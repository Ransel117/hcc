#pragma once

#include <stdint.h>
#include <stdio.h>

// ===========================================
//
//
// General
//
//
// ===========================================

#ifndef static_assert
#define static_assert _Static_assert
#endif

#ifndef noreturn
#define noreturn _Noreturn
#endif

#ifndef alignof
#define alignof _Alignof
#endif

#ifndef alignas
#define alignas _Alignas
#endif

#ifndef thread_local
#define thread_local _Thread_local
#endif

#ifndef bool
#define bool _Bool
#endif

#ifndef true
#define true 1
#endif

#ifndef false
#define false 0
#endif

#ifndef hcc_max_align_t
#define hcc_max_align_t void*
#endif

#define HCC_DEFINE_ID(Name) typedef struct Name { uint32_t idx_plus_one; } Name
HCC_DEFINE_ID(HccStringId);
HCC_DEFINE_ID(HccConstantId);
#define HccStringId(id) (HccStringId){id}
#define HccConstantId(id) (HccConstantId){id}

typedef struct HccCompiler HccCompiler;
typedef struct HccTask HccTask;
typedef struct HccAST HccAST;
typedef struct HccAML HccAML;
typedef struct HccPPMacro HccPPMacro;
typedef struct HccCodeFile HccCodeFile;
typedef struct HccLocation HccLocation;
typedef struct HccTarget HccTarget;
typedef struct HccCU HccCU;

// ===========================================
//
//
// Result
//
//
// ===========================================

typedef int16_t HccResultCode;
enum HccResultCode {
	//
	// success codes are positive
	//
	HCC_SUCCESS,
	HCC_SUCCESS_IS_NEW,

	HCC_SUCCESS_COUNT,

	//
	// errors are negative
	//

	HCC_ERROR_ALLOCATION_FAILURE = -10000, // HccResult.value == HccAllocTag
	HCC_ERROR_COLLECTION_FULL,    // HccResult.value == HccAllocTag
	HCC_ERROR_MESSAGES,
	HCC_ERROR_NOT_FINISHED,
	HCC_ERROR_FILE_OPEN_READ,
	HCC_ERROR_FILE_READ,
	HCC_ERROR_OPEN_OUTPUT_FILE,

	HCC_ERROR_THREAD_INIT,
	HCC_ERROR_THREAD_WAIT_FOR_TERMINATION,
	HCC_ERROR_SEMAPHORE_GIVE,
	HCC_ERROR_SEMAPHORE_TAKE,
	HCC_ERROR_MUTEX_LOCK,
	HCC_ERROR_MUTEX_UNLOCK,

	HCC_ERROR_END,
#define HCC_ERROR_COUNT (HCC_ERROR_END - HCC_ERROR_ALLOCATION_FAILURE)
};

typedef struct HccResult HccResult;
struct HccResult {
	HccResultCode code;
	int32_t       value;
	char*         stacktrace;
};
#define HccResult(code, value, stacktrace) ((HccResult) { code, value, stacktrace })

#define HCC_RESULT_SUCCESS ((HccResult){0})
#define HCC_IS_SUCCESS(result) (result.code >= 0)
#define HCC_ENSURE(expr) { HccResult result__ = (expr); if (result__.code < 0) { hcc_result_print(#expr, result__); exit(1); } }

extern const char* hcc_success_strings[HCC_SUCCESS_COUNT];
extern const char* hcc_error_strings[HCC_ERROR_COUNT];
void hcc_result_print(char* what, HccResult result);

// ===========================================
//
//
// IO Interface
//
//
// ===========================================

typedef struct HccIIO HccIIO;
typedef uintptr_t (*HccIIOReadFn)(HccIIO* iio, void* data_out, uintptr_t size);
typedef uintptr_t (*HccIIOWriteFn)(HccIIO* iio, const void* data, uintptr_t size);
typedef uintptr_t (*HccIIOWriteFmtFn)(HccIIO* iio, const char* fmt, va_list va_args);

struct HccIIO {
	void*            handle;
	uintptr_t        cursor;
	uintptr_t        size;
	HccIIOReadFn     read_fn;
	HccIIOWriteFn    write_fn;
	HccIIOWriteFmtFn write_fmt_fn;
	bool             ascii_colors_enabled;
};

HccIIO hcc_iio_file(FILE* f);
HccIIO hcc_iio_memory(void* data, uintptr_t size);
bool hcc_iio_get_ascii_colors_enabled(HccIIO* iio);
void hcc_iio_set_ascii_colors_enabled(HccIIO* iio, bool enabled);
uintptr_t hcc_iio_read(HccIIO* iio, void* data_out, uintptr_t size);
uintptr_t hcc_iio_write(HccIIO* iio, const void* data, uintptr_t size);
uintptr_t hcc_iio_write_fmt(HccIIO* iio, const char* fmt, ...);
#ifdef __GNUC__
uintptr_t hcc_iio_write_fmt(HccIIO* iio, const char* fmt, ...) __attribute__ ((format (printf, 2, 3)));
#else
uintptr_t hcc_iio_write_fmt(HccIIO* iio, const char* fmt, ...);
#endif

// ===========================================
//
//
// Allocation Tagging
//
//
// ===========================================

typedef uint16_t HccAllocTag;
enum HccAllocTag {
	HCC_ALLOC_TAG_NONE,
	HCC_ALLOC_TAG_GLOBAL_MEM_ARENA,
	HCC_ALLOC_TAG_CODE,
	HCC_ALLOC_TAG_STRING_TABLE_ENTRIES,
	HCC_ALLOC_TAG_STRING_TABLE_DATA,
	HCC_ALLOC_TAG_STRING_TABLE_ID_TO_ENTRY_MAP,
	HCC_ALLOC_TAG_WORKER_CALL_STACKS,
	HCC_ALLOC_TAG_WORKER_JOB_QUEUE,
	HCC_ALLOC_TAG_ATA_TEXT,
	HCC_ALLOC_TAG_ATA_BINARY,
	HCC_ALLOC_TAG_ATA,
	HCC_ALLOC_TAG_AST_TEXT,
	HCC_ALLOC_TAG_AST_BINARY,
	HCC_ALLOC_TAG_AST,
	HCC_ALLOC_TAG_AML_TEXT,
	HCC_ALLOC_TAG_AML_BINARY,
	HCC_ALLOC_TAG_AML,
	HCC_ALLOC_TAG_WORKER_STRING_BUFFER,
	HCC_ALLOC_TAG_WORKER_ARENA,

	HCC_ALLOC_TAG_CU_GLOBAL_DECLARATIONS,
	HCC_ALLOC_TAG_CU_STRUCT_DECLARATIONS,
	HCC_ALLOC_TAG_CU_UNION_DECLARATIONS,
	HCC_ALLOC_TAG_CU_ENUM_DECLARATIONS,

	HCC_ALLOC_TAG_DATA_TYPE_TABLE_ARRAYS,
	HCC_ALLOC_TAG_DATA_TYPE_TABLE_COMPOUNDS,
	HCC_ALLOC_TAG_DATA_TYPE_TABLE_COMPOUND_FIELDS,
	HCC_ALLOC_TAG_DATA_TYPE_TABLE_TYPEDEFS,
	HCC_ALLOC_TAG_DATA_TYPE_TABLE_ENUMS,
	HCC_ALLOC_TAG_DATA_TYPE_TABLE_ENUM_VALUES,
	HCC_ALLOC_TAG_DATA_TYPE_TABLE_POINTERS,
	HCC_ALLOC_TAG_DATA_TYPE_TABLE_BUFFERS,
	HCC_ALLOC_TAG_DATA_TYPE_TABLE_ARRAYS_DEDUP_HASH_TABLE,
	HCC_ALLOC_TAG_DATA_TYPE_TABLE_POINTERS_DEDUP_HASH_TABLE,
	HCC_ALLOC_TAG_DATA_TYPE_TABLE_BUFFERS_DEDUP_HASH_TABLE,
	HCC_ALLOC_TAG_DATA_TYPE_TABLE_ANON_COMPOUND_DEDUP_HASH_TABLE,

	HCC_ALLOC_TAG_ATA_TOKEN_BAG_TOKENS,
	HCC_ALLOC_TAG_ATA_TOKEN_BAG_LOCATIONS,
	HCC_ALLOC_TAG_ATA_TOKEN_BAG_VALUES,
	HCC_ALLOC_TAG_AST_FILE_MACROS,
	HCC_ALLOC_TAG_AST_FILE_MACRO_PARAMS,
	HCC_ALLOC_TAG_AST_FILE_PRAGMA_ONCED_FILES,
	HCC_ALLOC_TAG_AST_FILE_UNIQUE_INCLUDED_FILES,
	HCC_ALLOC_TAG_AST_FILE_GLOBAL_DECLARATIONS,
	HCC_ALLOC_TAG_AST_FILE_STRUCT_DECLARATIONS,
	HCC_ALLOC_TAG_AST_FILE_UNION_DECLARATIONS,
	HCC_ALLOC_TAG_AST_FILE_ENUM_DECLARATIONS,
	HCC_ALLOC_TAG_AST_FILES_HASH_TABLE,
	HCC_ALLOC_TAG_AST_FUNCTION_PARAMS_AND_VARIABLES,
	HCC_ALLOC_TAG_AST_FUNCTIONS,
	HCC_ALLOC_TAG_AST_EXPRS,
	HCC_ALLOC_TAG_AST_GLOBAL_VARIBALES,
	HCC_ALLOC_TAG_AST_UNSUPPORTED_INTRINSICTYPE_USED,

	HCC_ALLOC_TAG_PPGEN_EXPAND_STACK,
	HCC_ALLOC_TAG_PPGEN_EXPAND_MACRO_IDX_STACK,
	HCC_ALLOC_TAG_PPGEN_STRINGIFY_BUFFER,
	HCC_ALLOC_TAG_PPGEN_IF_STACK,
	HCC_ALLOC_TAG_PPGEN_MACRO_DECLARATIONS,
	HCC_ALLOC_TAG_PPGEN_MACRO_ARGS_STACK,
	HCC_ALLOC_TAG_ATAGEN_PAUSED_FILE_STACK,
	HCC_ALLOC_TAG_ATAGEN_OPEN_BRACKET_STACK,

	HCC_ALLOC_TAG_ASTGEN_VARIABLE_STACK_STRINGS,
	HCC_ALLOC_TAG_ASTGEN_VARIABLE_STACK_VAR_INDICES,
	HCC_ALLOC_TAG_ASTGEN_COMPOUND_FIELD_NAMES,
	HCC_ALLOC_TAG_ASTGEN_COMPOUND_FIELD_LOCATIONS,
	HCC_ALLOC_TAG_ASTGEN_COMPOUND_TYPE_FIND_FIELDS,
	HCC_ALLOC_TAG_ASTGEN_COMPOUND_FIELDS,
	HCC_ALLOC_TAG_ASTGEN_FUNCTION_PARAMS_AND_VARIABLES,
	HCC_ALLOC_TAG_ASTGEN_ENUM_VALUES,

	HCC_ALLOC_TAG_COUNT,
};

typedef uint8_t HccAllocMode;
enum HccAllocMode {
	HCC_ALLOC_MODE_ALLOC,
	HCC_ALLOC_MODE_DEALLOC,
};

typedef void (*HccAllocEventFn)(void* userdata, HccAllocMode mode, HccAllocTag tag, void* addr, uintptr_t size);

extern const char* hcc_alloc_tag_strings[HCC_ALLOC_TAG_COUNT];

typedef struct HccTrackedMem HccTrackedMem;
struct HccTrackedMem {
	HccAllocTag tag;
	void*       addr;
	uintptr_t   size;
};

typedef struct HccMemTrackerIter HccMemTrackerIter;

HccMemTrackerIter* hcc_mem_tracker_iter_start();
void hcc_mem_tracker_iter_finish(HccMemTrackerIter* iter);
bool hcc_mem_tracker_iter_next(HccMemTrackerIter* iter, HccTrackedMem* out);

void hcc_mem_tracker_log(HccIIO* iio);

// ===========================================
//
//
// String
//
//
// ===========================================

typedef struct HccString HccString;
struct HccString {
	char* data;
	uintptr_t size;
};

#define hcc_string(data, size) ((HccString) { data, size })
#define hcc_string_lit(lit) ((HccString) { lit, sizeof(lit) - 1 })
#define hcc_string_c(string) ((HccString) { string, strlen(string) })
#define hcc_string_c_path(string) ((HccString) { string, strlen(string) + 1 })

// ===========================================
//
//
// Time Utilities
//
//
// ===========================================

typedef struct HccDuration HccDuration;
struct HccDuration {
	uint64_t secs;
	uint32_t nanosecs;
};

typedef uint8_t HccTimeMode;
enum HccTimeMode {
	// will follow the realtime system time, is effected by system time changes
	// use this if you want the system time.
	HCC_TIME_MODE_REALTIME,
	// some arbitrary time that is used as a reference point and not effected by system time.
	// use this to measure a duration between two times.
	HCC_TIME_MODE_MONOTONIC,
};

typedef struct HccTime HccTime;
struct HccTime {
	uint64_t secs;
	uint32_t nanosecs;
};

HccTime hcc_time_now(HccTimeMode mode);
HccDuration hcc_time_elapsed(HccTime time, HccTimeMode mode);
HccDuration hcc_time_diff(HccTime to, HccTime from);

#define hcc_duration_init(secs_, nanosecs_) (HccDuration) { .secs = secs_, .nanosecs = nanosecs_ }
#define hcc_duration_from_millisecs(millisecs) (HccDuration) { .secs = (millisecs) / 1000, .nanosecs = ((millisecs) % 1000) * 1000000 }
#define hcc_duration_from_microsecs(microsecs) (HccDuration) { .secs = (microsecs) / 1000000, .nanosecs = ((microsecs) % 1000000) * 1000 }
#define hcc_duration_from_nanosecs(nanosecs_) (HccDuration) { .secs = (nanosecs_) / 1000000000, .nanosecs = (nanosecs_) % 1000000000 }

bool hcc_duration_has_secs(HccDuration duration);
bool hcc_duration_has_millisecs(HccDuration duration);
bool hcc_duration_has_microsecs(HccDuration duration);
bool hcc_duration_has_nanosecs(HccDuration duration);
float hcc_duration_to_f32_secs(HccDuration duration);
double hcc_duration_to_f64_secs(HccDuration duration);
float hcc_duration_to_f32_millisecs(HccDuration duration);
double hcc_duration_to_f64_millisecs(HccDuration duration);
float hcc_duration_to_f32_microsecs(HccDuration duration);
double hcc_duration_to_f64_microsecs(HccDuration duration);
uint64_t hcc_duration_secs(HccDuration duration);
uint64_t hcc_duration_millisecs(HccDuration duration);
uint64_t hcc_duration_microsecs(HccDuration duration);
uint64_t hcc_duration_nanosecs(HccDuration duration);
uint64_t hcc_duration_frame_to_fps(HccDuration duration);
HccDuration hcc_duration_add(HccDuration a, HccDuration b);
HccDuration hcc_duration_sub(HccDuration a, HccDuration b);
bool hcc_duration_lt(HccDuration a, HccDuration b);
bool hcc_duration_gt(HccDuration a, HccDuration b);

void hcc_location_merge_apply(HccLocation* before, HccLocation* after);

// ===========================================
//
//
// Message: Error & Warn
//
//
// ===========================================

typedef uint32_t HccMessageCode;

typedef uint8_t HccMessageType;
enum HccMessageType {
	HCC_MESSAGE_TYPE_ERROR = 0x1,
	HCC_MESSAGE_TYPE_WARN = 0x2,

	HCC_MESSAGE_TYPE_COUNT,
};

typedef struct HccMessage HccMessage;
struct HccMessage {
	HccString      string; // points to HccMessageSys.message_strings
	HccMessageType type;
	HccMessageCode code;
	HccLocation*   location;
	HccLocation*   other_location;
};

typedef HccMessageCode HccErrorCode;
enum {
	HCC_ERROR_CODE_NONE,

	//
	// ATAGEN
	HCC_ERROR_CODE_INVALID_TOKEN_MACRO_IDENTIFIER,
	HCC_ERROR_CODE_INVALID_TOKEN_MACRO_PARAM_IDENTIFIER,
	HCC_ERROR_CODE_DUPLICATE_MACRO_PARAM_IDENTIFIER,
	HCC_ERROR_CODE_INVALID_MACRO_PARAM_DELIMITER,
	HCC_ERROR_CODE_MACRO_PARAM_VA_ARG_NOT_LAST,
	HCC_ERROR_CODE_MACRO_ALREADY_DEFINED,
	HCC_ERROR_CODE_INVALID_INCLUDE_OPERAND,
	HCC_ERROR_CODE_TOO_MANY_INCLUDE_OPERANDS,
	HCC_ERROR_CODE_INCLUDE_PATH_IS_EMPTY,
	HCC_ERROR_CODE_INCLUDE_PATH_DOES_NOT_EXIST,
	HCC_ERROR_CODE_FAILED_TO_OPEN_FILE_FOR_READ,
	HCC_ERROR_CODE_CONDITION_HAS_NO_PP_TOKENS,
	HCC_ERROR_CODE_INVALID_PP_BINARY_OP,
	HCC_ERROR_CODE_INVALID_PP_UNARY_EXPR,
	HCC_ERROR_CODE_EXPECTED_PARENTHESIS_CLOSE,
	HCC_ERROR_CODE_UNDEFINED_IDENTIFIER_IN_PP_EXPR,
	HCC_ERROR_CODE_EXPECTED_COLON_FOR_TERNARY_OP,
	HCC_ERROR_CODE_INVALID_PP_LINE_OPERANDS,
	HCC_ERROR_CODE_PP_LINE_MUST_BE_MORE_THAN_ZERO,
	HCC_ERROR_CODE_TOO_MANY_PP_LINE_OPERANDS,
	HCC_ERROR_CODE_PP_ERROR,
	HCC_ERROR_CODE_INVALID_PP_PRAGMA_OPERAND,
	HCC_ERROR_CODE_PP_PRAGMA_OPERAND_USED_IN_MAIN_FILE,
	HCC_ERROR_CODE_TOO_MANY_PP_PRAGMA_OPERANDS,
	HCC_ERROR_CODE_INVALID_TOKEN_PREPROCESSOR_DIRECTIVE,
	HCC_ERROR_CODE_INVALID_PREPROCESSOR_DIRECTIVE,
	HCC_ERROR_CODE_PP_ENDIF_BEFORE_IF,
	HCC_ERROR_CODE_PP_ELSEIF_CANNOT_FOLLOW_ELSE,
	HCC_ERROR_CODE_PP_IF_UNTERMINATED,
	HCC_ERROR_CODE_INVALID_PP_CONCAT_OPERANDS,
	HCC_ERROR_CODE_TOO_MANY_UNDEF_OPERANDS,
	HCC_ERROR_CODE_TOO_MANY_IFDEF_OPERANDS,
	HCC_ERROR_CODE_PP_DIRECTIVE_NOT_FIRST_ON_LINE,
	HCC_ERROR_CODE_INVALID_OCTAL_DIGIT,
	HCC_ERROR_CODE_MAX_UINT_OVERFLOW,
	HCC_ERROR_CODE_MAX_SINT_OVERFLOW,
	HCC_ERROR_CODE_MAX_SINT_OVERFLOW_DECIMAL,
	HCC_ERROR_CODE_MAX_FLOAT_OVERFLOW,
	HCC_ERROR_CODE_U_SUFFIX_ALREADY_USED,
	HCC_ERROR_CODE_U_SUFFIX_ON_FLOAT,
	HCC_ERROR_CODE_L_SUFFIX_ON_FLOAT,
	HCC_ERROR_CODE_LONG_DOUBLE_IS_UNSUPPORTED,
	HCC_ERROR_CODE_FLOAT_HAS_DOUBLE_FULL_STOP,
	HCC_ERROR_CODE_FLOAT_MUST_BE_DECIMAL,
	HCC_ERROR_CODE_FLOAT_SUFFIX_MUST_FOLLOW_DECIMAL_PLACE,
	HCC_ERROR_CODE_INVALID_INTEGER_LITERALS,
	HCC_ERROR_CODE_INVALID_FLOAT_LITERALS,
	HCC_ERROR_CODE_NO_BRACKETS_OPEN,
	HCC_ERROR_CODE_INVALID_CLOSE_BRACKET_PAIR,
	HCC_ERROR_CODE_UNCLOSED_STRING_LITERAL,
	HCC_ERROR_CODE_MACRO_STARTS_WITH_CONCAT,
	HCC_ERROR_CODE_STRINGIFY_MUST_BE_MACRO_PARAM,
	HCC_ERROR_CODE_INVALID_TOKEN,
	HCC_ERROR_CODE_INVALID_TOKEN_HASH_IN_PP_OPERAND,
	HCC_ERROR_CODE_EXPECTED_IDENTIFIER_PP_IF_DEFINED,
	HCC_ERROR_CODE_EXPECTED_PARENTHESIS_CLOSE_DEFINED,
	HCC_ERROR_CODE_INVALID_USE_OF_VA_ARGS,
	HCC_ERROR_CODE_VA_ARGS_IN_MACRO_PARAMETER,
	HCC_ERROR_CODE_NOT_ENOUGH_MACRO_ARGUMENTS,
	HCC_ERROR_CODE_TOO_MANY_MACRO_ARGUMENTS,

	//
	// ASTGEN
	HCC_ERROR_CODE_CANNOT_FIND_FIELD,
	HCC_ERROR_CODE_DUPLICATE_FIELD_IDENTIFIER,
	HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_CONDITION,
	HCC_ERROR_CODE_MISSING_SEMICOLON,
	HCC_ERROR_CODE_REDEFINITION_IDENTIFIER_GLOBAL,
	HCC_ERROR_CODE_FUNCTION_PROTOTYPE_MISMATCH,
	HCC_ERROR_CODE_EXPECTED_CURLY_OPEN_ENUM,
	HCC_ERROR_CODE_EXPECTED_CURLY_OPEN_ENUM_GOT_SEMICOLON,
	HCC_ERROR_CODE_EXPECTED_CURLY_OPEN_UNNAMED_ENUM,
	HCC_ERROR_CODE_REIMPLEMENTATION_DATA_TYPE,
	HCC_ERROR_CODE_EMPTY_ENUM,
	HCC_ERROR_CODE_EXPECTED_IDENTIFIER_ENUM_VALUE,
	HCC_ERROR_CODE_ENUM_VALUE_OVERFLOW,
	HCC_ERROR_CODE_ENUM_VALUE_INVALID_FORMAT,
	HCC_ERROR_CODE_ENUM_VALUE_INVALID_TERMINATOR_WITH_EXPLICIT_VALUE,
	HCC_ERROR_CODE_ENUM_VALUE_INVALID_TERMINATOR,
	HCC_ERROR_CODE_INTRINSIC_NOT_FOUND_FUNCTION,
	HCC_ERROR_CODE_INTRINSIC_NOT_FOUND_STRUCT,
	HCC_ERROR_CODE_INTRINSIC_NOT_FOUND_UNION,
	HCC_ERROR_CODE_INVALID_SPECIFIER_FOR_STRUCT,
	HCC_ERROR_CODE_INVALID_SPECIFIER_CONFIG_FOR_STRUCT,
	HCC_ERROR_CODE_NOT_AVAILABLE_FOR_UNION,
	HCC_ERROR_CODE_EXPECTED_CURLY_OPEN_ANON_STRUCT_TYPE,
	HCC_ERROR_CODE_EXPECTED_CURLY_OPEN_ANON_UNION_TYPE,
	HCC_ERROR_CODE_INVALID_SPECIFIER_FOR_STRUCT_FIELD,
	HCC_ERROR_CODE_INVALID_SPECIFIER_CONFIG_FOR_STRUCT_FIELD,
	HCC_ERROR_CODE_COMPOUND_FIELD_INVALID_TERMINATOR,
	HCC_ERROR_CODE_COMPOUND_FIELD_MISSING_NAME,
	HCC_ERROR_CODE_INTRINSIC_INVALID_COMPOUND_STRUCT_FIELDS_COUNT,
	HCC_ERROR_CODE_INTRINSIC_INVALID_COMPOUND_STRUCT_FIELD,
	HCC_ERROR_CODE_INTRINSIC_VECTOR_INVALID_SIZE_AND_ALIGN,
	HCC_ERROR_CODE_MISSING_RASTERIZER_STATE_SPECIFIER,
	HCC_ERROR_CODE_POSITION_ALREADY_SPECIFIED,
	HCC_ERROR_CODE_EXPECTED_PARENTHESIS_OPEN_ALIGNAS,
	HCC_ERROR_CODE_ALIGNAS_ON_SPECIAL_COMPOUND_DATA_TYPE,
	HCC_ERROR_CODE_INVALID_ALIGNAS_INT_CONSTANT,
	HCC_ERROR_CODE_INVALID_ALIGNAS_OPERAND,
	HCC_ERROR_CODE_EXPECTED_PARENTHESIS_CLOSE_ALIGNAS,
	HCC_ERROR_CODE_ALIGNAS_REDUCES_ALIGNMENT,
	HCC_ERROR_CODE_EXPECTED_PARENTHESIS_OPEN_RESOURCE_SET_SLOT,
	HCC_ERROR_CODE_RESOURCE_SET_SLOT_OUT_OF_BOUNDS,
	HCC_ERROR_CODE_RESOURCE_SET_MUST_BE_A_UINT,
	HCC_ERROR_CODE_EXPECTED_PARENTHESIS_CLOSE_RESOURCE_SET_SLOT,
	HCC_ERROR_CODE_CONST_BUFFER_IN_RESOURCES_USING_BINDLESS,
	HCC_ERROR_CODE_MATCHING_RESOURCE_SLOTS_IN_RESOURCES,
	HCC_ERROR_CODE_OVERFLOW_RESOURCE_CONSTANTS_SIZE,
	HCC_ERROR_CODE_POSITION_MUST_BE_VEC4_F32,
	HCC_ERROR_CODE_POSITION_NOT_SPECIFIED,
	HCC_ERROR_CODE_EXPECTED_TYPE_NAME,
	HCC_ERROR_CODE_EXPECTED_PARENTHESIS_OPEN_RESOURCE_TYPE_GENERIC,
	HCC_ERROR_CODE_EXPECTED_PARENTHESIS_CLOSE_RESOURCE_TYPE_GENERIC,
	HCC_ERROR_CODE_EXPECTED_POD_DATA_TYPE_FOR_BUFFER,
	HCC_ERROR_CODE_INVALID_TEXEL_TYPE,
	HCC_ERROR_CODE_INVALID_BUFFER_ELEMENT_TYPE,
	HCC_ERROR_CODE_INVALID_RESOURCE_TABLE_RESOURCE_MODEL,
	HCC_ERROR_CODE_UNSIGNED_OR_SIGNED_ON_NON_INT_TYPE,
	HCC_ERROR_CODE_COMPLEX_ON_NON_FLOAT_TYPE,
	HCC_ERROR_CODE_MULTIPLE_TYPES_SPECIFIED,
	HCC_ERROR_CODE_COMPLEX_UNSUPPORTED_AT_THIS_TIME,
	HCC_ERROR_CODE_UNSIGNED_AND_SIGNED,
	HCC_ERROR_CODE_ATOMIC_UNSUPPORTED_AT_THIS_TIME,
	HCC_ERROR_CODE_DUPLICATE_TYPE_SPECIFIER,
	HCC_ERROR_CODE_EXPECTED_IDENTIFIER_TYPEDEF,
	HCC_ERROR_CODE_INVALID_SPECIFIER_FOR_TYPEDEF,
	HCC_ERROR_CODE_INTRINSIC_NOT_FOUND_TYPEDEF,
	HCC_ERROR_CODE_INTRINSIC_INVALID_TYPEDEF,
	HCC_ERROR_CODE_TYPE_MISMATCH_IMPLICIT_CAST,
	HCC_ERROR_CODE_TYPE_MISMATCH,
	HCC_ERROR_CODE_UNSUPPORTED_BINARY_OPERATOR,
	HCC_ERROR_CODE_INVALID_CURLY_EXPR,
	HCC_ERROR_CODE_FIELD_DESIGNATOR_ON_ARRAY_TYPE,
	HCC_ERROR_CODE_EXPECTED_IDENTIFIER_FIELD_DESIGNATOR,
	HCC_ERROR_CODE_ARRAY_DESIGNATOR_ON_COMPOUND_TYPE,
	HCC_ERROR_CODE_EXPECTED_INTEGER_FOR_ARRAY_IDX,
	HCC_ERROR_CODE_ARRAY_INDEX_OUT_OF_BOUNDS,
	HCC_ERROR_CODE_ARRAY_DESIGNATOR_EXPECTED_SQUARE_BRACE_CLOSE,
	HCC_ERROR_CODE_EXPECTED_ASSIGN_OR_ARRAY_DESIGNATOR,
	HCC_ERROR_CODE_EXPECTED_ASSIGN_OR_FIELD_DESIGNATOR,
	HCC_ERROR_CODE_EXPECTED_ASSIGN,
	HCC_ERROR_CODE_UNARY_OPERATOR_NOT_SUPPORTED,
	HCC_ERROR_CODE_UNDECLARED_IDENTIFIER,
	HCC_ERROR_CODE_EXPECTED_PARENTHESIS_CLOSE_EXPR,
	HCC_ERROR_CODE_INVALID_CAST,
	HCC_ERROR_CODE_INVALID_CURLY_INITIALIZER_LIST_END,
	HCC_ERROR_CODE_SIZEALIGNOF_TYPE_OPERAND_NOT_WRAPPED,
	HCC_ERROR_CODE_EXPECTED_EXPR,
	HCC_ERROR_CODE_NOT_ENOUGH_FUNCTION_ARGS,
	HCC_ERROR_CODE_TOO_MANY_FUNCTION_ARGS,
	HCC_ERROR_CODE_INVALID_FUNCTION_ARG_DELIMITER,
	HCC_ERROR_CODE_ARRAY_SUBSCRIPT_EXPECTED_SQUARE_BRACE_CLOSE,
	HCC_ERROR_CODE_EXPECTED_IDENTIFIER_FIELD_ACCESS,
	HCC_ERROR_CODE_MISSING_COLON_TERNARY_OP,
	HCC_ERROR_CODE_PARENTHISES_USED_ON_NON_FUNCTION,
	HCC_ERROR_CODE_SQUARE_BRACE_USED_ON_NON_ARRAY_DATA_TYPE,
	HCC_ERROR_CODE_FULL_STOP_USED_ON_NON_COMPOUND_DATA_TYPE,
	HCC_ERROR_CODE_CANNOT_ASSIGN_TO_CONST,
	HCC_ERROR_CODE_EXPECTED_PARENTHESIS_OPEN_CONDITION_EXPR,
	HCC_ERROR_CODE_EXPECTED_PARENTHESIS_CLOSE_CONDITION_EXPR,
	HCC_ERROR_CODE_EXPECTED_ARRAY_SIZE,
	HCC_ERROR_CODE_EXPECTED_INTEGER_CONSTANT_ARRAY_SIZE,
	HCC_ERROR_CODE_ARRAY_SIZE_CANNOT_BE_NEGATIVE,
	HCC_ERROR_CODE_ARRAY_SIZE_CANNOT_BE_ZERO,
	HCC_ERROR_CODE_ARRAY_DECL_EXPECTED_SQUARE_BRACE_CLOSE,
	HCC_ERROR_CODE_UNSUPPORTED_SPECIFIER,
	HCC_ERROR_CODE_SPECIFIER_ALREADY_BEEN_USED,
	HCC_ERROR_CODE_UNUSED_SPECIFIER,
	HCC_ERROR_CODE_UNSUPPORTED_INTRINSIC_TYPE_USED,
	HCC_ERROR_CODE_INVALID_SPECIFIER_VARIABLE_DECL,
	HCC_ERROR_CODE_INVALID_SPECIFIER_FUNCTION_DECL,
	HCC_ERROR_CODE_REDEFINITION_IDENTIFIER_LOCAL,
	HCC_ERROR_CODE_STATIC_VARIABLE_INITIALIZER_MUST_BE_CONSTANT,
	HCC_ERROR_CODE_INVALID_VARIABLE_DECL_TERMINATOR,
	HCC_ERROR_CODE_INVALID_ELSE,
	HCC_ERROR_CODE_INVALID_SWITCH_CONDITION_TYPE,
	HCC_ERROR_CODE_EXPECTED_CURLY_OPEN_SWITCH_STATEMENT,
	HCC_ERROR_CODE_EXPECTED_WHILE_CONDITION_FOR_DO_WHILE,
	HCC_ERROR_CODE_EXPECTED_PARENTHESIS_OPEN_FOR,
	HCC_ERROR_CODE_EXPECTED_IDENTIFIER_FOR_VARIABLE_DECL,
	HCC_ERROR_CODE_EXPECTED_PARENTHESIS_CLOSE_FOR,
	HCC_ERROR_CODE_CASE_STATEMENT_OUTSIDE_OF_SWITCH,
	HCC_ERROR_CODE_SWITCH_CASE_VALUE_MUST_BE_A_CONSTANT,
	HCC_ERROR_CODE_EXPECTED_COLON_SWITCH_CASE,
	HCC_ERROR_CODE_DEFAULT_STATMENT_OUTSIDE_OF_SWITCH,
	HCC_ERROR_CODE_DEFAULT_STATEMENT_ALREADY_DECLARED,
	HCC_ERROR_CODE_EXPECTED_COLON_SWITCH_DEFAULT,
	HCC_ERROR_CODE_INVALID_BREAK_STATEMENT_USAGE,
	HCC_ERROR_CODE_INVALID_CONTINUE_STATEMENT_USAGE,
	HCC_ERROR_CODE_MULTIPLE_SHADER_STAGES_ON_FUNCTION,
	HCC_ERROR_CODE_VERTEX_SHADER_MUST_RETURN_RASTERIZER_STATE,
	HCC_ERROR_CODE_FRAGMENT_SHADER_MUST_RETURN_FRAGMENT_STATE,
	HCC_ERROR_CODE_EXPECTED_IDENTIFIER_FUNCTION_PARAM,
	HCC_ERROR_CODE_REDEFINITION_IDENTIFIER_FUNCTION_PARAM,
	HCC_ERROR_CODE_FUNCTION_SHADER_PROTOTYPE_VERTEX_INVALID_COUNT,
	HCC_ERROR_CODE_FUNCTION_SHADER_PROTOTYPE_VERTEX_INVALID_INPUT,
	HCC_ERROR_CODE_FUNCTION_SHADER_PROTOTYPE_FRAGMENT_INVALID_COUNT,
	HCC_ERROR_CODE_FUNCTION_SHADER_PROTOTYPE_FRAGMENT_INVALID_INPUT,
	HCC_ERROR_CODE_FUNCTION_SHADER_PROTOTYPE_FRAGMENT_INVALID_RASTERIZER_STATE,
	HCC_ERROR_CODE_INTRINSIC_INVALID_FUNCTION_RETURN_DATA_TYPE,
	HCC_ERROR_CODE_INTRINSIC_INVALID_FUNCTION_PARAMS_COUNT,
	HCC_ERROR_CODE_INTRINSIC_INVALID_FUNCTION_PARAM_DATA_TYPE,
	HCC_ERROR_CODE_FUNCTION_INVALID_TERMINATOR,
	HCC_ERROR_CODE_EXPECTED_SHADER_PARAM_TO_BE_CONST,
	HCC_ERROR_CODE_CANNOT_CALL_SHADER_FUNCTION,
	HCC_ERROR_CODE_CANNOT_CALL_UNIMPLEMENTED_FUNCTION,
	HCC_ERROR_CODE_REDEFINITION_OF_FUNCTION_MISMATCH_PARAM_DATA_TYPE,
	HCC_ERROR_CODE_REDEFINITION_OF_FUNCTION_TOO_MANY_PARAMETERS,
	HCC_ERROR_CODE_REDEFINITION_OF_FUNCTION_NOT_ENOUGH_PARAMETERS,
	HCC_ERROR_CODE_REDEFINITION_OF_FUNCTION_BODY_ALREADY_DECLARED,
	HCC_ERROR_CODE_FUNCTION_RECURSION,
	HCC_ERROR_CODE_UNEXPECTED_TOKEN_FUNCTION_PROTOTYPE_END,
	HCC_ERROR_CODE_UNEXPECTED_TOKEN,
	HCC_ERROR_CODE_INVALID_DATA_TYPE_RASTERIZER_STATE,
	HCC_ERROR_CODE_INVALID_DATA_TYPE_FRAGMENT_STATE,
	HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_COMPOUND_DATA_TYPE,
	HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_BUFFER_ELEMENT,
	HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_RESOURCE_SET,
	HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_RESOURCE_TABLE,
	HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_RESOURCES_BINDING,
	HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_RESOURCES_BINDING_AND_BINDLESS,
	HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_FUNCTION_PARAM,
	HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_FUNCTION_PARAM_INLINE,
	HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_VARIABLE,
	HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_POINTER_DATA_TYPE,
	HCC_ERROR_CODE_ONLY_SINGLE_POINTERS_ARE_SUPPORTED,
	HCC_ERROR_CODE_POINTER_TO_RESOURCE_SET_TABLE_MUST_BE_CONST,
	HCC_ERROR_CODE_LOGICAL_ADDRESSED_VAR_USED_BEFORE_ASSIGNED,
	HCC_ERROR_CODE_LOGICAL_ADDRESSED_CONDITIONALLY_ASSIGNED_BEFORE_USE,
	HCC_ERROR_CODE_NON_CONST_STATIC_VARIABLE_CANNOT_BE_LOGICALLY_ADDRESSED,
	HCC_ERROR_CODE_DECLARATION_MISMATCH,
	HCC_ERROR_CODE_INCOMPLETE_TYPE_USED_BY_VALUE,

	HCC_ERROR_CODE_COUNT,
};

typedef HccMessageCode HccWarnCode;
enum {
	HCC_WARN_CODE_NONE,

	//
	// ATAGEN
	HCC_WARN_CODE_PP_WARNING,

	//
	// ASTGEN
	HCC_WARN_CODE_CURLY_INITIALIZER_ON_SCALAR,
	HCC_WARN_CODE_UNUSED_INITIALIZER_REACHED_END,
	HCC_WARN_CODE_NO_DESIGNATOR_AFTER_DESIGNATOR,

	HCC_WARN_CODE_COUNT,
};

void hcc_message_print(HccIIO* iio, HccMessage* message);

void hcc_message_pushv(HccTask* t, HccMessageType type, HccMessageCode code, HccLocation* location, HccLocation* other_location, va_list va_args);
void hcc_message_push(HccTask* t, HccMessageType type, HccMessageCode code, HccLocation* location, HccLocation* other_location, ...);
void hcc_error_pushv(HccTask* t, HccErrorCode error_code, HccLocation* location, HccLocation* other_location, va_list va_args);
void hcc_error_push(HccTask* t, HccErrorCode error_code, HccLocation* location, HccLocation* other_location, ...);
void hcc_warn_pushv(HccTask* t, HccWarnCode warn_code, HccLocation* location, HccLocation* other_location, va_list va_args);
void hcc_warn_push(HccTask* t, HccWarnCode warn_code, HccLocation* location, HccLocation* other_location, ...);

// ===========================================
//
//
// AML Intrinsic Type
//
//
// ===========================================

typedef uint8_t HccAMLIntrinsicDataType;
enum HccAMLIntrinsicDataType {
	HCC_AML_INTRINSIC_DATA_TYPE_VOID = 0x0,
	HCC_AML_INTRINSIC_DATA_TYPE_BOOL = 0x1,
	HCC_AML_INTRINSIC_DATA_TYPE_S8 =   0x2,
	HCC_AML_INTRINSIC_DATA_TYPE_S16 =  0x3,
	HCC_AML_INTRINSIC_DATA_TYPE_S32 =  0x4,
	HCC_AML_INTRINSIC_DATA_TYPE_S64 =  0x5,
	HCC_AML_INTRINSIC_DATA_TYPE_U8 =   0x6,
	HCC_AML_INTRINSIC_DATA_TYPE_U16 =  0x7,
	HCC_AML_INTRINSIC_DATA_TYPE_U32 =  0x8,
	HCC_AML_INTRINSIC_DATA_TYPE_U64 =  0x9,
	HCC_AML_INTRINSIC_DATA_TYPE_F16 =  0xa,
	HCC_AML_INTRINSIC_DATA_TYPE_F32 =  0xb,
	HCC_AML_INTRINSIC_DATA_TYPE_F64 =  0xc,

	HCC_AML_INTRINSIC_DATA_TYPE_SCALAR_COUNT = 13,

	HCC_AML_INTRINSIC_DATA_TYPE_BOOLX2 =  0x11,
	HCC_AML_INTRINSIC_DATA_TYPE_S8X2 =    0x12,
	HCC_AML_INTRINSIC_DATA_TYPE_S16X2 =   0x13,
	HCC_AML_INTRINSIC_DATA_TYPE_S32X2 =   0x14,
	HCC_AML_INTRINSIC_DATA_TYPE_S64X2 =   0x15,
	HCC_AML_INTRINSIC_DATA_TYPE_U8X2 =    0x16,
	HCC_AML_INTRINSIC_DATA_TYPE_U16X2 =   0x17,
	HCC_AML_INTRINSIC_DATA_TYPE_U32X2 =   0x18,
	HCC_AML_INTRINSIC_DATA_TYPE_U64X2 =   0x19,
	HCC_AML_INTRINSIC_DATA_TYPE_F16X2 =   0x1a,
	HCC_AML_INTRINSIC_DATA_TYPE_F32X2 =   0x1b,
	HCC_AML_INTRINSIC_DATA_TYPE_F64X2 =   0x1c,

	HCC_AML_INTRINSIC_DATA_TYPE_BOOLX3 =  0x21,
	HCC_AML_INTRINSIC_DATA_TYPE_S8X3 =    0x22,
	HCC_AML_INTRINSIC_DATA_TYPE_S16X3 =   0x23,
	HCC_AML_INTRINSIC_DATA_TYPE_S32X3 =   0x24,
	HCC_AML_INTRINSIC_DATA_TYPE_S64X3 =   0x25,
	HCC_AML_INTRINSIC_DATA_TYPE_U8X3 =    0x26,
	HCC_AML_INTRINSIC_DATA_TYPE_U16X3 =   0x27,
	HCC_AML_INTRINSIC_DATA_TYPE_U32X3 =   0x28,
	HCC_AML_INTRINSIC_DATA_TYPE_U64X3 =   0x29,
	HCC_AML_INTRINSIC_DATA_TYPE_F16X3 =   0x2a,
	HCC_AML_INTRINSIC_DATA_TYPE_F32X3 =   0x2b,
	HCC_AML_INTRINSIC_DATA_TYPE_F64X3 =   0x2c,

	HCC_AML_INTRINSIC_DATA_TYPE_BOOLX4 =  0x31,
	HCC_AML_INTRINSIC_DATA_TYPE_S8X4 =    0x32,
	HCC_AML_INTRINSIC_DATA_TYPE_S16X4 =   0x33,
	HCC_AML_INTRINSIC_DATA_TYPE_S32X4 =   0x34,
	HCC_AML_INTRINSIC_DATA_TYPE_S64X4 =   0x35,
	HCC_AML_INTRINSIC_DATA_TYPE_U8X4 =    0x36,
	HCC_AML_INTRINSIC_DATA_TYPE_U16X4 =   0x37,
	HCC_AML_INTRINSIC_DATA_TYPE_U32X4 =   0x38,
	HCC_AML_INTRINSIC_DATA_TYPE_U64X4 =   0x39,
	HCC_AML_INTRINSIC_DATA_TYPE_F16X4 =   0x3a,
	HCC_AML_INTRINSIC_DATA_TYPE_F32X4 =   0x3b,
	HCC_AML_INTRINSIC_DATA_TYPE_F64X4 =   0x3c,

	HCC_AML_INTRINSIC_DATA_TYPE_F16X2X2 = 0x5a,
	HCC_AML_INTRINSIC_DATA_TYPE_F32X2X3 = 0x9b,
	HCC_AML_INTRINSIC_DATA_TYPE_F64X2X4 = 0xdc,

	HCC_AML_INTRINSIC_DATA_TYPE_F16X3X2 = 0x6a,
	HCC_AML_INTRINSIC_DATA_TYPE_F32X3X3 = 0xab,
	HCC_AML_INTRINSIC_DATA_TYPE_F64X3X4 = 0xec,

	HCC_AML_INTRINSIC_DATA_TYPE_F16X4X2 = 0x7a,
	HCC_AML_INTRINSIC_DATA_TYPE_F32X4X3 = 0xbb,
	HCC_AML_INTRINSIC_DATA_TYPE_F64X4X4 = 0xfc,

	HCC_AML_INTRINSIC_DATA_TYPE_COUNT = 256,
};

//
// format constants
#define HCC_AML_INTRINSIC_DATA_TYPE_SCALAR_MASK   0x0f
#define HCC_AML_INTRINSIC_DATA_TYPE_COLUMNS_MASK  0x30
#define HCC_AML_INTRINSIC_DATA_TYPE_COLUMNS_SHIFT 4
#define HCC_AML_INTRINSIC_DATA_TYPE_ROWS_MASK     0xc0
#define HCC_AML_INTRINSIC_DATA_TYPE_ROWS_SHIFT    6

//
// initializer
#define HCC_AML_INTRINSIC_DATA_TYPE(type, columns, rows) \
( \
	(HCC_AML_INTRINSIC_DATA_TYPE_##type) | \ \
	(((columns - 1) << HCC_AML_INTRINSIC_DATA_TYPE_COLUMNS_SHIFT) & HCC_AML_INTRINSIC_DATA_TYPE_COLUMNS_MASK) | \
	((((rows) - 1) << HCC_AML_INTRINSIC_DATA_TYPE_ROWS_COUNT_SHIFT) & HCC_AML_INTRINSIC_DATA_TYPE_ROWS_COUNT_MASK) \
)

//
// extraction utilities
#define HCC_AML_INTRINSIC_DATA_TYPE_SCALAR(type)  ((type) & HCC_AML_INTRINSIC_DATA_TYPE_SCALAR_MASK)
#define HCC_AML_INTRINSIC_DATA_TYPE_COLUMNS(type) ((((type) & HCC_AML_INTRINSIC_DATA_TYPE_COLUMNS_MASK) >> HCC_AML_INTRINSIC_DATA_TYPE_COLUMNS_SHIFT) + 1)
#define HCC_AML_INTRINSIC_DATA_TYPE_ROWS(type)    ((((type) & HCC_AML_INTRINSIC_DATA_TYPE_ROWS_MASK) >> HCC_AML_INTRINSIC_DATA_TYPE_ROWS_SHIFT) + 1)

extern const char* hcc_aml_intrinsic_data_type_scalar_strings[HCC_AML_INTRINSIC_DATA_TYPE_SCALAR_COUNT];
extern uint8_t hcc_aml_intrinsic_data_type_scalar_size_aligns[HCC_AML_INTRINSIC_DATA_TYPE_SCALAR_COUNT];

// ===========================================
//
//
// AML Scalar Data Type Mask
//
//
// ===========================================

typedef uint16_t HccAMLScalarDataTypeMask;
#define HCC_AML_SCALAR_DATA_TYPE_MASK_SET(ptr, aml_intrinsic_type) (*(ptr)) |= (1 << (aml_intrinsic_type))
#define HCC_AML_SCALAR_DATA_TYPE_MASK_UNSET(ptr, aml_intrinsic_type) (*(ptr)) &= ~(1 << (aml_intrinsic_type))
#define HCC_AML_SCALAR_DATA_TYPE_MASK_IS_SET(v, aml_intrinsic_type) ((bool)((v) & (1 << (aml_intrinsic_type))))

HccString hcc_aml_scalar_data_type_mask_string(HccAMLScalarDataTypeMask mask);

// ===========================================
//
//
// Resource Data Type
//
//
// ===========================================

typedef uint8_t HccTextureDim;
enum HccTextureDim {
	HCC_TEXTURE_DIM_1D =   0,
	HCC_TEXTURE_DIM_2D =   1,
	HCC_TEXTURE_DIM_3D =   2,
	HCC_TEXTURE_DIM_CUBE = 3,
};

typedef uint16_t HccResourceDataType;
enum HccResourceDataType {
	HCC_RESOURCE_DATA_TYPE_CONSTBUFFER =   0,
	HCC_RESOURCE_DATA_TYPE_BUFFER =        1,
	HCC_RESOURCE_DATA_TYPE_TEXTURE =       2,
	HCC_RESOURCE_DATA_TYPE_SAMPLER_STATE = 3,
	HCC_RESOURCE_DATA_TYPE_COUNT =         4,
};

//
// format constants
#define HCC_RESOURCE_DATA_TYPE_TYPE_MASK   0x0003
#define HCC_RESOURCE_DATA_TYPE_AUX_MASK    0xfffc
#define HCC_RESOURCE_DATA_TYPE_AUX_SHIFT   2

//
// format aux constants for HCC_RESOURCE_DATA_TYPE_TEXTURE
#define HCC_RESOURCE_DATA_TYPE_TEXTURE_IS_ARRAY_MASK        0x0004
#define HCC_RESOURCE_DATA_TYPE_TEXTURE_IS_MS_MASK           0x0008
#define HCC_RESOURCE_DATA_TYPE_TEXTURE_DIM_MASK             0x0030
#define HCC_RESOURCE_DATA_TYPE_TEXTURE_DIM_SHIFT            4
#define HCC_RESOURCE_DATA_TYPE_TEXTURE_INTRINSIC_TYPE_MASK  0x03c0
#define HCC_RESOURCE_DATA_TYPE_TEXTURE_INTRINSIC_TYPE_SHIFT 6

//
// extraction utilities
#define HCC_RESOURCE_DATA_TYPE_TYPE(type) ((type) & HCC_RESOURCE_DATA_TYPE_TYPE_MASK)
#define HCC_RESOURCE_DATA_TYPE_AUX(type)  (((type) & HCC_RESOURCE_DATA_TYPE_AUX_MASK) >> HCC_RESOURCE_DATA_TYPE_AUX_SHIFT)

//
// extraction utilities for HCC_RESOURCE_DATA_TYPE_TEXTURE aux
#define HCC_RESOURCE_DATA_TYPE_TEXTURE_IS_ARRAY(type)        (!!((type) & HCC_RESOURCE_DATA_TYPE_TEXTURE_IS_ARRAY_MASK))
#define HCC_RESOURCE_DATA_TYPE_TEXTURE_IS_MS(type)           (!!((type) & HCC_RESOURCE_DATA_TYPE_TEXTURE_IS_MS_MASK))
#define HCC_RESOURCE_DATA_TYPE_TEXTURE_DIM(type)             (((type) & HCC_RESOURCE_DATA_TYPE_TEXTURE_DIM_MASK) >> HCC_RESOURCE_DATA_TYPE_TEXTURE_DIM_SHIFT)
#define HCC_RESOURCE_DATA_TYPE_TEXTURE_INTRINISIC_TYPE(type) (((type) & HCC_RESOURCE_DATA_TYPE_TEXTURE_INTRINISIC_TYPE_MASK) >> HCC_RESOURCE_DATA_TYPE_TEXTURE_INTRINISIC_TYPE_SHIFT)

//
// initialization
#define HCC_RESOURCE_DATA_TYPE_CONSTBUFFER(idx) \
( \
	HCC_RESOURCE_DATA_TYPE_CONSTBUFFER | \
	(((idx) << HCC_RESOURCE_DATA_TYPE_AUX_SHIFT) & HCC_RESOURCE_DATA_TYPE_AUX_MASK) \
)

#define HCC_RESOURCE_DATA_TYPE_BUFFER(idx) \
( \
	HCC_RESOURCE_DATA_TYPE_BUFFER | \
	(((idx) << HCC_RESOURCE_DATA_TYPE_AUX_SHIFT) & HCC_RESOURCE_DATA_TYPE_AUX_MASK) \
)

#define HCC_RESOURCE_DATA_TYPE_TEXTURE(dim, intrinsic_type, is_array, is_ms) \
( \
	HCC_RESOURCE_DATA_TYPE_TEXTURE | \
	(((dim) << HCC_RESOURCE_DATA_TYPE_TEXTURE_DIM_SHIFT) & HCC_RESOURCE_DATA_TYPE_TEXTURE_DIM_MASK) | \
	(((intrinsic_type) << HCC_RESOURCE_DATA_TYPE_TEXTURE_INTRINSIC_TYPE_SHIFT) & HCC_RESOURCE_DATA_TYPE_TEXTURE_INTRINSIC_TYPE_MASK) | \
	((is_array) ? HCC_RESOURCE_DATA_TYPE_TEXTURE_IS_ARRAY_MASK : 0) | \
	((is_ms) ? HCC_RESOURCE_DATA_TYPE_TEXTURE_IS_MS_MASK : 0) \
)

// ===========================================
//
//
// AST Basic Data Type
//
//
// ===========================================

typedef uint8_t HccASTBasicDataType;
enum HccASTBasicDataType {
	HCC_AST_BASIC_DATA_TYPE_VOID =       0,
	HCC_AST_BASIC_DATA_TYPE_BOOL =       1,
	HCC_AST_BASIC_DATA_TYPE_CHAR =       2,
	HCC_AST_BASIC_DATA_TYPE_SCHAR =      3,
	HCC_AST_BASIC_DATA_TYPE_SSHORT =     4,
	HCC_AST_BASIC_DATA_TYPE_SINT =       5,
	HCC_AST_BASIC_DATA_TYPE_SLONG =      6,
	HCC_AST_BASIC_DATA_TYPE_SLONGLONG =  7,
	HCC_AST_BASIC_DATA_TYPE_UCHAR =      8,
	HCC_AST_BASIC_DATA_TYPE_USHORT =     9,
	HCC_AST_BASIC_DATA_TYPE_UINT =      10,
	HCC_AST_BASIC_DATA_TYPE_ULONG =     11,
	HCC_AST_BASIC_DATA_TYPE_ULONGLONG = 12,
	HCC_AST_BASIC_DATA_TYPE_FLOAT =     13,
	HCC_AST_BASIC_DATA_TYPE_DOUBLE =    14,
	HCC_AST_BASIC_DATA_TYPE_COUNT =     15,
};

#define HCC_AST_BASIC_DATA_TYPE_IS_INT(type) ( \
	(type) >= HCC_AST_BASIC_DATA_TYPE_CHAR && \
	(type) <= HCC_AST_BASIC_DATA_TYPE_ULONGLONG \
)
#define HCC_AST_BASIC_DATA_TYPE_IS_SINT(cu, type) \
( \
	( \
		(type) >= HCC_AST_BASIC_DATA_TYPE_SCHAR && \
		(type) <= HCC_AST_BASIC_DATA_TYPE_SLONGLONG \
	) || \
	( \
		(type) == HCC_AST_BASIC_DATA_TYPE_CHAR && \
		!hcc_options_is_char_unsigned((cu)->options) \
	) \
)

#define HCC_AST_BASIC_DATA_TYPE_IS_UINT(cu, type) \
( \
	( \
		(type) >= HCC_AST_BASIC_DATA_TYPE_UCHAR && \
		(type) <= HCC_AST_BASIC_DATA_TYPE_ULONGLONG \
	) || \
	( \
		(type) == HCC_AST_BASIC_DATA_TYPE_CHAR && \
		hcc_options_is_char_unsigned((cu)->options) \
	) \
)
#define HCC_AST_BASIC_DATA_TYPE_IS_FLOAT(type) ((type) == HCC_AST_BASIC_DATA_TYPE_FLOAT || (type) == HCC_AST_BASIC_DATA_TYPE_DOUBLE)

extern uint8_t hcc_ast_data_type_basic_type_ranks[HCC_AST_BASIC_DATA_TYPE_COUNT];
extern const char* hcc_ast_data_type_basic_type_strings[HCC_AST_BASIC_DATA_TYPE_COUNT];
extern uint8_t hcc_ast_basic_type_size_and_aligns_x86_64_linux[HCC_AST_BASIC_DATA_TYPE_COUNT];
extern uint64_t hcc_ast_basic_type_int_mins_x86_64_linux[HCC_AST_BASIC_DATA_TYPE_COUNT];
extern uint64_t hcc_ast_basic_type_int_maxes_x86_64_linux[HCC_AST_BASIC_DATA_TYPE_COUNT];

// ===========================================
//
//
// Data Type
//
//
// ===========================================

typedef uint32_t HccDataType;
enum HccDataType {
	HCC_DATA_TYPE_AST_BASIC =      0, // HccASTBasicDataType
	HCC_DATA_TYPE_AML_INTRINSIC =  1, // HccAMLIntrinsicDataType
	HCC_DATA_TYPE_ENUM =           2, // index for HccDataTypeTable.enum_data_types
	HCC_DATA_TYPE_STRUCT =         3, // index for HccDataTypeTable.compound_data_types
	HCC_DATA_TYPE_UNION =          4, // index for HccDataTypeTable.compound_data_types
	HCC_DATA_TYPE_ARRAY =          5, // index for HccDataTypeTable.array_data_types
	HCC_DATA_TYPE_POINTER =        6, // index for HccDataTypeTable.pointer_data_types
	HCC_DATA_TYPE_TYPEDEF =        7, // index for HccDataTypeTable.typedefs
	HCC_DATA_TYPE_GENERIC_FLOAT =  8,
	HCC_DATA_TYPE_RESOURCE =       9, // HccResourceDataType
	HCC_DATA_TYPE_COUNT =         10,
#define HCC_DATA_TYPE_INVALID HCC_DATA_TYPE_COUNT
};

//
// format constants
#define HCC_DATA_TYPE_TYPE_MASK               0x0000000f // as HCC_DATA_TYPE_COUNT < 16
#define HCC_DATA_TYPE_CONST_QUALIFIER_MASK    0x00000010
#define HCC_DATA_TYPE_VOLATILE_QUALIFIER_MASK 0x00000020
#define HCC_DATA_TYPE_ATOMIC_QUALIFIER_MASK   0x00000040
#define HCC_DATA_TYPE_QUALIFIERS_MASK         0x00000070
#define HCC_DATA_TYPE_AUX_MASK                0xffffff80
#define HCC_DATA_TYPE_AUX_SHIFT               7

//
// extraction utilities
#define HCC_DATA_TYPE_TYPE(type)        ((type) & HCC_DATA_TYPE_TYPE_MASK)
#define HCC_DATA_TYPE_AUX(type)         (((type) & HCC_DATA_TYPE_AUX_MASK) >> HCC_DATA_TYPE_AUX_SHIFT)

//
// insertion utilities
#define HCC_DATA_TYPE_CONST(type)            ((type) | HCC_DATA_TYPE_CONST_QUALIFIER_MASK)
#define HCC_DATA_TYPE_VOLATILE(type)         ((type) | HCC_DATA_TYPE_VOLATILE_QUALIFIER_MASK)
#define HCC_DATA_TYPE_ATOMIC(type)           ((type) | HCC_DATA_TYPE_ATOMIC_QUALIFIER_MASK)

//
// removal utilities
#define HCC_DATA_TYPE_STRIP_CONST(type)      ((type) & ~HCC_DATA_TYPE_CONST_QUALIFIER_MASK)
#define HCC_DATA_TYPE_STRIP_VOLATILE(type)   ((type) & ~HCC_DATA_TYPE_VOLATILE_QUALIFIER_MASK)
#define HCC_DATA_TYPE_STRIP_ATOMIC(type)     ((type) & ~HCC_DATA_TYPE_ATOMIC_QUALIFIER_MASK)
#define HCC_DATA_TYPE_STRIP_QUALIFIERS(type) ((type) & ~HCC_DATA_TYPE_QUALIFIERS_MASK)

//
// initialization
#define HCC_DATA_TYPE(type, aux) ( \
	HCC_DATA_TYPE_##type | \
	((aux) << HCC_DATA_TYPE_AUX_SHIFT) \
)
#define HCC_DATA_TYPE_SCALARX(aml_intrinsic_data_type) HCC_DATA_TYPE(UNION, HCC_COMPOUND_DATA_TYPE_IDX_SCALARX_START + (aml_intrinsic_data_type))
#define HCC_DATA_TYPE_PSCALARX(aml_intrinsic_data_type) HCC_DATA_TYPE(STRUCT, HCC_COMPOUND_DATA_TYPE_IDX_PSCALARX_START + (aml_intrinsic_data_type))

//
// comparision utilities
#define HCC_DATA_TYPE_IS_CONST(type)         (!!((type) & HCC_DATA_TYPE_CONST_QUALIFIER_MASK))
#define HCC_DATA_TYPE_IS_VOLATILE(type)      (!!((type) & HCC_DATA_TYPE_VOLATILE_QUALIFIER_MASK))
#define HCC_DATA_TYPE_IS_ATOMIC(type)        (!!((type) & HCC_DATA_TYPE_ATOMIC_QUALIFIER_MASK))
#define HCC_DATA_TYPE_IS_AST_BASIC(type)     (HCC_DATA_TYPE_TYPE(type) == HCC_DATA_TYPE_AST_BASIC)
#define HCC_DATA_TYPE_IS_AML_INTRINSIC(type) (HCC_DATA_TYPE_TYPE(type) == HCC_DATA_TYPE_AML_INTRINSIC)
#define HCC_DATA_TYPE_IS_ENUM(type)          (HCC_DATA_TYPE_TYPE(type) == HCC_DATA_TYPE_ENUM)
#define HCC_DATA_TYPE_IS_STRUCT(type)        (HCC_DATA_TYPE_TYPE(type) == HCC_DATA_TYPE_STRUCT)
#define HCC_DATA_TYPE_IS_UNION(type)         (HCC_DATA_TYPE_TYPE(type) == HCC_DATA_TYPE_UNION)
#define HCC_DATA_TYPE_IS_ARRAY(type)         (HCC_DATA_TYPE_TYPE(type) == HCC_DATA_TYPE_ARRAY)
#define HCC_DATA_TYPE_IS_POINTER(type)       (HCC_DATA_TYPE_TYPE(type) == HCC_DATA_TYPE_POINTER)
#define HCC_DATA_TYPE_IS_TYPEDEF(type)       (HCC_DATA_TYPE_TYPE(type) == HCC_DATA_TYPE_TYPEDEF)
#define HCC_DATA_TYPE_IS_GENERIC_FLOAT(type) (HCC_DATA_TYPE_TYPE(type) == HCC_DATA_TYPE_GENERIC_FLOAT)
#define HCC_DATA_TYPE_IS_RESOURCE(type)      (HCC_DATA_TYPE_TYPE(type) == HCC_DATA_TYPE_RESOURCE)
#define HCC_DATA_TYPE_IS_COMPOUND(type)      (HCC_DATA_TYPE_IS_STRUCT(type) || HCC_DATA_TYPE_IS_UNION(type))
#define HCC_DATA_TYPE_IS_COMPOSITE(type)     (HCC_DATA_TYPE_IS_STRUCT(type) || HCC_DATA_TYPE_IS_UNION(type) || HCC_DATA_TYPE_IS_ARRAY(type))
#define HCC_DATA_TYPE_IS_PVECTOR(type)       (HCC_DATA_TYPE_IS_STRUCT(type) && HCC_STRUCT_IDX_PVEC_START <= HCC_DATA_TYPE_AUX(type) && HCC_DATA_TYPE_AUX(type) < HCC_STRUCT_IDX_PVEC_END)
#define HCC_DATA_TYPE_IS_VECTOR(type)        (HCC_DATA_TYPE_IS_UNION(type) && HCC_UNION_IDX_VEC_START <= HCC_DATA_TYPE_AUX(type) && HCC_DATA_TYPE_AUX(type) < HCC_UNION_IDX_VEC_END)
#define HCC_DATA_TYPE_IS_PMATRIX(type)       (HCC_DATA_TYPE_IS_STRUCT(type) && HCC_STRUCT_IDX_PMAT_START <= HCC_DATA_TYPE_AUX(type) && HCC_DATA_TYPE_AUX(type) < HCC_STRUCT_IDX_PMAT_END)
#define HCC_DATA_TYPE_IS_MATRIX(type)        (HCC_DATA_TYPE_IS_UNION(type) && HCC_UNION_IDX_MAT_START <= HCC_DATA_TYPE_AUX(type) && HCC_DATA_TYPE_AUX(type) < HCC_UNION_IDX_MAT_END)

#define HCC_DATA_TYPE_VOID                   HCC_DATA_TYPE(AST_BASIC, HCC_AST_BASIC_DATA_TYPE_VOID)
#define HCC_DATA_TYPE_INT                    HCC_DATA_TYPE(AST_BASIC, HCC_AST_BASIC_DATA_TYPE_SINT)
#define HCC_DATA_TYPE_UINT8_T                HCC_DATA_TYPE(TYPEDEF, HCC_TYPEDEF_IDX_UINT8_T)
#define HCC_DATA_TYPE_UINT16_T               HCC_DATA_TYPE(TYPEDEF, HCC_TYPEDEF_IDX_UINT16_T)
#define HCC_DATA_TYPE_UINT32_T               HCC_DATA_TYPE(TYPEDEF, HCC_TYPEDEF_IDX_UINT32_T)
#define HCC_DATA_TYPE_UINT64_T               HCC_DATA_TYPE(TYPEDEF, HCC_TYPEDEF_IDX_UINT64_T)
#define HCC_DATA_TYPE_UINTPTR_T              HCC_DATA_TYPE(TYPEDEF, HCC_TYPEDEF_IDX_UINTPTR_T)
#define HCC_DATA_TYPE_INT8_T                 HCC_DATA_TYPE(TYPEDEF, HCC_TYPEDEF_IDX_INT8_T)
#define HCC_DATA_TYPE_INT16_T                HCC_DATA_TYPE(TYPEDEF, HCC_TYPEDEF_IDX_INT16_T)
#define HCC_DATA_TYPE_INT32_T                HCC_DATA_TYPE(TYPEDEF, HCC_TYPEDEF_IDX_INT32_T)
#define HCC_DATA_TYPE_INT64_T                HCC_DATA_TYPE(TYPEDEF, HCC_TYPEDEF_IDX_INT64_T)
#define HCC_DATA_TYPE_INTPTR_T               HCC_DATA_TYPE(TYPEDEF, HCC_TYPEDEF_IDX_INTPTR_T)
#define HCC_DATA_TYPE_HALF                   HCC_DATA_TYPE(STRUCT, HCC_COMPOUND_DATA_TYPE_IDX_HALF)
#define HCC_DATA_TYPE_HALF_T                 HCC_DATA_TYPE(TYPEDEF, HCC_TYPEDEF_IDX_HALF)

// ===========================================
//
//
// Declarations
//
//
// ===========================================

//
// inherits HccDataType
typedef uint32_t HccDecl;
enum HccDecl {
	HCC_DECL_FUNCTION = HCC_DATA_TYPE_COUNT,
	HCC_DECL_ENUM_VALUE,
	HCC_DECL_LOCAL_VARIABLE,
	HCC_DECL_GLOBAL_VARIABLE,
};

//
// initialization
#define HCC_DECL(type, aux) ( \
	HCC_DECL_##type | \
	((aux) << HCC_DATA_TYPE_AUX_SHIFT) \
)

//
// comparison utilities
#define HCC_DECL_IS_DATA_TYPE(type) (HCC_DATA_TYPE_TYPE(type) < HCC_DATA_TYPE_COUNT)
#define HCC_DECL_IS_FUNCTION(type) (HCC_DATA_TYPE_TYPE(type) == HCC_DECL_FUNCTION)
#define HCC_DECL_IS_ENUM_VALUE(type) (HCC_DATA_TYPE_TYPE(type) == HCC_DECL_ENUM_VALUE)
#define HCC_DECL_IS_LOCAL_VARIABLE(type) (HCC_DATA_TYPE_TYPE(type) == HCC_DECL_LOCAL_VARIABLE)
#define HCC_DECL_IS_GLOBAL_VARIABLE(type) (HCC_DATA_TYPE_TYPE(type) == HCC_DECL_GLOBAL_VARIABLE)

#define HCC_DECL_AUX(type) HCC_DATA_TYPE_AUX(type)

HccLocation* hcc_decl_location(HccCU* cu, HccDecl decl);

// ===========================================
//
//
// Data Type Table
//
//
// ===========================================

typedef struct HccDataTypeTable HccDataTypeTable;
typedef struct HccArrayDataType HccArrayDataType;
typedef struct HccBufferDataType HccBufferDataType;
typedef struct HccPointerDataType HccPointerDataType;
typedef struct HccCompoundDataType HccCompoundDataType;
typedef struct HccCompoundField HccCompoundField;
typedef struct HccEnumDataType HccEnumDataType;
typedef struct HccEnumValue HccEnumValue;
typedef struct HccTypedef HccTypedef;

typedef struct HccDataTypeTableSetup HccDataTypeTableSetup;
struct HccDataTypeTableSetup {
	uint32_t arrays_grow_count;
	uint32_t arrays_reserve_cap;
	uint32_t compounds_grow_count;
	uint32_t compounds_reserve_cap;
	uint32_t compound_fields_grow_count;
	uint32_t compound_fields_reserve_cap;
	uint32_t typedefs_grow_count;
	uint32_t typedefs_reserve_cap;
	uint32_t enums_grow_count;
	uint32_t enums_reserve_cap;
	uint32_t enum_values_grow_count;
	uint32_t enum_values_reserve_cap;
	uint32_t pointers_grow_count;
	uint32_t pointers_reserve_cap;
	uint32_t buffers_grow_count;
	uint32_t buffers_reserve_cap;
};

typedef uint8_t HccBasicTypeClass;
enum HccBasicTypeClass {
	HCC_BASIC_TYPE_CLASS_VOID,
	HCC_BASIC_TYPE_CLASS_BOOL,
	HCC_BASIC_TYPE_CLASS_UINT,
	HCC_BASIC_TYPE_CLASS_SINT,
	HCC_BASIC_TYPE_CLASS_FLOAT,

	HCC_BASIC_TYPE_CLASS_COUNT,
};

typedef union HccBasic HccBasic;
union HccBasic {
	int8_t   s8;
	int16_t  s16;
	int32_t  s32;
	int64_t  s64;
	uint8_t  u8;
	uint16_t u16;
	uint32_t u32;
	uint64_t u64;
	float    f;
	double   d;
};

HccString hcc_data_type_string(HccCU* cu, HccDataType data_type);
void hcc_data_type_size_align(HccCU* cu, HccDataType data_type, uint64_t* size_out, uint64_t* align_out);
void hcc_data_type_print_basic(HccCU* cu, HccDataType data_type, void* data, HccIIO* iio);
bool hcc_data_type_is_condition(HccCU* cu, HccDataType data_type);
uint32_t hcc_data_type_composite_fields_count(HccCU* cu, HccDataType data_type);
bool hcc_data_type_is_rasterizer_state(HccCU* cu, HccDataType data_type);
bool hcc_data_type_is_fragment_state(HccCU* cu, HccDataType data_type);
HccCompoundDataType* hcc_data_type_get_resource_table(HccCU* cu, HccDataType data_type);
HccCompoundDataType* hcc_data_type_get_resource_set(HccCU* cu, HccDataType data_type);
bool hcc_data_type_is_resource_table_pointer(HccCU* cu, HccDataType data_type);
bool hcc_data_type_is_resource_set_pointer(HccCU* cu, HccDataType data_type);
bool hcc_data_type_is_resource_set_or_table_pointer(HccCU* cu, HccDataType data_type);
bool hcc_data_type_has_resources(HccCU* cu, HccDataType data_type);
HccDataType hcc_data_type_strip_pointer(HccCU* cu, HccDataType data_type);
HccDataType hcc_data_type_strip_all_pointers(HccCU* cu, HccDataType data_type);
HccLocation* hcc_data_type_location(HccCU* cu, HccDataType data_type);
HccDataType hcc_data_type_lower_ast_to_aml(HccCU* cu, HccDataType data_type);
HccAMLScalarDataTypeMask hcc_data_type_scalar_data_types_mask(HccCU* cu, HccDataType data_type);

HccBasicTypeClass hcc_basic_type_class(HccCU* cu, HccDataType data_type);
HccBasic hcc_basic_from_sint(HccCU* cu, HccDataType data_type, int64_t value);
HccBasic hcc_basic_from_uint(HccCU* cu, HccDataType data_type, uint64_t value);
HccBasic hcc_basic_from_float(HccCU* cu, HccDataType data_type, double value);

HccArrayDataType* hcc_array_data_type_get(HccCU* cu, HccDataType data_type);
HccDataType hcc_array_data_type_element_data_type(HccArrayDataType* dt);
HccConstantId hcc_array_data_type_element_count_constant_id(HccArrayDataType* dt);
uint64_t hcc_array_data_type_element_count(HccCU* cu, HccArrayDataType* dt);

HccBufferDataType* hcc_buffer_data_type_get(HccCU* cu, HccDataType data_type);
HccDataType hcc_buffer_data_type_element_data_type(HccBufferDataType* dt);

HccPointerDataType* hcc_pointer_data_type_get(HccCU* cu, HccDataType data_type);
HccDataType hcc_pointer_data_type_element_data_type(HccPointerDataType* dt);

HccCompoundDataType* hcc_compound_data_type_get(HccCU* cu, HccDataType data_type);
bool hcc_compound_data_type_is_struct(HccCompoundDataType* dt);
bool hcc_compound_data_type_is_union(HccCompoundDataType* dt);
HccLocation* hcc_compound_data_type_identifier_location(HccCompoundDataType* dt);
HccStringId hcc_compound_data_type_identifier_string_id(HccCompoundDataType* dt);
HccCompoundField* hcc_compound_data_type_fields(HccCompoundDataType* dt, uint32_t* fields_count_out);
void hcc_compound_data_type_size_align(HccCompoundDataType* dt, uint64_t* size_out, uint64_t* align_out);

HccLocation* hcc_compound_field_identifier_location(HccCompoundField* field);
HccStringId hcc_compound_field_identifier_string_id(HccCompoundField* field);
HccDataType hcc_compound_field_data_type(HccCompoundField* field);

HccEnumDataType* hcc_enum_data_type_get(HccCU* cu, HccDataType data_type);
HccLocation* hcc_enum_data_type_identifier_location(HccEnumDataType* dt);
HccStringId hcc_enum_data_type_identifier_string_id(HccEnumDataType* dt);
HccEnumValue* hcc_enum_data_type_values(HccEnumDataType* dt, uint32_t* values_count_out);

HccEnumValue* hcc_enum_value_get(HccCU* cu, HccDecl decl);
HccLocation* hcc_enum_value_identifier_location(HccEnumValue* value);
HccStringId hcc_enum_value_identifier_string_id(HccEnumValue* value);
HccConstantId hcc_enum_value_constant_id(HccEnumValue* value);
int32_t hcc_enum_value(HccCU* cu, HccEnumValue* value);

HccTypedef* hcc_typedef_get(HccCU* cu, HccDataType data_type);
HccLocation* hcc_typedef_identifier_location(HccTypedef* dt);
HccStringId hcc_typedef_identifier_string_id(HccTypedef* dt);
HccDataType hcc_typedef_aliased_data_type(HccTypedef* dt);
HccDataType hcc_typedef_resolve_and_keep_qualifiers(HccCU* cu, HccDataType data_type);
HccDataType hcc_typedef_resolve_and_strip_qualifiers(HccCU* cu, HccDataType data_type);

// ===========================================
//
//
// Constant
//
//
// ===========================================

typedef struct HccConstantTableSetup HccConstantTableSetup;
struct HccConstantTableSetup {
	uint32_t data_grow_size;
	uint32_t data_reserve_size;
	uint32_t entries_cap;
	uint32_t composite_fields_buffer_grow_count;
	uint32_t composite_fields_buffer_reserve_cap;
};

typedef struct HccConstant HccConstant;
struct HccConstant {
	void*       data;
	uint32_t    size;
	HccDataType data_type;
};

void hcc_constant_print(HccCU* ast, HccConstantId constant_id, HccIIO* iio);
bool hcc_constant_as_uint(HccCU* cu, HccConstant constant, uint64_t* out);
bool hcc_constant_as_sint(HccCU* cu, HccConstant constant, int64_t* out);
bool hcc_constant_as_sint32(HccCU* cu, HccConstant constant, int32_t* out);
bool hcc_constant_as_float(HccCU* cu, HccConstant constant, double* out);

// ===========================================
//
//
// Constant Table
//
//
// ===========================================

HccConstantId hcc_constant_table_deduplicate_basic(HccCU* cu, HccDataType data_type, HccBasic* basic);
HccConstantId* hcc_constant_table_deduplicate_composite_start(HccCU* cu, HccDataType data_type, uint32_t* fields_count_out);
HccConstantId hcc_constant_table_deduplicate_composite_end(HccCU* cu, HccDataType data_type, HccConstantId* fields, uint32_t fields_count);
HccConstantId hcc_constant_table_deduplicate_zero(HccCU* cu, HccDataType data_type);
HccConstant hcc_constant_table_get(HccCU* cu, HccConstantId id);

// ===========================================
//
//
// AST Expressions
//
//
// ===========================================

typedef uint8_t HccASTBinaryOp;
enum HccASTBinaryOp {
	HCC_AST_BINARY_OP_ASSIGN,
	HCC_AST_BINARY_OP_ADD,
	HCC_AST_BINARY_OP_SUBTRACT,
	HCC_AST_BINARY_OP_MULTIPLY,
	HCC_AST_BINARY_OP_DIVIDE,
	HCC_AST_BINARY_OP_MODULO,
	HCC_AST_BINARY_OP_BIT_AND,
	HCC_AST_BINARY_OP_BIT_OR,
	HCC_AST_BINARY_OP_BIT_XOR,
	HCC_AST_BINARY_OP_BIT_SHIFT_LEFT,
	HCC_AST_BINARY_OP_BIT_SHIFT_RIGHT,

	//
	// logical operators (return a bool)
	HCC_AST_BINARY_OP_EQUAL,
	HCC_AST_BINARY_OP_NOT_EQUAL,
	HCC_AST_BINARY_OP_LESS_THAN,
	HCC_AST_BINARY_OP_LESS_THAN_OR_EQUAL,
	HCC_AST_BINARY_OP_GREATER_THAN,
	HCC_AST_BINARY_OP_GREATER_THAN_OR_EQUAL,

	HCC_AST_BINARY_OP_LOGICAL_AND,
	HCC_AST_BINARY_OP_LOGICAL_OR,

	HCC_AST_BINARY_OP_TERNARY,
	HCC_AST_BINARY_OP_COMMA,

	HCC_AST_BINARY_OP_COUNT,
};

typedef uint8_t HccASTUnaryOp;
enum HccASTUnaryOp {
	HCC_AST_UNARY_OP_LOGICAL_NOT,
	HCC_AST_UNARY_OP_BIT_NOT,
	HCC_AST_UNARY_OP_PLUS,
	HCC_AST_UNARY_OP_NEGATE,
	HCC_AST_UNARY_OP_PRE_INCREMENT,
	HCC_AST_UNARY_OP_PRE_DECREMENT,
	HCC_AST_UNARY_OP_POST_INCREMENT,
	HCC_AST_UNARY_OP_POST_DECREMENT,
	HCC_AST_UNARY_OP_DEREF,
	HCC_AST_UNARY_OP_ADDRESS_OF,

	HCC_AST_UNARY_OP_COUNT,
};

extern uint8_t hcc_ast_unary_op_precedence[HCC_AST_UNARY_OP_COUNT];

// ===========================================
//
//
// AST Declarations
//
//
// ===========================================

typedef struct HccASTVariable HccASTVariable;
typedef struct HccASTFunction HccASTFunction;

typedef uint8_t HccASTFunctionShaderStage;
enum HccASTFunctionShaderStage {
	HCC_AST_FUNCTION_SHADER_STAGE_NONE,
	HCC_AST_FUNCTION_SHADER_STAGE_VERTEX,
	HCC_AST_FUNCTION_SHADER_STAGE_FRAGMENT,
	HCC_AST_FUNCTION_SHADER_STAGE_COMPUTE,
	HCC_AST_FUNCTION_SHADER_STAGE_MESHTASK,

	HCC_AST_FUNCTION_SHADER_STAGE_COUNT,
};

extern const char* hcc_ast_function_shader_stage_strings[HCC_AST_FUNCTION_SHADER_STAGE_COUNT];

HccASTVariable* hcc_ast_global_variable_get(HccCU* cu, HccDecl decl);
HccLocation* hcc_ast_variable_identifier_location(HccASTVariable* variable);
HccStringId hcc_ast_variable_identifier_string_id(HccASTVariable* variable);
HccDataType hcc_ast_variable_data_type(HccASTVariable* variable);
HccConstantId hcc_ast_variable_initializer_constant_id(HccASTVariable* variable);
void hcc_ast_variable_to_string(HccCU* cu, HccASTVariable* variable, HccIIO* iio);

HccASTFunction* hcc_ast_function_get(HccCU* cu, HccDecl decl);
HccASTFunctionShaderStage hcc_ast_function_shader_stage(HccASTFunction* function);
bool hcc_ast_function_is_inline(HccASTFunction* function);
bool hcc_ast_function_is_static(HccASTFunction* function);
bool hcc_ast_function_is_extern(HccASTFunction* function);
HccLocation* hcc_ast_function_identifier_location(HccASTFunction* function);
HccStringId hcc_ast_function_identifier_string_id(HccASTFunction* function);
HccDataType hcc_ast_function_return_data_type(HccASTFunction* function);
HccLocation* hcc_ast_function_return_data_type_location(HccASTFunction* function);
uint8_t hcc_ast_function_params_count(HccASTFunction* function);
uint16_t hcc_ast_function_variables_count(HccASTFunction* function);
HccASTVariable* hcc_ast_function_params_and_variables(HccASTFunction* function);
void hcc_ast_function_to_string(HccCU* cu, HccASTFunction* function, HccIIO* iio);

// ===========================================
//
//
// Preprocessor
//
//
// ===========================================

typedef struct HccPPMacro HccPPMacro;

HccStringId hcc_pp_macro_get_identifier_string_id(HccPPMacro* macro);
HccString hcc_pp_macro_get_identifier_string(HccPPMacro* macro);
HccLocation* hcc_pp_macro_get_location(HccPPMacro* macro);
HccStringId* hcc_pp_macro_get_params(HccPPMacro* macro, uint32_t* params_count_out);

// ===========================================
//
//
// ATA Token
//
//
// ===========================================

#define HCC_ATA_TOKEN_IDX_INVALID UINT32_MAX

typedef uint8_t HccATAToken;
enum {
	HCC_ATA_TOKEN_EOF,
	HCC_ATA_TOKEN_IDENT,
	HCC_ATA_TOKEN_STRING,
	HCC_ATA_TOKEN_INCLUDE_PATH_SYSTEM,
	HCC_ATA_TOKEN_BACK_SLASH,
	HCC_ATA_TOKEN_HASH,
	HCC_ATA_TOKEN_DOUBLE_HASH,
	HCC_ATA_TOKEN_MACRO_WHITESPACE,
	HCC_ATA_TOKEN_MACRO_PARAM,
	HCC_ATA_TOKEN_MACRO_STRINGIFY,
	HCC_ATA_TOKEN_MACRO_STRINGIFY_WHITESPACE,
	HCC_ATA_TOKEN_MACRO_CONCAT,
	HCC_ATA_TOKEN_MACRO_CONCAT_WHITESPACE,

	//
	// symbols
	//
#define HCC_ATA_TOKEN_BRACKET_START HCC_ATA_TOKEN_CURLY_OPEN
	HCC_ATA_TOKEN_CURLY_OPEN,
	HCC_ATA_TOKEN_CURLY_CLOSE,
	HCC_ATA_TOKEN_PARENTHESIS_OPEN,
	HCC_ATA_TOKEN_PARENTHESIS_CLOSE,
	HCC_ATA_TOKEN_SQUARE_OPEN,
	HCC_ATA_TOKEN_SQUARE_CLOSE,
#define HCC_ATA_TOKEN_BRACKET_END   (HCC_ATA_TOKEN_SQUARE_CLOSE + 1)
#define HCC_ATA_TOKEN_BRACKET_COUNT (HCC_ATA_TOKEN_BRACKET_END - HCC_ATA_TOKEN_BRACKET_START)

	HCC_ATA_TOKEN_FULL_STOP,
	HCC_ATA_TOKEN_COMMA,
	HCC_ATA_TOKEN_SEMICOLON,
	HCC_ATA_TOKEN_COLON,
	HCC_ATA_TOKEN_PLUS,
	HCC_ATA_TOKEN_MINUS,
	HCC_ATA_TOKEN_FORWARD_SLASH,
	HCC_ATA_TOKEN_ASTERISK,
	HCC_ATA_TOKEN_PERCENT,
	HCC_ATA_TOKEN_AMPERSAND,
	HCC_ATA_TOKEN_PIPE,
	HCC_ATA_TOKEN_CARET,
	HCC_ATA_TOKEN_EXCLAMATION_MARK,
	HCC_ATA_TOKEN_QUESTION_MARK,
	HCC_ATA_TOKEN_TILDE,
	HCC_ATA_TOKEN_EQUAL,
	HCC_ATA_TOKEN_LESS_THAN,
	HCC_ATA_TOKEN_GREATER_THAN,

	//
	// grouped symbols
	//
	HCC_ATA_TOKEN_LOGICAL_AND,
	HCC_ATA_TOKEN_LOGICAL_OR,
	HCC_ATA_TOKEN_LOGICAL_EQUAL,
	HCC_ATA_TOKEN_LOGICAL_NOT_EQUAL,
	HCC_ATA_TOKEN_LESS_THAN_OR_EQUAL,
	HCC_ATA_TOKEN_GREATER_THAN_OR_EQUAL,
	HCC_ATA_TOKEN_BIT_SHIFT_LEFT,
	HCC_ATA_TOKEN_BIT_SHIFT_RIGHT,
	HCC_ATA_TOKEN_ADD_ASSIGN,
	HCC_ATA_TOKEN_SUBTRACT_ASSIGN,
	HCC_ATA_TOKEN_MULTIPLY_ASSIGN,
	HCC_ATA_TOKEN_DIVIDE_ASSIGN,
	HCC_ATA_TOKEN_MODULO_ASSIGN,
	HCC_ATA_TOKEN_BIT_SHIFT_LEFT_ASSIGN,
	HCC_ATA_TOKEN_BIT_SHIFT_RIGHT_ASSIGN,
	HCC_ATA_TOKEN_BIT_AND_ASSIGN,
	HCC_ATA_TOKEN_BIT_XOR_ASSIGN,
	HCC_ATA_TOKEN_BIT_OR_ASSIGN,
	HCC_ATA_TOKEN_INCREMENT,
	HCC_ATA_TOKEN_DECREMENT,

#define HCC_ATA_TOKEN_LIT_NUMBERS_START HCC_ATA_TOKEN_LIT_UINT
	HCC_ATA_TOKEN_LIT_UINT,
	HCC_ATA_TOKEN_LIT_ULONG,
	HCC_ATA_TOKEN_LIT_ULONGLONG,
	HCC_ATA_TOKEN_LIT_SINT,
	HCC_ATA_TOKEN_LIT_SLONG,
	HCC_ATA_TOKEN_LIT_SLONGLONG,
	HCC_ATA_TOKEN_LIT_FLOAT,
	HCC_ATA_TOKEN_LIT_DOUBLE,
#define HCC_ATA_TOKEN_LIT_NUMBERS_END (HCC_ATA_TOKEN_LIT_DOUBLE + 1)

	//
	// keywords
	//
#define HCC_ATA_TOKEN_KEYWORDS_START HCC_ATA_TOKEN_KEYWORD_VOID
	HCC_ATA_TOKEN_KEYWORD_VOID,
	HCC_ATA_TOKEN_KEYWORD_BOOL,
	HCC_ATA_TOKEN_KEYWORD_CHAR,
	HCC_ATA_TOKEN_KEYWORD_SHORT,
	HCC_ATA_TOKEN_KEYWORD_INT,
	HCC_ATA_TOKEN_KEYWORD_LONG,
	HCC_ATA_TOKEN_KEYWORD_FLOAT,
	HCC_ATA_TOKEN_KEYWORD_DOUBLE,
	HCC_ATA_TOKEN_KEYWORD_GENERIC_FLOAT,
	HCC_ATA_TOKEN_KEYWORD_UNSIGNED,
	HCC_ATA_TOKEN_KEYWORD_SIGNED,
	HCC_ATA_TOKEN_KEYWORD_COMPLEX,
	HCC_ATA_TOKEN_KEYWORD_ATOMIC,
	HCC_ATA_TOKEN_KEYWORD_RETURN,
	HCC_ATA_TOKEN_KEYWORD_IF,
	HCC_ATA_TOKEN_KEYWORD_ELSE,
	HCC_ATA_TOKEN_KEYWORD_DO,
	HCC_ATA_TOKEN_KEYWORD_WHILE,
	HCC_ATA_TOKEN_KEYWORD_FOR,
	HCC_ATA_TOKEN_KEYWORD_SWITCH,
	HCC_ATA_TOKEN_KEYWORD_CASE,
	HCC_ATA_TOKEN_KEYWORD_DEFAULT,
	HCC_ATA_TOKEN_KEYWORD_BREAK,
	HCC_ATA_TOKEN_KEYWORD_CONTINUE,
	HCC_ATA_TOKEN_KEYWORD_TRUE,
	HCC_ATA_TOKEN_KEYWORD_FALSE,
	HCC_ATA_TOKEN_KEYWORD_VERTEX,
	HCC_ATA_TOKEN_KEYWORD_FRAGMENT,
	HCC_ATA_TOKEN_KEYWORD_GEOMETRY,
	HCC_ATA_TOKEN_KEYWORD_TESSELLATION,
	HCC_ATA_TOKEN_KEYWORD_COMPUTE,
	HCC_ATA_TOKEN_KEYWORD_MESHTASK,
	HCC_ATA_TOKEN_KEYWORD_ENUM,
	HCC_ATA_TOKEN_KEYWORD_STRUCT,
	HCC_ATA_TOKEN_KEYWORD_UNION,
	HCC_ATA_TOKEN_KEYWORD_TYPEDEF,
	HCC_ATA_TOKEN_KEYWORD_STATIC,
	HCC_ATA_TOKEN_KEYWORD_CONST,
	HCC_ATA_TOKEN_KEYWORD_AUTO,
	HCC_ATA_TOKEN_KEYWORD_REGISTER,
	HCC_ATA_TOKEN_KEYWORD_VOLATILE,
	HCC_ATA_TOKEN_KEYWORD_EXTERN,
	HCC_ATA_TOKEN_KEYWORD_INLINE,
	HCC_ATA_TOKEN_KEYWORD_NO_RETURN,
	HCC_ATA_TOKEN_KEYWORD_SIZEOF,
	HCC_ATA_TOKEN_KEYWORD_ALIGNOF,
	HCC_ATA_TOKEN_KEYWORD_ALIGNAS,
	HCC_ATA_TOKEN_KEYWORD_STATIC_ASSERT,
	HCC_ATA_TOKEN_KEYWORD_RESTRICT,
	HCC_ATA_TOKEN_KEYWORD_INTRINSIC,
	HCC_ATA_TOKEN_KEYWORD_RASTERIZER_STATE,
	HCC_ATA_TOKEN_KEYWORD_FRAGMENT_STATE,
	HCC_ATA_TOKEN_KEYWORD_BUFFER_ELEMENT,
	HCC_ATA_TOKEN_KEYWORD_RESOURCE_SET,
	HCC_ATA_TOKEN_KEYWORD_RESOURCE_TABLE,
	HCC_ATA_TOKEN_KEYWORD_RESOURCES,
	HCC_ATA_TOKEN_KEYWORD_POSITION,
	HCC_ATA_TOKEN_KEYWORD_NOINTERP,
	HCC_ATA_TOKEN_KEYWORD_CONSTBUFFER,
	HCC_ATA_TOKEN_KEYWORD_BUFFER,
	HCC_ATA_TOKEN_KEYWORD_TEXTURE1D,
	HCC_ATA_TOKEN_KEYWORD_TEXTURE1DARRAY,
	HCC_ATA_TOKEN_KEYWORD_TEXTURE2D,
	HCC_ATA_TOKEN_KEYWORD_TEXTURE2DARRAY,
	HCC_ATA_TOKEN_KEYWORD_TEXTURE2DMS,
	HCC_ATA_TOKEN_KEYWORD_TEXTURE2DMSARRAY,
	HCC_ATA_TOKEN_KEYWORD_TEXTURECUBE,
	HCC_ATA_TOKEN_KEYWORD_TEXTURECUBEARRAY,
	HCC_ATA_TOKEN_KEYWORD_TEXTURECUBEMS,
	HCC_ATA_TOKEN_KEYWORD_TEXTURECUBEMSARRAY,
	HCC_ATA_TOKEN_KEYWORD_TEXTURE3D,
	HCC_ATA_TOKEN_KEYWORD_SAMPLERSTATE,
#define HCC_ATA_TOKEN_KEYWORDS_END HCC_ATA_TOKEN_COUNT
#define HCC_ATA_TOKEN_KEYWORDS_COUNT (HCC_ATA_TOKEN_KEYWORDS_END - HCC_ATA_TOKEN_KEYWORDS_START)
#define HCC_ATA_TOKEN_IS_KEYWORD(token) (HCC_ATA_TOKEN_KEYWORDS_START <= (token) && (token) < HCC_ATA_TOKEN_KEYWORDS_END)
#define HCC_ATA_TOKEN_IS_LIT_NUMBER(token) (HCC_ATA_TOKEN_LIT_NUMBERS_START <= (token) && (token) < HCC_ATA_TOKEN_LIT_NUMBERS_END)

	HCC_ATA_TOKEN_COUNT,
};

extern const char* hcc_ata_token_strings[HCC_ATA_TOKEN_COUNT];

bool hcc_ata_token_has_value(HccATAToken token);
uint32_t hcc_ata_token_num_values(HccATAToken token);
bool hcc_ata_token_concat_is_okay(HccATAToken before, HccATAToken after);

// ===========================================
//
//
// ATA Value
//
//
// ===========================================

typedef union HccATAValue HccATAValue;
union HccATAValue {
	HccConstantId constant_id;
	HccStringId   string_id;
	uint32_t      macro_param_idx;
};
static_assert(sizeof(HccATAValue) == sizeof(uint32_t), "HccATAValue has been designed around being 32 bits!");
#define HccATAValue(raw) ((HccATAValue){ { raw } })

// ===========================================
//
//
// ATA Iterator
//
//
// ===========================================

typedef struct HccATAIter HccATAIter;
typedef struct HccASTFile HccASTFile;

HccATAIter* hcc_ata_iter_start(HccASTFile* file);
void hcc_ata_iter_finish(HccASTFile* file, HccATAIter* iter);

HccATAToken hcc_ata_iter_next(HccATAIter* iter);
HccATAToken hcc_ata_iter_peek(HccATAIter* iter);
HccATAToken hcc_ata_iter_peek_ahead(HccATAIter* iter, uint32_t by);
HccLocation* hcc_ata_iter_location(HccATAIter* iter);
HccATAValue hcc_ata_iter_next_value(HccATAIter* iter);
HccATAValue hcc_ata_iter_peek_value(HccATAIter* iter);

// ===========================================
//
//
// AST File
//
//
// ===========================================

typedef struct HccASTFile HccASTFile;

typedef struct HccASTFileSetup HccASTFileSetup;
struct HccASTFileSetup {
	uint32_t macros_grow_count;
	uint32_t macros_reserve_cap;
	uint32_t macro_params_grow_count;
	uint32_t macro_params_reserve_cap;
	uint32_t tokens_grow_count;
	uint32_t tokens_reserve_cap;
	uint32_t values_grow_count;
	uint32_t values_reserve_cap;
	uint32_t unique_include_files_grow_count;
	uint32_t unique_include_files_reserve_cap;
};

HccString hcc_ast_file_get_path(HccASTFile* file);
HccPPMacro* hcc_ast_file_get_macros(HccASTFile* file, uint32_t* macros_count_out);
HccATAIter* hcc_ast_file_get_ata_iter(HccASTFile* file);
HccStringId* hcc_ast_file_unique_included_files(HccASTFile* file, uint32_t* count_out);

void hcc_ast_file_reset(HccASTFile* file);
HccResult hcc_ast_file_push_token(HccASTFile* file, HccATAToken token, HccLocation* location);
HccResult hcc_ast_file_push_value(HccASTFile* file, HccATAValue value);
bool hcc_ast_file_pop_token(HccASTFile* file);

// ===========================================
//
//
// AST - Abstract Syntax Tree
//
//
// ===========================================

typedef struct HccAST HccAST;

typedef struct HccASTSetup HccASTSetup;
struct HccASTSetup {
	uint32_t        files_cap;
	HccASTFileSetup file_setup;
	uint32_t        function_params_and_variables_grow_count;
	uint32_t        function_params_and_variables_reserve_cap;
	uint32_t        functions_grow_count;
	uint32_t        functions_reserve_cap;
	uint32_t        exprs_grow_count;
	uint32_t        exprs_reserve_cap;
	uint32_t        expr_locations_grow_count;
	uint32_t        expr_locations_reserve_cap;
	uint32_t        global_variables_grow_count;
	uint32_t        global_variables_reserve_cap;
};

// ===========================================
//
//
// AML - Abstract Machine Language
//
//
// ===========================================

typedef struct HccAML HccAML;

typedef struct HccAMLSetup HccAMLSetup;
struct HccAMLSetup {
	uint32_t        placeholder;
};

// ===========================================
//
//
// Compilation Unit
//
//
// ===========================================
//
// this is not a traditional compiliation unit from the sense
// of a single C source file and all of it's includes.
// we actually allow multiple C source files to be compiled
// into a single AST and therefore a single binary.
//

typedef struct HccCU HccCU;

typedef struct HccCUSetup HccCUSetup;
struct HccCUSetup {
	HccDataTypeTableSetup dtt;
	HccConstantTableSetup constant_table;
	HccASTSetup           ast;
	HccAMLSetup           aml;
};

HccDataTypeTable* hcc_cu_get_data_type_table(HccCU* cu);
HccAST* hcc_cu_get_ast(HccCU* cu);
HccAML* hcc_cu_get_aml(HccCU* cu);

// ===========================================
//
//
// Compiler Target
//
//
// ===========================================

typedef uint16_t HccTargetArch;
enum HccTargetArch {
	HCC_TARGET_ARCH_X86_64,

	HCC_TARGET_ARCH_COUNT,
};

typedef uint16_t HccTargetOS;
enum HccTargetOS {
	HCC_TARGET_OS_LINUX,
	HCC_TARGET_OS_MAC_OS,
	HCC_TARGET_OS_WINDOWS,
	HCC_TARGET_OS_ANDROID,
	HCC_TARGET_OS_IOS,

	HCC_TARGET_OS_COUNT,
};

typedef uint16_t HccTargetGfxAPI;
enum HccTargetGfxAPI {
	HCC_TARGET_GFX_API_OPENGL,
	HCC_TARGET_GFX_API_VULKAN,
	HCC_TARGET_GFX_API_DX11,
	HCC_TARGET_GFX_API_DX12,
	HCC_TARGET_GFX_API_METAL,

	HCC_TARGET_GFX_API_COUNT,
};

typedef uint16_t HccTargetFormat;
enum HccTargetFormat {
	HCC_TARGET_FORMAT_SPIR_V,
	HCC_TARGET_FORMAT_DXIL,
	HCC_TARGET_FORMAT_METAL,
	HCC_TARGET_FORMAT_GLSL,
	HCC_TARGET_FORMAT_HLSL,

	HCC_TARGET_FORMAT_COUNT,
};

typedef uint16_t HccTargetResourceModel;
enum HccTargetResourceModel {
	HCC_TARGET_RESOURCE_MODEL_BINDING,
	HCC_TARGET_RESOURCE_MODEL_BINDING_AND_BINDLESS,
};

// ===========================================
//
//
// Compiler Options
//
//
// ===========================================

typedef struct HccOptions HccOptions;
typedef uint16_t HccOptionKey;
enum HccOptionKey {
	HCC_OPTION_KEY_TARGET_ARCH,                 // HccTargetArch
	HCC_OPTION_KEY_TARGET_OS,                   // HccTargetOS
	HCC_OPTION_KEY_TARGET_GFX_API,              // HccTargetGfxAPI
	HCC_OPTION_KEY_TARGET_FORMAT,               // HccTargetFormat
	HCC_OPTION_KEY_TARGET_RESOURCE_MODEL,       // HccTargetResourceModel
	HCC_OPTION_KEY_INT8_ENABLED,                // bool
	HCC_OPTION_KEY_INT16_ENABLED,               // bool
	HCC_OPTION_KEY_INT64_ENABLED,               // bool
	HCC_OPTION_KEY_FLOAT16_ENABLED,             // bool
	HCC_OPTION_KEY_FLOAT64_ENABLED,             // bool
	HCC_OPTION_KEY_RESOURCE_SET_SLOT_MAX,       // uint
	HCC_OPTION_KEY_RESOURCE_CONSTANTS_MAX_SIZE, // uint

	HCC_OPTION_KEY_COUNT,
};

typedef union HccOptionValue HccOptionValue;
union HccOptionValue {
	bool      bool_;
	uint32_t  uint;
	int32_t   int_;
	float     float_;
	HccString string;
};

typedef struct HccOptionsSetup HccOptionsSetup;
struct HccOptionsSetup {
	uint32_t defines_grow_count;
	uint32_t defines_reserve_cap;
};

extern HccOptionsSetup hcc_options_setup_default;
extern HccOptionValue hcc_option_key_defaults[HCC_OPTION_KEY_COUNT];

HccResult hcc_options_init(HccOptionsSetup* setup, HccOptions** o_out);
void hcc_options_deinit(HccOptions* options);
void hcc_options_reset(HccOptions* options);
HccResult hcc_options_merge(HccOptions* low_priority, HccOptions* high_priority, HccOptions** o_out);
HccResult hcc_options_clone(HccOptions* src, HccOptions** o_out);
bool hcc_options_is_set(HccOptions* options, HccOptionKey key);

HccOptionValue hcc_options_get(HccOptions* options, HccOptionKey key);
bool hcc_options_get_bool(HccOptions* options, HccOptionKey key);
uint32_t hcc_options_get_u32(HccOptions* options, HccOptionKey key);
int32_t hcc_options_get_s32(HccOptions* options, HccOptionKey key);
float hcc_options_get_float(HccOptions* options, HccOptionKey key);
HccString hcc_options_get_string(HccOptions* options, HccOptionKey key);

void hcc_options_set(HccOptions* options, HccOptionKey key, HccOptionValue value);
void hcc_options_set_bool(HccOptions* options, HccOptionKey key, bool value);
void hcc_options_set_u32(HccOptions* options, HccOptionKey key, uint32_t value);
void hcc_options_set_s32(HccOptions* options, HccOptionKey key, int32_t value);
void hcc_options_set_float(HccOptions* options, HccOptionKey key, float value);
void hcc_options_set_string(HccOptions* options, HccOptionKey key, HccString value);

HccResult hcc_options_add_define(HccOptions* options, HccString name, HccString value);

bool hcc_options_is_char_unsigned(HccOptions* o);

// ===========================================
//
//
// Compiler Task
//
//
// ===========================================

typedef uint8_t HccWorkerJobType;
enum HccWorkerJobType {
	HCC_WORKER_JOB_TYPE_ATAGEN,
	HCC_WORKER_JOB_TYPE_ASTGEN,
	HCC_WORKER_JOB_TYPE_AMLGEN,
	HCC_WORKER_JOB_TYPE_AMLOPT,
	HCC_WORKER_JOB_TYPE_BINARY,
	HCC_WORKER_JOB_TYPE_METADATA,

	HCC_WORKER_JOB_TYPE_COUNT,
};

typedef uint8_t HccStage;
enum HccStage {
	HCC_STAGE_CODE,
	HCC_STAGE_AST,
	HCC_STAGE_AML,
	HCC_STAGE_BINARY,
	HCC_STAGE_METADATA,

	HCC_STAGE_COUNT,
};
#define HCC_STAGE_INPUT_END (HCC_STAGE_AML + 1)

typedef uint8_t HccPhase;
enum HccPhase {
	HCC_PHASE_FRONTEND,     // ATA -> AST -> AML
	HCC_PHASE_OPTIMIZATION, // AML -> AML (optimized)
	HCC_PHASE_BACKEND,      // AML -> BINARY

	HCC_PHASE_COUNT,
};

typedef struct HccTaskSetup HccTaskSetup;
struct HccTaskSetup {
	HccCUSetup       cu;
	HccOptions*      options;
	HccWorkerJobType final_worker_job_type;
	uint32_t         include_paths_cap;
	uint32_t         messages_cap;
	uint32_t         message_strings_cap;
};

typedef struct HccTask HccTask;

extern HccTaskSetup hcc_task_setup_default;
extern const char* hcc_stage_strings[HCC_STAGE_COUNT];
extern const char* hcc_phase_strings[HCC_PHASE_COUNT];
extern const char* hcc_worker_job_type_strings[HCC_WORKER_JOB_TYPE_COUNT];

HccResult hcc_task_init(HccTaskSetup* setup, HccTask** t_out);
void hcc_task_deinit(HccTask* t);

HccResult hcc_task_add_include_path(HccTask* t, HccString path);
HccResult hcc_task_add_input_code_file(HccTask* t, const char* file_path, HccOptions* options);

HccResult hcc_task_add_output_ast_text(HccTask* t, HccIIO* iio);
HccResult hcc_task_add_output_ast_binary(HccTask* t, HccIIO* iio);
HccResult hcc_task_add_output_ast(HccTask* t, HccAST** ast_out);

HccResult hcc_task_add_output_aml_text(HccTask* t, HccIIO* iio);
HccResult hcc_task_add_output_aml_binary(HccTask* t, HccIIO* iio);
HccResult hcc_task_add_output_aml(HccTask* t, HccAML** aml_out);

bool hcc_task_has_started(HccTask* t);
bool hcc_task_is_complete(HccTask* t);
HccResult hcc_task_result(HccTask* t);
HccMessage* hcc_task_messages(HccTask* t, uint32_t* count_out);
HccCU* hcc_task_cu(HccTask* t);
HccResult hcc_task_wait_for_complete(HccTask* t);
HccDuration hcc_task_duration(HccTask* t); // total duration from when the task started, must be called when the task is complete
HccDuration hcc_task_phase_duration(HccTask* t, HccPhase phase); // duration spent on the task for that phase, must be called when the task is complete
HccDuration hcc_task_worker_job_type_duration(HccTask* t, HccWorkerJobType type); // duration spent on the task by the workers for this job type, must be called when the task is complete

// ===========================================
//
//
// Compiler
//
//
// ===========================================

typedef struct HccPPGenSetup HccPPGenSetup;
struct HccPPGenSetup {
	uint32_t expand_stack_grow_count;
	uint32_t expand_stack_reserve_cap;
	uint32_t stringify_buffer_grow_count;
	uint32_t stringify_buffer_reserve_cap;
	uint32_t if_stack_grow_count;
	uint32_t if_stack_reserve_cap;
	uint32_t macro_declarations_cap;
	uint32_t macro_args_stack_grow_count;
	uint32_t macro_args_stack_reserve_cap;
};

typedef struct HccATAGenSetup HccATAGenSetup;
struct HccATAGenSetup {
	HccPPGenSetup ppgen;
	uint32_t      paused_file_stack_grow_count;
	uint32_t      paused_file_stack_reserve_cap;
	uint32_t      open_bracket_stack_grow_count;
	uint32_t      open_bracket_stack_reserve_cap;
};

typedef struct HccASTGenSetup HccASTGenSetup;
struct HccASTGenSetup {
	uint32_t variable_stack_grow_count;
	uint32_t variable_stack_reserve_cap;
	uint32_t compound_fields_reserve_cap;
	uint32_t function_params_and_variables_reserve_cap;
	uint32_t enum_values_reserve_cap;
};

typedef struct HccCompilerSetup HccCompilerSetup;
struct HccCompilerSetup {
	HccATAGenSetup atagen;
	HccASTGenSetup astgen;
	uint32_t       worker_string_buffer_grow_size;
	uint32_t       worker_string_buffer_reserve_size;
	uint32_t       worker_arena_size;
	uint32_t       workers_count;
	uint32_t       worker_jobs_queue_cap;
	uint32_t       worker_call_stack_size;
};

extern HccCompilerSetup hcc_compiler_setup_default;

HccResult hcc_compiler_init(HccCompilerSetup* setup, HccCompiler** c_out);
HccResult hcc_compiler_deinit(HccCompiler* c);
HccResult hcc_compiler_dispatch_task(HccCompiler* c, HccTask* t);
HccResult hcc_compiler_wait_for_all_tasks(HccCompiler* c);
HccResult hcc_compiler_clear_mem_arenas(HccCompiler* c);
HccDuration hcc_compiler_duration(HccCompiler* c); // total duration from when the compiler started, must be called when the compiler is complete
HccDuration hcc_compiler_phase_duration(HccCompiler* c, HccPhase phase); // duration spent on the compiler for that phase, must be called when the compiler is complete
HccDuration hcc_compiler_worker_job_type_duration(HccCompiler* c, HccWorkerJobType type); // duration spent on the compiler by the workers for this job type, must be called when the compiler is complete

// ===========================================
//
//
// String Table
//
//
// ===========================================
//
// used to hold a unique set of strings so the user
// can reduce the string down to a uint32_t identifier.
// this identifier can be used to uniquely identify the string.
// so a comparision with the two identifier integers can be used to compare strings.
//

typedef struct HccStringTable HccStringTable;

#define hcc_string_table_deduplicate_lit(string_lit) hcc_string_table_deduplicate(string_lit, sizeof(string_lit) - 1)
#define hcc_string_table_deduplicate_c_string(c_string) hcc_string_table_deduplicate(c_string, strlen(c_string))
HccResult hcc_string_table_deduplicate(const char* string, uint32_t string_size, HccStringId* out);
HccString hcc_string_table_get(HccStringId id);
HccString hcc_string_table_get_or_empty(HccStringId id);

// ===========================================
//
//
// Code File
//
//
// ===========================================

typedef struct HccCodeFile HccCodeFile;

HccCodeFile* hcc_code_file_find(HccString file_path);
HccResult hcc_code_file_find_or_insert(HccString file_path, HccCodeFile** code_file_out);
HccString hcc_code_file_path_string(HccCodeFile* code_file);
HccString hcc_code_file_code(HccCodeFile* code_file);
uint32_t hcc_code_file_line_size(HccCodeFile* code_file, uint32_t line);
uint32_t hcc_code_file_lines_count(HccCodeFile* code_file);

// ===========================================
//
//
// Location
//
//
// ===========================================

typedef struct HccLocation HccLocation;
struct HccLocation {
	HccCodeFile* code_file;
	HccLocation* parent_location;
	HccPPMacro*  macro;
	uint32_t     code_start_idx;
	uint32_t     code_end_idx;
	uint32_t     line_start;
	uint32_t     line_end;
	uint32_t     column_start;
	uint32_t     column_end;

	HccString    display_path;
	uint32_t     display_line;
};

// ===========================================
//
//
// Library
//
//
// ===========================================

typedef uint32_t HccFlags;
enum HccFlags {
	HCC_FLAGS_NONE =              0x0,
	HCC_FLAGS_ENABLE_STACKTRACE = 0x1,
};

typedef uint32_t (*HccPathCanonicalizeFn)(const char* path, char* out_buf);
typedef bool (*HccFileOpenReadFn)(const char* path, HccIIO* out);

typedef struct HccSetup HccSetup;
struct HccSetup {
	HccFlags               flags;
	uint32_t               global_mem_arena_size;
	HccAllocEventFn        alloc_event_fn;
	HccPathCanonicalizeFn  path_canonicalize_fn;
	HccFileOpenReadFn      file_open_read_fn;
	void*                  alloc_event_userdata;
	uint32_t               string_table_data_grow_count;
	uint32_t               string_table_data_reserve_cap;
	uint32_t               string_table_entries_cap;
	uint32_t               code_files_cap;
	uint32_t               code_file_lines_grow_count;
	uint32_t               code_file_lines_reserve_cap;
	uint32_t               code_file_pp_if_spans_grow_count;
	uint32_t               code_file_pp_if_spans_reserve_cap;
};

extern HccSetup hcc_setup_default;

HccResult hcc_init(HccSetup* setup);
void hcc_deinit();
HccResult hcc_clear_global_mem_arena();
HccResult hcc_clear_code_files();
HccResult hcc_alloc_location(HccLocation** out);


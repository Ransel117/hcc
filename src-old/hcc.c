#include "hcc.h"

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <signal.h>
#include <unistd.h>
#include <limits.h>
#include <fcntl.h>
#include <sys/stat.h>

// ===========================================
//
//
// General
//
//
// ===========================================

static HccCompiler* _hcc_compiler_ptr;

const char* hcc_alloc_tag_strings[HCC_ALLOC_TAG_COUNT] = {
	[HCC_ALLOC_TAG_MESSAGES] = "HCC_ALLOC_TAG_MESSAGES",
	[HCC_ALLOC_TAG_MESSAGE_STRINGS] = "HCC_ALLOC_TAG_MESSAGE_STRINGS",
	[HCC_ALLOC_TAG_STRING_TABLE_DATA] = "HCC_ALLOC_TAG_STRING_TABLE_DATA",
	[HCC_ALLOC_TAG_STRING_TABLE_ENTRIES] = "HCC_ALLOC_TAG_STRING_TABLE_ENTRIES",
	[HCC_ALLOC_TAG_CONSTANT_TABLE_DATA] = "HCC_ALLOC_TAG_CONSTANT_TABLE_DATA",
	[HCC_ALLOC_TAG_CONSTANT_TABLE_ENTRIES] = "HCC_ALLOC_TAG_CONSTANT_TABLE_ENTRIES",
	[HCC_ALLOC_TAG_STRING_BUFFER] = "HCC_ALLOC_TAG_STRING_BUFFER",
	[HCC_ALLOC_TAG_INCLUDE_PATHS] = "HCC_ALLOC_TAG_INCLUDE_PATHS",
	[HCC_ALLOC_TAG_CODE_FILES] = "HCC_ALLOC_TAG_CODE_FILES",
	[HCC_ALLOC_TAG_PATH_TO_CODE_FILE_ID_MAP] = "HCC_ALLOC_TAG_PATH_TO_CODE_FILE_ID_MAP",
	[HCC_ALLOC_TAG_CODE_FILE_LINE_CODE_START_INDICES] = "HCC_ALLOC_TAG_CODE_FILE_LINE_CODE_START_INDICES",
	[HCC_ALLOC_TAG_CODE_FILE_PP_IF_SPANS] = "HCC_ALLOC_TAG_CODE_FILE_PP_IF_SPANS",
	[HCC_ALLOC_TAG_CODE] = "HCC_ALLOC_TAG_CODE",
	[HCC_ALLOC_TAG_PP_TOKENS] = "HCC_ALLOC_TAG_PP_TOKENS",
	[HCC_ALLOC_TAG_PP_TOKEN_LOCATION_INDICES] = "HCC_ALLOC_TAG_PP_TOKEN_LOCATION_INDICES",
	[HCC_ALLOC_TAG_PP_TOKEN_VALUES] = "HCC_ALLOC_TAG_PP_TOKEN_VALUES",
	[HCC_ALLOC_TAG_PP_MACROS] = "HCC_ALLOC_TAG_PP_MACROS",
	[HCC_ALLOC_TAG_PP_MACRO_PARAMS] = "HCC_ALLOC_TAG_PP_MACRO_PARAMS",
	[HCC_ALLOC_TAG_PP_MACRO_ARGS_STACK] = "HCC_ALLOC_TAG_PP_MACRO_ARGS_STACK",
	[HCC_ALLOC_TAG_PP_EXPAND_STACK] = "HCC_ALLOC_TAG_PP_EXPAND_STACK",
	[HCC_ALLOC_TAG_PP_STRINGIFY_BUFFER] = "HCC_ALLOC_TAG_PP_STRINGIFY_BUFFER",
	[HCC_ALLOC_TAG_PP_IF_SPAN_STACK] = "HCC_ALLOC_TAG_PP_IF_SPAN_STACK",
	[HCC_ALLOC_TAG_PP_MACRO_DECLARATIONS] = "HCC_ALLOC_TAG_PP_MACRO_DECLARATIONS",
	[HCC_ALLOC_TAG_TOKENGEN_TOKENS] = "HCC_ALLOC_TAG_TOKENGEN_TOKENS",
	[HCC_ALLOC_TAG_TOKENGEN_TOKEN_LOCATION_INDICES] = "HCC_ALLOC_TAG_TOKENGEN_TOKEN_LOCATION_INDICES",
	[HCC_ALLOC_TAG_TOKENGEN_TOKEN_VALUES] = "HCC_ALLOC_TAG_TOKENGEN_TOKEN_VALUES",
	[HCC_ALLOC_TAG_TOKENGEN_TOKEN_LOCATIONS] = "HCC_ALLOC_TAG_TOKENGEN_TOKEN_LOCATIONS",
	[HCC_ALLOC_TAG_TOKENGEN_PAUSED_FILE_STACK] = "HCC_ALLOC_TAG_TOKENGEN_PAUSED_FILE_STACK",
	[HCC_ALLOC_TAG_TOKENGEN_OPEN_BRACKET_STACK] = "HCC_ALLOC_TAG_TOKENGEN_OPEN_BRACKET_STACK",
	[HCC_ALLOC_TAG_ASTGEN_FUNCTION_PARAMS_AND_VARIABLES] = "HCC_ALLOC_TAG_ASTGEN_FUNCTION_PARAMS_AND_VARIABLES",
	[HCC_ALLOC_TAG_ASTGEN_FUNCTIONS] = "HCC_ALLOC_TAG_ASTGEN_FUNCTIONS",
	[HCC_ALLOC_TAG_ASTGEN_EXPRS] = "HCC_ALLOC_TAG_ASTGEN_EXPRS",
	[HCC_ALLOC_TAG_ASTGEN_EXPR_LOCATIONS] = "HCC_ALLOC_TAG_ASTGEN_EXPR_LOCATIONS",
	[HCC_ALLOC_TAG_ASTGEN_GLOBAL_VARIABLES] = "HCC_ALLOC_TAG_ASTGEN_GLOBAL_VARIABLES",
	[HCC_ALLOC_TAG_ASTGEN_FUNCTION_USED_FUNCTION_INDICES] = "HCC_ALLOC_TAG_ASTGEN_FUNCTION_USED_FUNCTION_INDICES",
	[HCC_ALLOC_TAG_ASTGEN_FUNCTION_USED_STATIC_VARIABLES] = "HCC_ALLOC_TAG_ASTGEN_FUNCTION_USED_STATIC_VARIABLES",
	[HCC_ALLOC_TAG_ASTGEN_ENTRY_POINT_FUNCTION_INDICES] = "HCC_ALLOC_TAG_ASTGEN_ENTRY_POINT_FUNCTION_INDICES",
	[HCC_ALLOC_TAG_ASTGEN_USED_FUNCTION_INDICES] = "HCC_ALLOC_TAG_ASTGEN_USED_FUNCTION_INDICES",
	[HCC_ALLOC_TAG_ASTGEN_RECURSIVE_FUNCTION_INDICES_STACK] = "HCC_ALLOC_TAG_ASTGEN_RECURSIVE_FUNCTION_INDICES_STACK",
	[HCC_ALLOC_TAG_ASTGEN_ARRAY_DATA_TYPES] = "HCC_ALLOC_TAG_ASTGEN_ARRAY_DATA_TYPES",
	[HCC_ALLOC_TAG_ASTGEN_COMPOUND_DATA_TYPES] = "HCC_ALLOC_TAG_ASTGEN_COMPOUND_DATA_TYPES",
	[HCC_ALLOC_TAG_ASTGEN_COMPOUND_FIELDS] = "HCC_ALLOC_TAG_ASTGEN_COMPOUND_FIELDS",
	[HCC_ALLOC_TAG_ASTGEN_TYPEDEFS] = "HCC_ALLOC_TAG_ASTGEN_TYPEDEFS",
	[HCC_ALLOC_TAG_ASTGEN_ENUM_DATA_TYPES] = "HCC_ALLOC_TAG_ASTGEN_ENUM_DATA_TYPES",
	[HCC_ALLOC_TAG_ASTGEN_ENUM_VALUES] = "HCC_ALLOC_TAG_ASTGEN_ENUM_VALUES",
	[HCC_ALLOC_TAG_ASTGEN_ORDERED_DATA_TYPES] = "HCC_ALLOC_TAG_ASTGEN_ORDERED_DATA_TYPES",
	[HCC_ALLOC_TAG_ASTGEN_GLOBAL_DECLARATIONS] = "HCC_ALLOC_TAG_ASTGEN_GLOBAL_DECLARATIONS",
	[HCC_ALLOC_TAG_ASTGEN_STRUCT_DECLARATIONS] = "HCC_ALLOC_TAG_ASTGEN_STRUCT_DECLARATIONS",
	[HCC_ALLOC_TAG_ASTGEN_UNION_DECLARATIONS] = "HCC_ALLOC_TAG_ASTGEN_UNION_DECLARATIONS",
	[HCC_ALLOC_TAG_ASTGEN_ENUM_DECLARATIONS] = "HCC_ALLOC_TAG_ASTGEN_ENUM_DECLARATIONS",
	[HCC_ALLOC_TAG_ASTGEN_COMPOUND_TYPE_FIND_FIELDS] = "HCC_ALLOC_TAG_ASTGEN_COMPOUND_TYPE_FIND_FIELDS",
	[HCC_ALLOC_TAG_ASTGEN_CURLY_INITIALIZER_NESTED_CURLYS] = "HCC_ALLOC_TAG_ASTGEN_CURLY_INITIALIZER_NESTED_CURLYS",
	[HCC_ALLOC_TAG_ASTGEN_CURLY_INITIALIZER_NESTED_ELMTS] = "HCC_ALLOC_TAG_ASTGEN_CURLY_INITIALIZER_NESTED_ELMTS",
	[HCC_ALLOC_TAG_ASTGEN_CURLY_INITIALIZER_DESIGNATOR_INITIALIZERS] = "HCC_ALLOC_TAG_ASTGEN_CURLY_INITIALIZER_DESIGNATOR_INITIALIZERS",
	[HCC_ALLOC_TAG_ASTGEN_CURLY_INITIALIZER_DESIGNATOR_INITIALIZER_ELMT_INDICES] = "HCC_ALLOC_TAG_ASTGEN_CURLY_INITIALIZER_DESIGNATOR_INITIALIZER_ELMT_INDICES",
	[HCC_ALLOC_TAG_ASTGEN_VARIABLE_STACK_STRINGS] = "HCC_ALLOC_TAG_ASTGEN_VARIABLE_STACK_STRINGS",
	[HCC_ALLOC_TAG_ASTGEN_VARIABLE_STACK_VAR_INDICES] = "HCC_ALLOC_TAG_ASTGEN_VARIABLE_STACK_VAR_INDICES",
	[HCC_ALLOC_TAG_ASTGEN_FIELD_NAME_TO_TOKEN_IDX] = "HCC_ALLOC_TAG_ASTGEN_FIELD_NAME_TO_TOKEN_IDX",
	[HCC_ALLOC_TAG_IRGEN_FUNCTIONS] = "HCC_ALLOC_TAG_IRGEN_FUNCTIONS",
	[HCC_ALLOC_TAG_IRGEN_BASIC_BLOCKS] = "HCC_ALLOC_TAG_IRGEN_BASIC_BLOCKS",
	[HCC_ALLOC_TAG_IRGEN_VALUES] = "HCC_ALLOC_TAG_IRGEN_VALUES",
	[HCC_ALLOC_TAG_IRGEN_WORDS] = "HCC_ALLOC_TAG_IRGEN_WORDS",
	[HCC_ALLOC_TAG_IRGEN_FUNCTION_CALL_PARAM_DATA_TYPES] = "HCC_ALLOC_TAG_IRGEN_FUNCTION_CALL_PARAM_DATA_TYPES",
	[HCC_ALLOC_TAG_SPIRVGEN_TYPE_TABLE_DATA_TYPES] = "HCC_ALLOC_TAG_SPIRVGEN_TYPE_TABLE_DATA_TYPES",
	[HCC_ALLOC_TAG_SPIRVGEN_TYPE_TABLE_ENTRIES] = "HCC_ALLOC_TAG_SPIRVGEN_TYPE_TABLE_ENTRIES",
	[HCC_ALLOC_TAG_SPIRVGEN_OUT_CAPABILITIES] = "HCC_ALLOC_TAG_SPIRVGEN_OUT_CAPABILITIES",
	[HCC_ALLOC_TAG_SPIRVGEN_OUT_ENTRY_POINTS] = "HCC_ALLOC_TAG_SPIRVGEN_OUT_ENTRY_POINTS",
	[HCC_ALLOC_TAG_SPIRVGEN_OUT_DEBUG_INFO] = "HCC_ALLOC_TAG_SPIRVGEN_OUT_DEBUG_INFO",
	[HCC_ALLOC_TAG_SPIRVGEN_OUT_ANNOTATIONS] = "HCC_ALLOC_TAG_SPIRVGEN_OUT_ANNOTATIONS",
	[HCC_ALLOC_TAG_SPIRVGEN_OUT_TYPES_VARIABLES_CONSTANTS] = "HCC_ALLOC_TAG_SPIRVGEN_OUT_TYPES_VARIABLES_CONSTANTS",
	[HCC_ALLOC_TAG_SPIRVGEN_OUT_FUNCTIONS] = "HCC_ALLOC_TAG_SPIRVGEN_OUT_FUNCTIONS",
};

//
// the padded zero bytes at the end of the file we add so we can look ahead in the tokenizer comparisions
#define _HCC_TOKENIZER_LOOK_HEAD_SIZE 4

#define HCC_DEBUG_CODE_SPAN_PUSH_POP 0
#define HCC_DEBUG_CODE_PREPROCESSOR 0
#define HCC_DEBUG_CODE_IF_SPAN 0

void _hcc_assert_failed(const char* cond, const char* file, int line, const char* message, ...) {
	fprintf(stderr, "assertion failed: %s\nmessage: ", cond);

	va_list va_args;
	va_start(va_args, message);
	vfprintf(stderr, message, va_args);
	va_end(va_args);

	fprintf(stderr, "\nfile: %s:%u\n", file, line);
	abort();
}

noreturn Uptr _hcc_abort(const char* file, int line, const char* message, ...) {
	fprintf(stderr, "abort: ");

	va_list va_args;
	va_start(va_args, message);
	vfprintf(stderr, message, va_args);
	va_end(va_args);

	fprintf(stderr, "\nfile: %s:%u\n", file, line);
	abort();
}

// ===========================================
//
//
// Platform Abstraction
//
//
// ===========================================

U32 hcc_onebitscount32(U32 bits) {
#ifdef __GNUC__
	return __builtin_popcount(bits);
#else
#error "unsupported fartcount"
#endif
}

U32 hcc_leastsetbitidx32(U32 bits) {
#ifdef __GNUC__
	return __builtin_ctz(bits);
#else
#error "unsupported fartcount"
#endif
}

void hcc_get_last_system_error_string(char* buf_out, U32 buf_out_size) {
#if _WIN32
	DWORD error = GetLastError();
	DWORD res = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, error, 0, (LPTSTR)buf_out, buf_out_size, NULL);
	if (res == 0) {
		error = GetLastError();
		HCC_ABORT("TODO handle error code: %u", error);
	}
#elif _GNU_SOURCE
	int error = errno;
	// GNU version (screw these guys for changing the way this works)
	char* buf = strerror_r(error, buf_out, buf_out_size);
	if (strcmp(buf, "Unknown error") == 0) {
		goto ERROR_1;
	}

	// if its static string then copy it to the buffer
	if (buf != buf_out) {
		strncpy(buf_out, buf, buf_out_size);

		U32 size = strsize(buf);
		if (size < buf_out_size) {
			goto ERROR_2;
		}
	}
#elif defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
	int error = errno;
	// use the XSI standard behavior.
	int res = strerror_r(error, buf_out, buf_out_size);
	if (res != 0) {
		int errnum = res;
		if (res == -1)
			errnum = errno;

		if (errnum == EINVAL) {
			goto ERROR_1;
		} else if (errnum == ERANGE) {
			goto ERROR_2;
		}
		HCC_ABORT("unexpected errno: %u", errnum);
	}
#else
#error "unimplemented for this platform"
#endif
	return;
ERROR_1:
	HCC_ABORT("invalid error %u", error);
ERROR_2:
	printf("internal warning: error buffer of size '%u' is not big enough", buf_out_size);
	HCC_ABORT("invalid error %u", error);
}

bool hcc_file_exist(char* path) {
#ifdef __linux__
	return access(path, F_OK) == 0;
#else
#error "unimplemented for this platform"
#endif
}

bool hcc_change_working_directory(char* path) {
#ifdef __linux__
	return chdir(path) == 0;
#else
#error "unimplemented for this platform"
#endif
}

char* hcc_path_canonicalize(char* path) {
#ifdef __linux__
	char* new_path = malloc(PATH_MAX);
	if (realpath(path, new_path) == NULL) {
		char error_buf[512];
		hcc_get_last_system_error_string(error_buf, sizeof(error_buf));
		HCC_ABORT("internal error: failed to locate file at '%s': %s", path, error_buf);
	}
	return new_path;
#else
#error "unimplemented for this platform"
#endif
}

bool hcc_path_is_absolute(char* path) {
#ifdef __unix__
	return path[0] == '/';
#else
#error "unimplemented for this platform"
#endif
}

char* hcc_file_read_all_the_codes(char* path, U64* size_out) {
#ifdef __linux__
	int fd_flags = O_CLOEXEC | O_RDONLY;
	int mode = 0666;
	int fd = open(path, fd_flags, mode);
	if (fd == -1) {
		return NULL;
	}

	struct stat s = {0};
	if (fstat(fd, &s) != 0) return NULL;
	*size_out = s.st_size;

	char* bytes = HCC_ALLOC(HCC_ALLOC_TAG_CODE, s.st_size + _HCC_TOKENIZER_LOOK_HEAD_SIZE, alignof(char));

	U64 remaining_read_size = s.st_size;
	U64 offset = 0;
	while (remaining_read_size) {
		ssize_t bytes_read = read(fd, bytes + offset, remaining_read_size);
		if (bytes_read == (ssize_t)-1) {
			return NULL;
		}
		offset += bytes_read;
		remaining_read_size -= bytes_read;
	}

	close(fd);

	return bytes;
#else
#error "unimplemented for this platform"
#endif
}

// ===========================================
//
//
// Stack
//
//
// ===========================================

#define HCC_DEBUG_ASSERT_STACK(header, elmt_size_) \
	HCC_DEBUG_ASSERT(header->magic_number == HCC_STACK_MAGIC_NUMBER, "address '%p' is not a stack", header + 1); \
	HCC_DEBUG_ASSERT(header->elmt_size == elmt_size_, "stack element size mismatch. expected '%zu' but got '%zu'", header->elmt_size == elmt_size_)

HccStack(void) _hcc_stack_init(Uptr cap, HccAllocTag tag, Uptr elmt_size) {
	HCC_DEBUG_ASSERT_NON_ZERO(cap);
	Uptr size = sizeof(HccStackHeader) + cap * elmt_size;
	HccStackHeader* header = HCC_ALLOC(tag, size, alignof(void*));
	if (!header) {
		hcc_compiler_bail_allocation_failure(_hcc_compiler_ptr, tag);
	}

	//
	// initialize the header and pass out the where the elements of the array start
	header->count = 0;
	header->cap = cap;
	header->tag = tag;
#if HCC_DEBUG_ASSERTIONS
	header->magic_number = HCC_STACK_MAGIC_NUMBER;
	header->elmt_size = elmt_size;
#endif

	return header + 1;
}

void _hcc_stack_deinit(HccStack(void) stack, HccAllocTag tag, Uptr elmt_size) {
	HccStackHeader* header = hcc_stack_header(stack);
	HCC_DEBUG_ASSERT_STACK(header, elmt_size);
	Uptr size = sizeof(HccStackHeader) + header->cap * elmt_size;
	HCC_DEALLOC(tag, header, size, alignof(void*));
}

Uptr _hcc_stack_resize(HccStack(void) stack, Uptr new_count, Uptr elmt_size) {
	HccStackHeader* header = hcc_stack_header(stack);
	HCC_DEBUG_ASSERT_STACK(header, elmt_size);
	Uptr count = header->count;
	HCC_DEBUG_ASSERT_ARRAY_RESIZE(count, header->cap);
	header->count = new_count;
	return count;
}

void* _hcc_stack_insert_many(HccStack(void) stack, Uptr idx, Uptr amount, Uptr elmt_size) {
	HccStackHeader* header = hcc_stack_header(stack);
	HCC_DEBUG_ASSERT_STACK(header, elmt_size);
	HCC_DEBUG_ASSERT(idx <= header->count, "insert index '%zu' must be less than or equal to count of '%zu'", idx, header->count);

	//
	// extend the count and ensure we don't exceed the capacity
	Uptr new_count = header->count + amount;
	if (new_count > header->cap) {
		hcc_compiler_bail_collection_is_full(_hcc_compiler_ptr, header->tag);
	}
	Uptr count = _hcc_stack_resize(stack, new_count, elmt_size);

	//
	// shift the elements from idx to (idx + amount), to the right to make room for the elements
	void* dst = HCC_PTR_ADD(stack, idx * elmt_size);
	memmove(HCC_PTR_ADD(dst, amount * elmt_size), dst, (count - idx) * elmt_size);

	return dst;
}

Uptr _hcc_stack_push_many(HccStack(void) stack, Uptr amount, Uptr elmt_size) {
	HccStackHeader* header = hcc_stack_header(stack);
	HCC_DEBUG_ASSERT_STACK(header, elmt_size);

	//
	// extend the count and ensure we don't exceed the capacity
	Uptr new_count = header->count + amount;
	if (new_count > header->cap) {
		hcc_compiler_bail_collection_is_full(_hcc_compiler_ptr, header->tag);
	}

	Uptr insert_idx = _hcc_stack_resize(stack, new_count, elmt_size);
	return insert_idx;
}

void _hcc_stack_pop_many(HccStack(void) stack, Uptr amount, Uptr elmt_size) {
	HccStackHeader* header = hcc_stack_header(stack);
	HCC_DEBUG_ASSERT_STACK(header, elmt_size);
	HCC_DEBUG_ASSERT(amount <= header->count, "cannot pop '%zu' many elements when the array has a count of '%zu'", amount, header->count);
	header->count -= amount;
}

void _hcc_stack_remove_swap_many(HccStack(void) stack, Uptr idx, Uptr amount, Uptr elmt_size) {
	HccStackHeader* header = hcc_stack_header(stack);
	HCC_DEBUG_ASSERT_STACK(header, elmt_size);
	HCC_DEBUG_ASSERT(idx <= header->count, "idx '%zu' must be less than or equal to count of '%zu'", idx, header->count);
	Uptr end_idx = idx + amount;
	HCC_DEBUG_ASSERT(end_idx <= header->count, "(idx + amount) '%zu' must be less than or equal to count of '%zu'", end_idx, header->count);

	//
	// get the pointer to the elements that are being removed
	void* dst = HCC_PTR_ADD(stack, idx * elmt_size);

	//
	// get the pointer to the elements at the back of the stack that will be moved
	Uptr src_idx = header->count;
	header->count -= amount;
	amount = HCC_MIN(amount, header->count);
	src_idx -= amount;

	//
	// replace the removed elements with the elements from the back of the stack
	void* src = HCC_PTR_ADD(stack, src_idx * elmt_size);
	memmove(dst, src, amount * elmt_size);
}

void _hcc_stack_remove_shift_many(HccStack(void) stack, Uptr idx, Uptr amount, Uptr elmt_size) {
	HccStackHeader* header = hcc_stack_header(stack);
	HCC_DEBUG_ASSERT(idx <= header->count, "idx '%zu' must be less than or equal to count of '%zu'", idx, header->count);
	Uptr end_idx = idx + amount;
	HCC_DEBUG_ASSERT(end_idx <= header->count, "(idx + amount) '%zu' must be less than or equal to count of '%zu'", end_idx, header->count);

	//
	// get the pointer to the elements that are being removed
	void* dst = HCC_PTR_ADD(stack, idx * elmt_size);

	//
	// now replace the elements by shifting the elements to the right over them.
	if (end_idx < header->count) {
		void* src = HCC_PTR_ADD(dst, amount * elmt_size);
		memmove(dst, src, (header->count - (idx + amount)) * elmt_size);
	}
	header->count -= amount;
}

void hcc_stack_push_char(HccStack(char) stk, char ch) {
	*hcc_stack_push(stk) = ch;
}

HccString hcc_stack_push_string(HccStack(char) stk, HccString string) {
	char* ptr = hcc_stack_push_many(stk, string.size);
	memcpy(ptr, string.data, string.size);
	return hcc_string(ptr, string.size);
}

HccString hcc_stack_push_string_fmtv(HccStack(char) stack, char* fmt, va_list args) {
	va_list args_copy;
	va_copy(args_copy, args);

	// add 1 so we have enough room for the null terminator that vsnprintf always outputs
	// vsnprintf will return -1 on an encoding error.
	Uptr size = vsnprintf(NULL, 0, fmt, args_copy) + 1;
	va_end(args_copy);
	HCC_DEBUG_ASSERT(size >= 1, "a vsnprintf encoding error has occurred");

	//
	// resize the stack to have enough room to store the pushed formatted string
	Uptr new_count = hcc_stack_count(stack) + size;
	Uptr insert_idx = hcc_stack_resize(stack, new_count);

	//
	// now call vsnprintf for real this time, with a buffer
	// to actually copy the formatted string.
	char* ptr = &stack[insert_idx];
	vsnprintf(ptr, size, fmt, args);
	return hcc_string(ptr, size);
}

HccString hcc_stack_push_string_fmt(HccStack(char) stack, char* fmt, ...) {
	va_list args;
	va_start(args, fmt);
	HccString string = hcc_stack_push_string_fmtv(stack, fmt, args);
	va_end(args);
	return string;
}

// ===========================================
//
//
// Hashing
//
//
// ===========================================

U32 hcc_fnv_hash_32(char* bytes, U32 byte_count, U32 hash) {
	char* bytes_end = bytes + byte_count;
	while (bytes < bytes_end) {
		hash = hash ^ *bytes;
		hash = hash * 0x01000193;
		bytes += 1;
	}
	return hash;
}

void hcc_generate_enum_hashes(char* array_name, char** strings, char** enum_strings, U32 enums_count) {
	U32 used_hashes[128];
	HCC_ASSERT(enums_count <= HCC_ARRAY_COUNT(used_hashes), "internal error: used_hashes needs to be atleast %u", enums_count);

	for (U32 idx = 0; idx < enums_count; idx += 1) {
		char* string = strings[idx];
		U32 string_size = strlen(string);
		U32 hash = hcc_fnv_hash_32(string, string_size, HCC_FNV_HASH_32_INITIAL);
		for (U32 used_idx = 0; used_idx < idx; used_idx += 1) {
			HCC_ASSERT(used_hashes[used_idx] != hash, "internal error: '%s' and '%s' have the same hash of '0x%x'", strings[idx], strings[used_idx]);
		}
		used_hashes[idx] = hash;
	}

	printf("U32 %s[] = {\n", array_name);
	for (U32 idx = 0; idx < enums_count; idx += 1) {
		char* enum_string = enum_strings[idx];
		U32 hash = used_hashes[idx];
		printf("\t[%s] = 0x%x,\n", enum_string, hash);
	}
	printf("};\n");
}

void hcc_generate_hashes() {
	hcc_generate_enum_hashes("hcc_pp_directive_hashes", hcc_pp_directive_strings, hcc_pp_directive_enum_strings, HCC_PP_DIRECTIVE_COUNT);
	exit(0);
}

U32 hcc_string_to_enum_hashed_find(HccString string, U32* enum_hashes, U32 enums_count) {
	U32 hash = hcc_fnv_hash_32(string.data, string.size, HCC_FNV_HASH_32_INITIAL);
	for (U32 enum_ = 0; enum_ < enums_count; enum_ += 1) {
		if (enum_hashes[enum_] == hash) {
			return enum_;
		}
	}
	return enums_count;
}


// ===========================================
//
//
// Hash Table
//
//
// ===========================================

void hcc_hash_table_init(HccHashTable* hash_table, U32 cap, HccAllocTag tag) {
	hash_table->keys = HCC_ALLOC_ARRAY(U32, tag, cap);
	if (hash_table->keys == NULL) {
		hcc_compiler_bail_allocation_failure(_hcc_compiler_ptr, tag);
	}
	HCC_ZERO_ELMT_MANY(hash_table->keys, cap);

	hash_table->values = HCC_ALLOC_ARRAY(U32, tag, cap);
	if (hash_table->values == NULL) {
		hcc_compiler_bail_allocation_failure(_hcc_compiler_ptr, tag);
	}

	hash_table->count = 0;
	hash_table->cap = cap;
}

bool hcc_hash_table_find(HccHashTable* hash_table, U32 key, U32* value_out) {
	for (uint32_t idx = 0; idx < hash_table->count; idx += 1) {
		U32 found_key = hash_table->keys[idx];
		if (found_key == key) {
			if (value_out) *value_out = hash_table->values[idx];
			return true;
		}

	}
	return false;
}

bool hcc_hash_table_find_or_insert(HccHashTable* hash_table, U32 key, U32** value_ptr_out) {
	for (uint32_t idx = 0; idx < hash_table->count; idx += 1) {
		U32 found_key = hash_table->keys[idx];
		if (found_key == key) {
			*value_ptr_out = &hash_table->values[idx];
			return true;
		}
	}

	hash_table->keys[hash_table->count] = key;
	*value_ptr_out = &hash_table->values[hash_table->count];
	HCC_ASSERT(hash_table->count < hash_table->cap, "hash table full");
	hash_table->count += 1;
	return false;
}

bool hcc_hash_table_remove(HccHashTable* hash_table, U32 key, U32* value_out) {
	for (uint32_t idx = 0; idx < hash_table->count; idx += 1) {
		U32 found_key = hash_table->keys[idx];
		if (found_key == key) {
			if (value_out) {
				*value_out = hash_table->values[idx];
			}
			if (idx + 1 < hash_table->count) {
				memmove(&hash_table->keys[idx], &hash_table->keys[idx + 1], (hash_table->cap - idx - 1) * sizeof(U32));
				memmove(&hash_table->values[idx], &hash_table->values[idx + 1], (hash_table->cap - idx - 1) * sizeof(U32));
			}
			hash_table->count -= 1;
			return true;
		}

	}
	return false;
}

void hcc_hash_table_clear(HccHashTable* hash_table) {
	hash_table->count = 0;
}

// ===========================================
//
//
// Token
//
//
// ===========================================

char* hcc_token_strings[HCC_TOKEN_COUNT] = {
	[HCC_TOKEN_EOF] = "end of file",
	[HCC_TOKEN_IDENT] = "identifier",
	[HCC_TOKEN_STRING] = "string",
	[HCC_TOKEN_INCLUDE_PATH_SYSTEM] = "<>",
	[HCC_TOKEN_BACK_SLASH] = "\\",
	[HCC_TOKEN_HASH] = "#",
	[HCC_TOKEN_DOUBLE_HASH] = "##",
	[HCC_TOKEN_MACRO_WHITESPACE] = " ",
	[HCC_TOKEN_MACRO_PARAM] = "macro param",
	[HCC_TOKEN_MACRO_STRINGIFY] = "macro stringify",
	[HCC_TOKEN_MACRO_STRINGIFY_WHITESPACE] = "macro stringify whitespace",
	[HCC_TOKEN_MACRO_CONCAT] = "##",
	[HCC_TOKEN_MACRO_CONCAT_WHITESPACE] = " ##",
	[HCC_TOKEN_CURLY_OPEN] = "{",
	[HCC_TOKEN_CURLY_CLOSE] = "}",
	[HCC_TOKEN_PARENTHESIS_OPEN] = "(",
	[HCC_TOKEN_PARENTHESIS_CLOSE] = ")",
	[HCC_TOKEN_SQUARE_OPEN] = "[",
	[HCC_TOKEN_SQUARE_CLOSE] = "]",
	[HCC_TOKEN_FULL_STOP] = ".",
	[HCC_TOKEN_COMMA] = ",",
	[HCC_TOKEN_SEMICOLON] = ";",
	[HCC_TOKEN_COLON] = ":",
	[HCC_TOKEN_PLUS] = "+",
	[HCC_TOKEN_MINUS] = "-",
	[HCC_TOKEN_FORWARD_SLASH] = "/",
	[HCC_TOKEN_ASTERISK] = "*",
	[HCC_TOKEN_PERCENT] = "%",
	[HCC_TOKEN_AMPERSAND] = "&",
	[HCC_TOKEN_PIPE] = "|",
	[HCC_TOKEN_CARET] = "^",
	[HCC_TOKEN_EXCLAMATION_MARK] = "!",
	[HCC_TOKEN_QUESTION_MARK] = "?",
	[HCC_TOKEN_TILDE] = "~",
	[HCC_TOKEN_EQUAL] = "=",
	[HCC_TOKEN_LESS_THAN] = "<",
	[HCC_TOKEN_GREATER_THAN] = ">",
	[HCC_TOKEN_LOGICAL_AND] = "&&",
	[HCC_TOKEN_LOGICAL_OR] = "||",
	[HCC_TOKEN_LOGICAL_EQUAL] = "==",
	[HCC_TOKEN_LOGICAL_NOT_EQUAL] = "!=",
	[HCC_TOKEN_LESS_THAN_OR_EQUAL] = "<=",
	[HCC_TOKEN_GREATER_THAN_OR_EQUAL] = ">=",
	[HCC_TOKEN_BIT_SHIFT_LEFT] = "<<",
	[HCC_TOKEN_BIT_SHIFT_RIGHT] = ">>",
	[HCC_TOKEN_ADD_ASSIGN] = "+=",
	[HCC_TOKEN_SUBTRACT_ASSIGN] = "-=",
	[HCC_TOKEN_MULTIPLY_ASSIGN] = "*=",
	[HCC_TOKEN_DIVIDE_ASSIGN] = "/=",
	[HCC_TOKEN_MODULO_ASSIGN] = "%=",
	[HCC_TOKEN_BIT_SHIFT_LEFT_ASSIGN] = "<<=",
	[HCC_TOKEN_BIT_SHIFT_RIGHT_ASSIGN] = ">>=",
	[HCC_TOKEN_BIT_AND_ASSIGN] = "&=",
	[HCC_TOKEN_BIT_XOR_ASSIGN] = "^=",
	[HCC_TOKEN_BIT_OR_ASSIGN] = "|=",
	[HCC_TOKEN_INCREMENT] = "++",
	[HCC_TOKEN_DECREMENT] = "--",
	[HCC_TOKEN_LIT_UINT] = "unsigned int",
	[HCC_TOKEN_LIT_ULONG] = "unsigned long",
	[HCC_TOKEN_LIT_ULONGLONG] = "unsigned long long",
	[HCC_TOKEN_LIT_SINT] = "int",
	[HCC_TOKEN_LIT_SLONG] = "long",
	[HCC_TOKEN_LIT_SLONGLONG] = "long long",
	[HCC_TOKEN_LIT_FLOAT] = "float",
	[HCC_TOKEN_LIT_DOUBLE] = "double",
	[HCC_TOKEN_KEYWORD_VOID] = "void",
	[HCC_TOKEN_KEYWORD_BOOL] = "_Bool",
	[HCC_TOKEN_KEYWORD_CHAR] = "char",
	[HCC_TOKEN_KEYWORD_SHORT] = "short",
	[HCC_TOKEN_KEYWORD_INT] = "int",
	[HCC_TOKEN_KEYWORD_LONG] = "long",
	[HCC_TOKEN_KEYWORD_FLOAT] = "float",
	[HCC_TOKEN_KEYWORD_DOUBLE] = "double",
	[HCC_TOKEN_KEYWORD_GENERIC_FLOAT] = "__hcc_generic_float",
	[HCC_TOKEN_KEYWORD_UNSIGNED] = "unsigned",
	[HCC_TOKEN_KEYWORD_SIGNED] = "signed",
	[HCC_TOKEN_KEYWORD_COMPLEX] = "_Complex",
	[HCC_TOKEN_KEYWORD_ATOMIC] = "_Atomic",
	[HCC_TOKEN_KEYWORD_RETURN] = "return",
	[HCC_TOKEN_KEYWORD_IF] = "if",
	[HCC_TOKEN_KEYWORD_ELSE] = "else",
	[HCC_TOKEN_KEYWORD_DO] = "do",
	[HCC_TOKEN_KEYWORD_WHILE] = "while",
	[HCC_TOKEN_KEYWORD_FOR] = "for",
	[HCC_TOKEN_KEYWORD_SWITCH] = "switch",
	[HCC_TOKEN_KEYWORD_CASE] = "case",
	[HCC_TOKEN_KEYWORD_DEFAULT] = "default",
	[HCC_TOKEN_KEYWORD_BREAK] = "break",
	[HCC_TOKEN_KEYWORD_CONTINUE] = "continue",
	[HCC_TOKEN_KEYWORD_TRUE] = "true",
	[HCC_TOKEN_KEYWORD_FALSE] = "false",
	[HCC_TOKEN_KEYWORD_VERTEX] = "vertex",
	[HCC_TOKEN_KEYWORD_FRAGMENT] = "fragment",
	[HCC_TOKEN_KEYWORD_GEOMETRY] = "geometry",
	[HCC_TOKEN_KEYWORD_TESSELLATION] = "tessellation",
	[HCC_TOKEN_KEYWORD_COMPUTE] = "compute",
	[HCC_TOKEN_KEYWORD_MESHTASK] = "meshtask",
	[HCC_TOKEN_KEYWORD_ENUM] = "enum",
	[HCC_TOKEN_KEYWORD_STRUCT] = "struct",
	[HCC_TOKEN_KEYWORD_UNION] = "union",
	[HCC_TOKEN_KEYWORD_TYPEDEF] = "typedef",
	[HCC_TOKEN_KEYWORD_STATIC] = "static",
	[HCC_TOKEN_KEYWORD_CONST] = "const",
	[HCC_TOKEN_KEYWORD_AUTO] = "auto",
	[HCC_TOKEN_KEYWORD_REGISTER] = "register",
	[HCC_TOKEN_KEYWORD_VOLATILE] = "volatile",
	[HCC_TOKEN_KEYWORD_EXTERN] = "extern",
	[HCC_TOKEN_KEYWORD_INLINE] = "inline",
	[HCC_TOKEN_KEYWORD_NO_RETURN] = "_Noreturn",
	[HCC_TOKEN_KEYWORD_SIZEOF] = "sizeof",
	[HCC_TOKEN_KEYWORD_ALIGNOF] = "_Alignof",
	[HCC_TOKEN_KEYWORD_ALIGNAS] = "_Alignas",
	[HCC_TOKEN_KEYWORD_STATIC_ASSERT] = "_Static_assert",
	[HCC_TOKEN_KEYWORD_RESTRICT] = "restrict",
	[HCC_TOKEN_KEYWORD_INTRINSIC] = "__hcc_intrinsic",
	[HCC_TOKEN_KEYWORD_RASTERIZER_STATE] = "__hcc_rasterizer_state",
	[HCC_TOKEN_KEYWORD_FRAGMENT_STATE] = "__hcc_fragment_state",
	[HCC_TOKEN_KEYWORD_BUFFER_ELEMENT] = "__hcc_buffer_element",
	[HCC_TOKEN_KEYWORD_RESOURCE_SET] = "__hcc_resource_set",
	[HCC_TOKEN_KEYWORD_RESOURCE_TABLE] = "__hcc_resource_table",
	[HCC_TOKEN_KEYWORD_RESOURCES] = "__hcc_resources",
	[HCC_TOKEN_KEYWORD_POSITION] = "__hcc_position",
	[HCC_TOKEN_KEYWORD_NOINTERP] = "__hcc_nointerp",
	[HCC_TOKEN_KEYWORD_RESOURCE_START + HCC_RESOURCE_TYPE_CONSTBUFFER] = "ConstBuffer",
	[HCC_TOKEN_KEYWORD_RESOURCE_START + HCC_RESOURCE_TYPE_ROELEMENTBUFFER] = "ROElementBuffer",
	[HCC_TOKEN_KEYWORD_RESOURCE_START + HCC_RESOURCE_TYPE_RWELEMENTBUFFER] = "RWElementBuffer",
	[HCC_TOKEN_KEYWORD_RESOURCE_START + HCC_RESOURCE_TYPE_ROBYTEBUFFER] = "ROByteBuffer",
	[HCC_TOKEN_KEYWORD_RESOURCE_START + HCC_RESOURCE_TYPE_RWBYTEBUFFER] = "RWByteBuffer",
	[HCC_TOKEN_KEYWORD_RESOURCE_START + HCC_RESOURCE_TYPE_ROTEXELBUFFER] = "ROTexelBuffer",
	[HCC_TOKEN_KEYWORD_RESOURCE_START + HCC_RESOURCE_TYPE_RWTEXELBUFFER] = "RWTexelBuffer",
	[HCC_TOKEN_KEYWORD_RESOURCE_START + HCC_RESOURCE_TYPE_ROTEXTURE1D] = "ROTexture1D",
	[HCC_TOKEN_KEYWORD_RESOURCE_START + HCC_RESOURCE_TYPE_RWTEXTURE1D] = "RWTexture1D",
	[HCC_TOKEN_KEYWORD_RESOURCE_START + HCC_RESOURCE_TYPE_ROTEXTURE1DARRAY] = "ROTexture1DArray",
	[HCC_TOKEN_KEYWORD_RESOURCE_START + HCC_RESOURCE_TYPE_RWTEXTURE1DARRAY] = "RWTexture1DArray",
	[HCC_TOKEN_KEYWORD_RESOURCE_START + HCC_RESOURCE_TYPE_ROTEXTURE2D] = "ROTexture2D",
	[HCC_TOKEN_KEYWORD_RESOURCE_START + HCC_RESOURCE_TYPE_RWTEXTURE2D] = "RWTexture2D",
	[HCC_TOKEN_KEYWORD_RESOURCE_START + HCC_RESOURCE_TYPE_ROTEXTURE2DARRAY] = "ROTexture2DArray",
	[HCC_TOKEN_KEYWORD_RESOURCE_START + HCC_RESOURCE_TYPE_RWTEXTURE2DARRAY] = "RWTexture2DArray",
	[HCC_TOKEN_KEYWORD_RESOURCE_START + HCC_RESOURCE_TYPE_ROTEXTURE2DMS] = "ROTexture2DMS",
	[HCC_TOKEN_KEYWORD_RESOURCE_START + HCC_RESOURCE_TYPE_RWTEXTURE2DMS] = "RWTexture2DMS",
	[HCC_TOKEN_KEYWORD_RESOURCE_START + HCC_RESOURCE_TYPE_ROTEXTURE2DMSARRAY] = "ROTexture2DMSArray",
	[HCC_TOKEN_KEYWORD_RESOURCE_START + HCC_RESOURCE_TYPE_RWTEXTURE2DMSARRAY] = "RWTexture2DMSArray",
	[HCC_TOKEN_KEYWORD_RESOURCE_START + HCC_RESOURCE_TYPE_ROTEXTURE3D] = "ROTexture3D",
	[HCC_TOKEN_KEYWORD_RESOURCE_START + HCC_RESOURCE_TYPE_RWTEXTURE3D] = "RWTexture3D",
	[HCC_TOKEN_KEYWORD_RESOURCE_START + HCC_RESOURCE_TYPE_SAMPLER_STATE] = "SamplerState",
};

U32 hcc_token_num_values(HccToken token) {
	switch (token) {
		case HCC_TOKEN_IDENT:
		case HCC_TOKEN_STRING:
		case HCC_TOKEN_INCLUDE_PATH_SYSTEM:
		case HCC_TOKEN_MACRO_PARAM:
		case HCC_TOKEN_MACRO_STRINGIFY:
		case HCC_TOKEN_MACRO_STRINGIFY_WHITESPACE:
			return 1;
		case HCC_TOKEN_LIT_UINT:
		case HCC_TOKEN_LIT_ULONG:
		case HCC_TOKEN_LIT_ULONGLONG:
		case HCC_TOKEN_LIT_SINT:
		case HCC_TOKEN_LIT_SLONG:
		case HCC_TOKEN_LIT_SLONGLONG:
		case HCC_TOKEN_LIT_FLOAT:
		case HCC_TOKEN_LIT_DOUBLE:
			return 2;
		default:
			return 0;
	}
}

bool hcc_token_concat_is_okay(HccToken before, HccToken after) {
	return (
		(HCC_TOKEN_IS_LIT_NUMBER(before) &&
			(
				HCC_TOKEN_IS_LIT_NUMBER(after) ||
				after == HCC_TOKEN_IDENT
			)
		) ||
		(before == HCC_TOKEN_IDENT &&
			(
				after == HCC_TOKEN_IDENT ||
				HCC_TOKEN_IS_LIT_NUMBER(after)
			)
		) ||
		(before == HCC_TOKEN_EQUAL && after == HCC_TOKEN_EQUAL) ||
		(before == HCC_TOKEN_EXCLAMATION_MARK && after == HCC_TOKEN_EQUAL) ||
		(before == HCC_TOKEN_PLUS &&
			(
				after == HCC_TOKEN_PLUS ||
				after == HCC_TOKEN_EQUAL
			)
		) ||
		(before == HCC_TOKEN_MINUS &&
			(
				after == HCC_TOKEN_MINUS ||
				after == HCC_TOKEN_EQUAL ||
				after == HCC_TOKEN_GREATER_THAN
			)
		) ||
		(before == HCC_TOKEN_ASTERISK && after == HCC_TOKEN_EQUAL) ||
		(before == HCC_TOKEN_FORWARD_SLASH && after == HCC_TOKEN_EQUAL) ||
		(before == HCC_TOKEN_PERCENT && after == HCC_TOKEN_EQUAL) ||
		(before == HCC_TOKEN_AMPERSAND &&
			(
				after == HCC_TOKEN_AMPERSAND ||
				after == HCC_TOKEN_EQUAL
			)
		) ||
		(before == HCC_TOKEN_PIPE &&
			(
				after == HCC_TOKEN_PIPE ||
				after == HCC_TOKEN_EQUAL
			)
		) ||
		(before == HCC_TOKEN_CARET &&
			(
				after == HCC_TOKEN_CARET ||
				after == HCC_TOKEN_EQUAL
			)
		) ||
		(before == HCC_TOKEN_LESS_THAN &&
			(
				after == HCC_TOKEN_LESS_THAN ||
				after == HCC_TOKEN_LESS_THAN_OR_EQUAL ||
				after == HCC_TOKEN_EQUAL
			)
		) ||
		(before == HCC_TOKEN_GREATER_THAN &&
			(
				after == HCC_TOKEN_GREATER_THAN ||
				after == HCC_TOKEN_GREATER_THAN_OR_EQUAL ||
				after == HCC_TOKEN_EQUAL
			)
		) ||
		(before == HCC_TOKEN_EQUAL &&
			(
				after == HCC_TOKEN_GREATER_THAN ||
				after == HCC_TOKEN_GREATER_THAN_OR_EQUAL ||
				after == HCC_TOKEN_EQUAL
			)
		) ||
		(before == HCC_TOKEN_HASH && after == HCC_TOKEN_HASH)
	);
}

U32 hcc_token_cursor_tokens_count(HccTokenCursor* cursor) {
	return cursor->tokens_end_idx - cursor->tokens_start_idx;
}

HccLocation* hcc_token_bag_location_get(HccCompiler* c, HccTokenBag* bag, U32 token_idx) {
	U32 location_idx = *hcc_stack_get(bag->token_location_indices, token_idx) & ~HCC_PP_TOKEN_IS_PREEXPANDED_MACRO_ARG_MASK;
	return hcc_stack_get(c->tokengen.token_locations, location_idx);
}

void hcc_token_bag_stringify_single(HccCompiler* c, HccTokenBag* bag, HccTokenCursor* cursor, HccPPMacro* macro) {
	HccToken token = *hcc_stack_get(bag->tokens, cursor->token_idx);
	cursor->token_idx += 1;
	switch (token) {
		case HCC_TOKEN_IDENT: {
			HccStringId string_id = hcc_stack_get(bag->token_values, cursor->token_value_idx)->string_id;
			cursor->token_value_idx += 1;
			HccString string = hcc_string_table_get(&c->string_table, string_id);
			hcc_stack_push_string(c->pp.stringify_buffer, string);
			break;
		};

		//
		// these cases are only reachable for the debug printing code in hcc_tokengen_print
		case HCC_TOKEN_MACRO_PARAM:
		case HCC_TOKEN_MACRO_STRINGIFY:
		case HCC_TOKEN_MACRO_STRINGIFY_WHITESPACE: {
			U32 param_idx = hcc_stack_get(bag->token_values, cursor->token_value_idx)->macro_param_idx;
			HccStringId string_id = *hcc_stack_get(c->pp.macro_params, macro->params_start_idx + param_idx);
			cursor->token_value_idx += 1;
			if (token == HCC_TOKEN_MACRO_STRINGIFY) {
				hcc_stack_push_char(c->pp.stringify_buffer, '#');
			} else if (token == HCC_TOKEN_MACRO_STRINGIFY_WHITESPACE) {
				hcc_stack_push_string(c->pp.stringify_buffer, hcc_string_lit("# "));
			}
			HccString string = hcc_string_table_get(&c->string_table, string_id);
			hcc_stack_push_string(c->pp.stringify_buffer, string);
			break;
		};

		case HCC_TOKEN_LIT_UINT:
		case HCC_TOKEN_LIT_ULONG:
		case HCC_TOKEN_LIT_ULONGLONG:
		case HCC_TOKEN_LIT_SINT:
		case HCC_TOKEN_LIT_SLONG:
		case HCC_TOKEN_LIT_SLONGLONG:
		case HCC_TOKEN_LIT_FLOAT:
		case HCC_TOKEN_LIT_DOUBLE: {
			cursor->token_value_idx += 1;
			HccStringId string_id = bag->token_values[cursor->token_value_idx].string_id;
			cursor->token_value_idx += 1;

			HccString string = hcc_string_table_get(&c->string_table, string_id);
			hcc_stack_push_string(c->pp.stringify_buffer, string);
			break;
		};

		case HCC_TOKEN_STRING: {
			HccStringId string_id = bag->token_values[cursor->token_value_idx].string_id;
			cursor->token_value_idx += 1;

			HccString string = hcc_string_table_get(&c->string_table, string_id);

			hcc_stack_push_char(c->pp.stringify_buffer, '"');
			for (U32 idx = 0; idx < string.size; idx += 1) {
				char ch = string.data[idx];
				switch (ch) {
					//
					// TODO complete the escape codes
					case '\\':
						hcc_stack_push_char(c->pp.stringify_buffer, '\\');
						hcc_stack_push_char(c->pp.stringify_buffer, '\\');
						break;
					case '\r':
						hcc_stack_push_char(c->pp.stringify_buffer, '\\');
						hcc_stack_push_char(c->pp.stringify_buffer, '\r');
						break;
					case '\n':
						hcc_stack_push_char(c->pp.stringify_buffer, '\\');
						hcc_stack_push_char(c->pp.stringify_buffer, '\n');
						break;
					default:
						hcc_stack_push_char(c->pp.stringify_buffer, ch);
				}
			}
			hcc_stack_push_char(c->pp.stringify_buffer, '"');

			break;
		};
		case HCC_TOKEN_MACRO_CONCAT:
		case HCC_TOKEN_MACRO_CONCAT_WHITESPACE: {
			//
			// tokengen will reorder macro concat so comes before the two operands.
			// so `ident ## ifier` becomes `## ident ifier`
			// so when stringifing, put it back in the order it was in string form.
			hcc_token_bag_stringify_single(c, bag, cursor, macro);
			hcc_stack_push_string(c->pp.stringify_buffer, hcc_string_c(hcc_token_strings[token]));
			if (*hcc_stack_get(bag->tokens, cursor->token_idx) == HCC_TOKEN_MACRO_WHITESPACE) {
				hcc_stack_push_char(c->pp.stringify_buffer, ' ');
				cursor->token_idx += 1;
			}
			hcc_token_bag_stringify_single(c, bag, cursor, macro);
			break;
		};

		default:
			hcc_stack_push_string(c->pp.stringify_buffer, hcc_string_c(hcc_token_strings[token]));
			break;
	}
}

HccToken hcc_token_bag_stringify_single_or_macro_param(HccCompiler* c, HccTokenBag* bag, HccTokenCursor* cursor, U32 args_start_idx, HccTokenBag* args_src_bag, bool false_before_true_after) {
	if (cursor->token_idx >= cursor->tokens_end_idx) {
		return HCC_TOKEN_COUNT;
	}

	HccToken token = *hcc_stack_get(bag->tokens, cursor->token_idx);
	if (token == HCC_TOKEN_MACRO_PARAM) {
		cursor->token_idx += 1;
		U32 param_idx = hcc_stack_get(bag->token_values, cursor->token_value_idx)->macro_param_idx;
		cursor->token_value_idx += 1;
		HccPPMacroArg* arg = hcc_stack_get(c->pp.macro_args_stack, args_start_idx + param_idx);
		HccTokenCursor arg_cursor = arg->cursor;
		if (arg_cursor.tokens_start_idx == arg_cursor.tokens_end_idx) {
			return HCC_TOKEN_COUNT;
		}

		HccToken return_token = *hcc_stack_get(args_src_bag->tokens, false_before_true_after ? arg_cursor.tokens_start_idx : arg_cursor.tokens_end_idx - 1);
		hcc_token_bag_stringify_range(c, args_src_bag, &arg_cursor, NULL);
		return return_token;
	}

	hcc_token_bag_stringify_single(c, bag, cursor, NULL);
	return token;
}

HccStringId hcc_token_bag_stringify_range(HccCompiler* c, HccTokenBag* bag, HccTokenCursor* cursor, HccPPMacro* macro) {
	while (cursor->token_idx < cursor->tokens_end_idx) {
		hcc_token_bag_stringify_single(c, bag, cursor, macro);
	}

	return hcc_string_table_deduplicate(&c->string_table, c->pp.stringify_buffer, hcc_stack_count(c->pp.stringify_buffer));
}

// ===========================================
//
//
// Preprocessor
//
//
// ===========================================

char* hcc_pp_predefined_macro_identifier_strings[HCC_PP_PREDEFINED_MACRO_COUNT] = {
	[HCC_PP_PREDEFINED_MACRO___FILE__] = "__FILE__",
	[HCC_PP_PREDEFINED_MACRO___LINE__] = "__LINE__",
	[HCC_PP_PREDEFINED_MACRO___COUNTER__] = "__COUNTER__",
	[HCC_PP_PREDEFINED_MACRO___HCC__] = "__HCC__",
	[HCC_PP_PREDEFINED_MACRO___HCC_GPU__] = "__HCC_GPU__",
	[HCC_PP_PREDEFINED_MACRO___HCC_X86_64__] = "__HCC_X86_64__",
	[HCC_PP_PREDEFINED_MACRO___HCC_LINUX__] = "__HCC_LINUX__",
	[HCC_PP_PREDEFINED_MACRO___HCC_WINDOWS__] = "__HCC_WINDOWS__",
};

char* hcc_pp_directive_enum_strings[HCC_PP_DIRECTIVE_COUNT] = {
	[HCC_PP_DIRECTIVE_DEFINE] = "HCC_PP_DIRECTIVE_DEFINE",
	[HCC_PP_DIRECTIVE_UNDEF] = "HCC_PP_DIRECTIVE_UNDEF",
	[HCC_PP_DIRECTIVE_INCLUDE] = "HCC_PP_DIRECTIVE_INCLUDE",
	[HCC_PP_DIRECTIVE_IF] = "HCC_PP_DIRECTIVE_IF",
	[HCC_PP_DIRECTIVE_IFDEF] = "HCC_PP_DIRECTIVE_IFDEF",
	[HCC_PP_DIRECTIVE_IFNDEF] = "HCC_PP_DIRECTIVE_IFNDEF",
	[HCC_PP_DIRECTIVE_ELSE] = "HCC_PP_DIRECTIVE_ELSE",
	[HCC_PP_DIRECTIVE_ELIF] = "HCC_PP_DIRECTIVE_ELIF",
	[HCC_PP_DIRECTIVE_ELIFDEF] = "HCC_PP_DIRECTIVE_ELIFDEF",
	[HCC_PP_DIRECTIVE_ELIFNDEF] = "HCC_PP_DIRECTIVE_ELIFNDEF",
	[HCC_PP_DIRECTIVE_ENDIF] = "HCC_PP_DIRECTIVE_ENDIF",
	[HCC_PP_DIRECTIVE_LINE] = "HCC_PP_DIRECTIVE_LINE",
	[HCC_PP_DIRECTIVE_ERROR] = "HCC_PP_DIRECTIVE_ERROR",
	[HCC_PP_DIRECTIVE_WARNING] = "HCC_PP_DIRECTIVE_WARNING",
	[HCC_PP_DIRECTIVE_PRAGMA] = "HCC_PP_DIRECTIVE_PRAGMA",
};

char* hcc_pp_directive_strings[HCC_PP_DIRECTIVE_COUNT] = {
	[HCC_PP_DIRECTIVE_DEFINE] = "define",
	[HCC_PP_DIRECTIVE_UNDEF] = "undef",
	[HCC_PP_DIRECTIVE_INCLUDE] = "include",
	[HCC_PP_DIRECTIVE_IF] = "if",
	[HCC_PP_DIRECTIVE_IFDEF] = "ifdef",
	[HCC_PP_DIRECTIVE_IFNDEF] = "ifndef",
	[HCC_PP_DIRECTIVE_ELSE] = "else",
	[HCC_PP_DIRECTIVE_ELIF] = "elif",
	[HCC_PP_DIRECTIVE_ELIFDEF] = "elifdef",
	[HCC_PP_DIRECTIVE_ELIFNDEF] = "elifndef",
	[HCC_PP_DIRECTIVE_ENDIF] = "endif",
	[HCC_PP_DIRECTIVE_LINE] = "line",
	[HCC_PP_DIRECTIVE_ERROR] = "error",
	[HCC_PP_DIRECTIVE_WARNING] = "warning",
	[HCC_PP_DIRECTIVE_PRAGMA] = "pragma",
};

U32 hcc_pp_directive_hashes[] = {
	[HCC_PP_DIRECTIVE_DEFINE] = 0x6a9f8552,
	[HCC_PP_DIRECTIVE_UNDEF] = 0x75191b51,
	[HCC_PP_DIRECTIVE_INCLUDE] = 0x75597a67,
	[HCC_PP_DIRECTIVE_IF] = 0x39386e06,
	[HCC_PP_DIRECTIVE_IFDEF] = 0x546cc0ed,
	[HCC_PP_DIRECTIVE_IFNDEF] = 0xf1e59c9f,
	[HCC_PP_DIRECTIVE_ELSE] = 0xbdbf5bf0,
	[HCC_PP_DIRECTIVE_ELIF] = 0xc0a5c8c3,
	[HCC_PP_DIRECTIVE_ELIFDEF] = 0x7aeee312,
	[HCC_PP_DIRECTIVE_ELIFNDEF] = 0xdc679c86,
	[HCC_PP_DIRECTIVE_ENDIF] = 0x1c12ad4d,
	[HCC_PP_DIRECTIVE_LINE] = 0x17db1627,
	[HCC_PP_DIRECTIVE_ERROR] = 0x21918751,
	[HCC_PP_DIRECTIVE_WARNING] = 0x792112ef,
	[HCC_PP_DIRECTIVE_PRAGMA] = 0x19fa4625,
};

void hcc_pp_init(HccCompiler* c, HccCompilerSetup* setup) {
	c->pp.macro_token_bag.tokens = hcc_stack_init(HccToken, setup->pp.macro_tokens_cap, HCC_ALLOC_TAG_PP_TOKENS);
	c->pp.macro_token_bag.token_location_indices = hcc_stack_init(U32, setup->pp.macro_tokens_cap, HCC_ALLOC_TAG_PP_TOKEN_LOCATION_INDICES);
	c->pp.macro_token_bag.token_values = hcc_stack_init(HccTokenValue, setup->pp.macro_token_values_cap, HCC_ALLOC_TAG_PP_TOKEN_VALUES);
	c->pp.macros = hcc_stack_init(HccPPMacro, setup->pp.macros_cap, HCC_ALLOC_TAG_PP_MACROS);
	c->pp.macro_params = hcc_stack_init(HccStringId, setup->pp.macro_params_cap, HCC_ALLOC_TAG_PP_MACRO_PARAMS);
	c->pp.macro_args_stack = hcc_stack_init(HccPPMacroArg, setup->pp.macro_args_stack_cap, HCC_ALLOC_TAG_PP_MACRO_ARGS_STACK);
	c->pp.expand_stack = hcc_stack_init(HccPPExpand, setup->pp.expand_stack_cap, HCC_ALLOC_TAG_PP_EXPAND_STACK);
	c->pp.expand_macro_idx_stack = hcc_stack_init(U32, setup->pp.expand_stack_cap, HCC_ALLOC_TAG_PP_EXPAND_STACK);
	c->pp.stringify_buffer = hcc_stack_init(char, setup->pp.stringify_buffer_cap, HCC_ALLOC_TAG_PP_STRINGIFY_BUFFER);
	c->pp.if_span_stack = hcc_stack_init(HccPPIfSpan*, setup->pp.if_stack_cap, HCC_ALLOC_TAG_PP_IF_SPAN_STACK);

	hcc_hash_table_init(&c->pp.macro_declarations, setup->pp.macros_cap, HCC_ALLOC_TAG_PP_MACRO_DECLARATIONS);
	for (HccPPPredefinedMacro m = 0; m < HCC_PP_PREDEFINED_MACRO_COUNT; m += 1) {
		if (m == HCC_PP_PREDEFINED_MACRO___HCC_LINUX__ && c->os != HCC_OS_LINUX) {
			continue;
		}
		if (m == HCC_PP_PREDEFINED_MACRO___HCC_WINDOWS__ && c->os != HCC_OS_WINDOWS) {
			continue;
		}
		if (m == HCC_PP_PREDEFINED_MACRO___HCC_X86_64__ && c->arch != HCC_ARCH_X86_64) {
			continue;
		}

		U32* macro_idx_ptr;
		HccStringId identifier_string_id = { HCC_STRING_ID_PREDEFINED_MACROS_START + m };
		bool found = hcc_hash_table_find_or_insert(&c->pp.macro_declarations, identifier_string_id.idx_plus_one, &macro_idx_ptr);
		HCC_DEBUG_ASSERT(!found, "internal error: predefined macro has already been initialized");
		*macro_idx_ptr = U32_MAX;
	}
}

HccPPMacro* hcc_pp_macro_get(HccCompiler* c, U32 macro_idx) {
	return hcc_stack_get(c->pp.macros, macro_idx);
}

HccPPIfSpan* hcc_pp_if_span_get(HccCompiler* c, U32 if_span_id) {
	HCC_DEBUG_ASSERT_NON_ZERO(if_span_id);
	HccCodeFile* code_file = c->tokengen.location.code_file;
	return hcc_stack_get(code_file->pp_if_spans, if_span_id - 1);
}

U32 hcc_pp_if_span_id(HccCompiler* c, HccPPIfSpan* if_span) {
	HccCodeFile* code_file = c->tokengen.location.code_file;
	HCC_DEBUG_ASSERT(code_file->pp_if_spans <= if_span && if_span <= hcc_stack_get_last(code_file->pp_if_spans), "if_span is out of the array bounds");
	U32 id = (if_span - hcc_stack_get_first(code_file->pp_if_spans)) + 1;
	return id;
}

HccPPIfSpan* hcc_pp_if_span_push(HccCompiler* c, HccPPDirective directive) {
	HccCodeFile* code_file = c->tokengen.location.code_file;
	U32 id = hcc_stack_count(code_file->pp_if_spans) + 1;

	HccPPIfSpan* pp_if_span;
	if (!(code_file->flags & HCC_CODE_FILE_FLAGS_PARSED_ONCE_OR_MORE)) {
#if HCC_DEBUG_CODE_IF_SPAN
		printf("#%s at line %u\n", hcc_pp_directive_strings[directive], c->tokengen.location.line_start);
#endif // HCC_DEBUG_CODE_IF_SPAN
		pp_if_span = hcc_stack_push(code_file->pp_if_spans);
		pp_if_span->directive = directive;
		pp_if_span->location = c->tokengen.location;
		pp_if_span->location.display_line = hcc_tokengen_display_line(c);
		pp_if_span->first_id = hcc_pp_if_span_id(c, pp_if_span);
		pp_if_span->has_else = false;
		pp_if_span->prev_id = 0;
		pp_if_span->next_id = 0;
		pp_if_span->last_id = 0;
	} else {
#if HCC_DEBUG_CODE_IF_SPAN
		printf("refound #%s at line %u\n", hcc_pp_directive_strings[directive], c->tokengen.location.line_start);
#endif // HCC_DEBUG_CODE_IF_SPAN
		code_file->pp_if_span_id += 1;
		pp_if_span = hcc_pp_if_span_get(c, code_file->pp_if_span_id);

		HccLocation location = c->tokengen.location;
		location.display_line = pp_if_span->location.display_line;
		HCC_DEBUG_ASSERT(
			pp_if_span->directive == directive &&
			HCC_CMP_ELMT(&pp_if_span->location, &location),
			"internal error: preprocessor if mismatch from first time this was included"
		);
	}

	return pp_if_span;
}

void hcc_pp_if_found_if(HccCompiler* c, HccPPDirective directive) {
	HccPPIfSpan* pp_if_span = hcc_pp_if_span_push(c, directive);
	*hcc_stack_push(c->pp.if_span_stack) = pp_if_span;
}

HccPPIfSpan* hcc_pp_if_found_if_counterpart(HccCompiler* c, HccPPDirective directive) {
	HccCodeFile* code_file = c->tokengen.location.code_file;
	HccPPIfSpan* counterpart = hcc_pp_if_span_push(c, directive);
	U32 id = hcc_pp_if_span_id(c, counterpart);

	if (!(code_file->flags & HCC_CODE_FILE_FLAGS_PARSED_ONCE_OR_MORE)) {
		HccPPIfSpan* pp_if_span = *hcc_stack_get_last(c->pp.if_span_stack);
		counterpart->first_id = hcc_pp_if_span_id(c, pp_if_span);
		counterpart->prev_id = pp_if_span->last_id;
		if (counterpart->prev_id) {
			HccPPIfSpan* prev = hcc_pp_if_span_get(c, counterpart->prev_id);
			prev->next_id = id;
		} else {
			pp_if_span->next_id = id;
		}
		pp_if_span->last_id = id;
	}

	return counterpart;
}

void hcc_pp_if_found_endif(HccCompiler* c) {
	HccPPIfSpan* pp_if_span = hcc_pp_if_found_if_counterpart(c, HCC_PP_DIRECTIVE_ENDIF);
	pp_if_span->next_id = 0;
	hcc_stack_pop(c->pp.if_span_stack);
}

void hcc_pp_if_found_else(HccCompiler* c, HccPPDirective directive) {
	HccPPIfSpan* pp_if_span = *hcc_stack_get_last(c->pp.if_span_stack);
	pp_if_span->has_else = true;

	pp_if_span = hcc_pp_if_found_if_counterpart(c, directive);
}

void hcc_pp_if_ensure_first_else(HccCompiler* c, HccPPDirective directive) {
	HccPPIfSpan* pp_if_span = *hcc_stack_get_last(c->pp.if_span_stack);

	HccCodeFile* code_file = c->tokengen.location.code_file;
	if (!(code_file->flags & HCC_CODE_FILE_FLAGS_PARSED_ONCE_OR_MORE)) {
		if (pp_if_span->has_else) {
			hcc_tokengen_bail_error_2_ptr(c, HCC_ERROR_CODE_PP_ELSEIF_CANNOT_FOLLOW_ELSE, &c->tokengen.location, &pp_if_span->location, hcc_pp_directive_strings[directive]);
		}
	}
}

void hcc_pp_if_ensure_one_is_open(HccCompiler* c, HccPPDirective directive) {
	if (hcc_stack_count(c->pp.if_span_stack) == 0) {
		hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_PP_ENDIF_BEFORE_IF, hcc_pp_directive_strings[directive]);
	}
}

void hcc_pp_eval_binary_op(HccCompiler* c, U32* token_idx_mut, HccBinaryOp* binary_op_type_out, U32* precedence_out) {
	HccToken token = *hcc_stack_get(c->tokengen.token_bag.tokens, *token_idx_mut);
	switch (token) {
		case HCC_TOKEN_ASTERISK:              *binary_op_type_out = HCC_BINARY_OP_MULTIPLY;              *precedence_out = 3;  break;
		case HCC_TOKEN_FORWARD_SLASH:         *binary_op_type_out = HCC_BINARY_OP_DIVIDE;                *precedence_out = 3;  break;
		case HCC_TOKEN_PERCENT:               *binary_op_type_out = HCC_BINARY_OP_MODULO;                *precedence_out = 3;  break;
		case HCC_TOKEN_PLUS:                  *binary_op_type_out = HCC_BINARY_OP_ADD;                   *precedence_out = 4;  break;
		case HCC_TOKEN_MINUS:                 *binary_op_type_out = HCC_BINARY_OP_SUBTRACT;              *precedence_out = 4;  break;
		case HCC_TOKEN_BIT_SHIFT_LEFT:        *binary_op_type_out = HCC_BINARY_OP_BIT_SHIFT_LEFT;        *precedence_out = 5;  break;
		case HCC_TOKEN_BIT_SHIFT_RIGHT:       *binary_op_type_out = HCC_BINARY_OP_BIT_SHIFT_RIGHT;       *precedence_out = 5;  break;
		case HCC_TOKEN_LESS_THAN:             *binary_op_type_out = HCC_BINARY_OP_LESS_THAN;             *precedence_out = 6;  break;
		case HCC_TOKEN_LESS_THAN_OR_EQUAL:    *binary_op_type_out = HCC_BINARY_OP_LESS_THAN_OR_EQUAL;    *precedence_out = 6;  break;
		case HCC_TOKEN_GREATER_THAN:          *binary_op_type_out = HCC_BINARY_OP_GREATER_THAN;          *precedence_out = 6;  break;
		case HCC_TOKEN_GREATER_THAN_OR_EQUAL: *binary_op_type_out = HCC_BINARY_OP_GREATER_THAN_OR_EQUAL; *precedence_out = 6;  break;
		case HCC_TOKEN_LOGICAL_EQUAL:         *binary_op_type_out = HCC_BINARY_OP_EQUAL;                 *precedence_out = 7;  break;
		case HCC_TOKEN_LOGICAL_NOT_EQUAL:     *binary_op_type_out = HCC_BINARY_OP_NOT_EQUAL;             *precedence_out = 7;  break;
		case HCC_TOKEN_AMPERSAND:             *binary_op_type_out = HCC_BINARY_OP_BIT_AND;               *precedence_out = 8;  break;
		case HCC_TOKEN_CARET:                 *binary_op_type_out = HCC_BINARY_OP_BIT_XOR;               *precedence_out = 9;  break;
		case HCC_TOKEN_PIPE:                  *binary_op_type_out = HCC_BINARY_OP_BIT_OR;                *precedence_out = 10; break;
		case HCC_TOKEN_LOGICAL_AND:           *binary_op_type_out = HCC_BINARY_OP_LOGICAL_AND;           *precedence_out = 11; break;
		case HCC_TOKEN_LOGICAL_OR:            *binary_op_type_out = HCC_BINARY_OP_LOGICAL_OR;            *precedence_out = 12; break;
		case HCC_TOKEN_QUESTION_MARK:         *binary_op_type_out = HCC_BINARY_OP_TERNARY;               *precedence_out = 13; break;
		case HCC_TOKEN_COMMA:                 *binary_op_type_out = HCC_BINARY_OP_COMMA;                 *precedence_out = 15; break;

		case HCC_TOKEN_PARENTHESIS_CLOSE:
		case HCC_TOKEN_COLON:
			*binary_op_type_out = HCC_BINARY_OP_ASSIGN;
			*precedence_out = 0;
			break;

		default:
			hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_INVALID_PP_BINARY_OP, hcc_token_strings[token]);
			break;
	}
}

HccPPEval hcc_pp_eval_unary_expr(HccCompiler* c, U32* token_idx_mut, U32* token_value_idx_mut) {
	HccToken token = *hcc_stack_get(c->tokengen.token_bag.tokens, *token_idx_mut);
	*token_idx_mut += 1;

	HccPPEval eval;
	HccUnaryOp unary_op;
	switch (token) {
		case HCC_TOKEN_LIT_UINT:
		case HCC_TOKEN_LIT_ULONG:
		case HCC_TOKEN_LIT_ULONGLONG: {
			HccConstantId constant_id = hcc_stack_get(c->tokengen.token_bag.token_values, *token_value_idx_mut)->constant_id;
			*token_value_idx_mut += 1;

			HccConstant constant = hcc_constant_table_get(c, constant_id);
			U64 u64;
			HCC_DEBUG_ASSERT(hcc_constant_as_uint(c, constant, &u64), "internal error: expected to be a unsigned int");

			eval.is_signed = false;
			eval.u64 = u64;
			break;
		};

		case HCC_TOKEN_LIT_SINT:
		case HCC_TOKEN_LIT_SLONG:
		case HCC_TOKEN_LIT_SLONGLONG: {
			HccConstantId constant_id = hcc_stack_get(c->tokengen.token_bag.token_values, *token_value_idx_mut)->constant_id;
			*token_value_idx_mut += 1;

			HccConstant constant = hcc_constant_table_get(c, constant_id);
			S64 s64;
			HCC_DEBUG_ASSERT(hcc_constant_as_sint(c, constant, &s64), "internal error: expected to be a signed int");

			eval.is_signed = true;
			eval.s64 = s64;
			break;
		};

		case HCC_TOKEN_PARENTHESIS_OPEN:
			eval = hcc_pp_eval_expr(c, 0, token_idx_mut, token_value_idx_mut);
			token = *hcc_stack_get(c->tokengen.token_bag.tokens, *token_idx_mut);
			if (token != HCC_TOKEN_PARENTHESIS_CLOSE) {
				hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_PARENTHESIS_CLOSE);
			}
			*token_idx_mut += 1;
			break;

		case HCC_TOKEN_TILDE: unary_op = HCC_UNARY_OP_BIT_NOT; goto UNARY;
		case HCC_TOKEN_EXCLAMATION_MARK: unary_op = HCC_UNARY_OP_LOGICAL_NOT; goto UNARY;
		case HCC_TOKEN_PLUS: unary_op = HCC_UNARY_OP_PLUS; goto UNARY;
		case HCC_TOKEN_MINUS: unary_op = HCC_UNARY_OP_NEGATE; goto UNARY;
UNARY:
		{
			eval = hcc_pp_eval_expr(c, 0, token_idx_mut, token_value_idx_mut);
			switch (unary_op) {
				case HCC_TOKEN_TILDE:            eval.u64 = ~eval.u64; break;
				case HCC_TOKEN_EXCLAMATION_MARK: eval.u64 = !eval.u64; break;
				case HCC_TOKEN_PLUS:                                   break;
				case HCC_TOKEN_MINUS:            eval.u64 = -eval.u64; break;
				default: HCC_UNREACHABLE();
			}
			break;
		};

		default:
			if (HCC_TOKEN_IS_KEYWORD(token) || token == HCC_TOKEN_IDENT) {
				//
				// the spec states that any identifier that is not evaluated during macro expansion
				// gets substituded for a 0.
				//
				eval.is_signed = true;
				eval.s64 = 0;

				if (hcc_options_is_enabled(c, HCC_OPTION_PP_UNDEF_EVAL)) {
					hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_UNDEFINED_IDENTIFIER_IN_PP_EXPR);
				}
			} else {
				*token_idx_mut -= 1;
				hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_INVALID_PP_UNARY_EXPR, hcc_token_strings[token]);
			}
			break;
	}

	return eval;
}

HccPPEval hcc_pp_eval_expr(HccCompiler* c, U32 min_precedence, U32* token_idx_mut, U32* token_value_idx_mut) {
	HccPPEval left_eval = hcc_pp_eval_unary_expr(c, token_idx_mut, token_value_idx_mut);

	while (*token_idx_mut < hcc_stack_count(c->tokengen.token_bag.tokens)) {
		HccBinaryOp binary_op_type;
		U32 precedence;
		hcc_pp_eval_binary_op(c, token_idx_mut, &binary_op_type, &precedence);
		if (binary_op_type == HCC_BINARY_OP_ASSIGN || (min_precedence && min_precedence <= precedence)) {
			return left_eval;
		}
		*token_idx_mut += 1;

		HccPPEval eval;
		if (binary_op_type == HCC_BINARY_OP_TERNARY) {
			HccPPEval true_eval = hcc_pp_eval_expr(c, 0, token_idx_mut, token_value_idx_mut);
			HccToken token = *hcc_stack_get(c->tokengen.token_bag.tokens, *token_idx_mut);
			if (token != HCC_TOKEN_COLON) {
				hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_COLON_FOR_TERNARY_OP);
			}
			*token_idx_mut += 1;
			HccPPEval false_eval = hcc_pp_eval_expr(c, 0, token_idx_mut, token_value_idx_mut);
			eval = left_eval.u64 ? true_eval : false_eval;
		} else {
			HccPPEval right_eval = hcc_pp_eval_expr(c, precedence, token_idx_mut, token_value_idx_mut);
			eval.is_signed = left_eval.is_signed == right_eval.is_signed;
			switch (binary_op_type) {
				case HCC_BINARY_OP_ADD: eval.u64 = left_eval.u64 + right_eval.u64; break;
				case HCC_BINARY_OP_SUBTRACT: eval.u64 = left_eval.u64 - right_eval.u64; break;
				case HCC_BINARY_OP_MULTIPLY: eval.u64 = left_eval.u64 * right_eval.u64; break;
				case HCC_BINARY_OP_DIVIDE:
					if (eval.is_signed) { eval.s64 = left_eval.s64 / right_eval.s64; }
					else {                eval.u64 = left_eval.u64 / right_eval.u64; }
					break;
				case HCC_BINARY_OP_MODULO:
					if (eval.is_signed) { eval.s64 = left_eval.s64 % right_eval.s64; }
					else {                eval.u64 = left_eval.u64 % right_eval.u64; }
					break;
				case HCC_BINARY_OP_BIT_AND:
					if (eval.is_signed) { eval.s64 = left_eval.s64 & right_eval.s64; }
					else {                eval.u64 = left_eval.u64 & right_eval.u64; }
					break;
				case HCC_BINARY_OP_BIT_OR:
					if (eval.is_signed) { eval.s64 = left_eval.s64 | right_eval.s64; }
					else {                eval.u64 = left_eval.u64 | right_eval.u64; }
					break;
				case HCC_BINARY_OP_BIT_XOR:
					if (eval.is_signed) { eval.s64 = left_eval.s64 ^ right_eval.s64; }
					else {                eval.u64 = left_eval.u64 ^ right_eval.u64; }
					break;
				case HCC_BINARY_OP_BIT_SHIFT_LEFT:
					if (eval.is_signed) { eval.s64 = left_eval.s64 << right_eval.s64; }
					else {                eval.u64 = left_eval.u64 << right_eval.u64; }
					break;
				case HCC_BINARY_OP_BIT_SHIFT_RIGHT:
					if (eval.is_signed) { eval.s64 = left_eval.s64 >> right_eval.s64; }
					else {                eval.u64 = left_eval.u64 >> right_eval.u64; }
					break;
				case HCC_BINARY_OP_EQUAL:     eval.u64 = left_eval.u64 == right_eval.u64; break;
				case HCC_BINARY_OP_NOT_EQUAL: eval.u64 = left_eval.u64 != right_eval.u64; break;
				case HCC_BINARY_OP_LESS_THAN:
					if (eval.is_signed) { eval.s64 = left_eval.s64 < right_eval.s64; }
					else {                eval.u64 = left_eval.u64 < right_eval.u64; }
					break;
				case HCC_BINARY_OP_LESS_THAN_OR_EQUAL:
					if (eval.is_signed) { eval.s64 = left_eval.s64 <= right_eval.s64; }
					else {                eval.u64 = left_eval.u64 <= right_eval.u64; }
					break;
				case HCC_BINARY_OP_GREATER_THAN:
					if (eval.is_signed) { eval.s64 = left_eval.s64 > right_eval.s64; }
					else {                eval.u64 = left_eval.u64 > right_eval.u64; }
					break;
				case HCC_BINARY_OP_GREATER_THAN_OR_EQUAL:
					if (eval.is_signed) { eval.s64 = left_eval.s64 >= right_eval.s64; }
					else {                eval.u64 = left_eval.u64 >= right_eval.u64; }
					break;
				case HCC_BINARY_OP_LOGICAL_AND:
					eval.u64 = left_eval.u64 && right_eval.u64;
					break;
				case HCC_BINARY_OP_LOGICAL_OR:
					eval.u64 = left_eval.u64 || right_eval.u64;
					break;
				default:
					HCC_UNREACHABLE();
			}
		}

		left_eval = eval;
	}

	return left_eval;
}

void hcc_pp_ensure_end_of_directive(HccCompiler* c, HccErrorCode error_code, HccPPDirective directive) {
	char byte = c->tokengen.code[c->tokengen.location.code_end_idx];
	char next_byte = c->tokengen.code[c->tokengen.location.code_end_idx + 1];
	if (
		byte != '\r' &&
		byte != '\n' &&
		!(byte == '/' && next_byte == '/') &&
		!(byte == '/' && next_byte == '*')
	) {
		if (c->tokengen.location.code_end_idx < c->tokengen.code_size) {
			hcc_tokengen_bail_error_1(c, error_code, hcc_pp_directive_strings[directive]);
		}
	}
}

void hcc_pp_parse_define(HccCompiler* c) {
	//
	// skip the whitespace after the #define
	hcc_tokengen_consume_whitespace(c);
	c->tokengen.location.code_start_idx = c->tokengen.location.code_end_idx;
	c->tokengen.location.column_start = c->tokengen.location.column_end;

	//
	// parse the identifier for the macro
	HccString ident_string = hcc_tokengen_parse_ident(c, HCC_ERROR_CODE_INVALID_TOKEN_MACRO_IDENTIFIER);
	HccStringId identifier_string_id = hcc_string_table_deduplicate(&c->string_table, (char*)ident_string.data, ident_string.size);
	hcc_tokengen_advance_column(c, ident_string.size);
	HccLocation ident_location = c->tokengen.location;

	U32 params_start_idx = hcc_stack_count(c->pp.macro_params);
	U32 params_count = 0;
	bool is_function = false;
	bool has_va_args = false;
	if (c->tokengen.code[c->tokengen.location.code_end_idx] == '(') {
		//
		// we found a open parenthesis right after the identifier
		// so this is a function-like macro.
		// let's collect the parameter names inside of the pair of parenthesis.
		//
		is_function = true;
		hcc_tokengen_advance_column(c, 1);
		hcc_tokengen_consume_whitespace(c);

		if (c->tokengen.code[c->tokengen.location.code_end_idx] != ')') {
			//
			// function-like has parameters
			//
			while (1) { // for each parameter
				params_count += 1;
				HccStringId param_string_id;
				if (
					c->tokengen.code[c->tokengen.location.code_end_idx] == '.' &&
					c->tokengen.code[c->tokengen.location.code_end_idx + 1] == '.' &&
					c->tokengen.code[c->tokengen.location.code_end_idx + 2] == '.'
				) {
					//
					// we found a ellipse '...' aka. the va arg
					//
					hcc_tokengen_advance_column(c, 3);
					has_va_args = true;
					param_string_id.idx_plus_one = HCC_STRING_ID___VA_ARGS__;
				} else {
					//
					// parse the parameter identifier and ensure that it is unique
					//
					HccString ident_string = hcc_tokengen_parse_ident(c, HCC_ERROR_CODE_INVALID_TOKEN_MACRO_PARAM_IDENTIFIER);
					param_string_id = hcc_string_table_deduplicate(&c->string_table, (char*)ident_string.data, ident_string.size);
					hcc_tokengen_advance_column(c, ident_string.size);
					if (param_string_id.idx_plus_one == HCC_STRING_ID___VA_ARGS__) {
						hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_VA_ARGS_IN_MACRO_PARAMETER);
					}

					for (U32 idx = params_start_idx; idx < hcc_stack_count(c->pp.macro_params); idx += 1) {
						if (hcc_stack_get(c->pp.macro_params, idx)->idx_plus_one == param_string_id.idx_plus_one) {
							hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_DUPLICATE_MACRO_PARAM_IDENTIFIER, (int)ident_string.size, ident_string.data);
						}
					}
				}

				//
				// push the parameter onto the end of the array
				*hcc_stack_push(c->pp.macro_params) = param_string_id;
				hcc_tokengen_consume_whitespace(c);

				U8 byte = c->tokengen.code[c->tokengen.location.code_end_idx];
				if (byte == ')') {
					//
					// we found the closing parenthesis so we are finished here
					break;
				}

				if (byte != ',') {
					//
					// huh, we couldn't find a ')' or a ',' after the identifier
					hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_INVALID_MACRO_PARAM_DELIMITER);
				}

				if (has_va_args) {
					//
					// a ',' was found after the va arg '...'
					hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_MACRO_PARAM_VA_ARG_NOT_LAST);
				}

				hcc_tokengen_advance_column(c, 1); // skip ','
				hcc_tokengen_consume_whitespace(c);
			}
		}

		hcc_tokengen_advance_column(c, 1); // skip ')'
	}

	hcc_tokengen_consume_whitespace(c);

	U32 tokens_start_idx = hcc_stack_count(c->pp.macro_token_bag.tokens);
	U32 token_values_start_idx = hcc_stack_count(c->pp.macro_token_bag.token_values);
	c->tokengen.macro_is_function = is_function;
	c->tokengen.macro_has_va_arg = has_va_args;
	c->tokengen.macro_param_string_ids = hcc_stack_get_or_null(c->pp.macro_params, params_start_idx);
	c->tokengen.macro_params_count = params_count;
	hcc_tokengen_run(c, &c->pp.macro_token_bag, HCC_TOKENGEN_RUN_MODE_PP_DEFINE_REPLACEMENT_LIST);
	U32 tokens_end_idx = hcc_stack_count(c->pp.macro_token_bag.tokens);
	U32 token_values_end_idx = hcc_stack_count(c->pp.macro_token_bag.token_values);
	U32 tokens_count = tokens_end_idx - tokens_start_idx;
	U32 token_values_count = token_values_end_idx - token_values_start_idx;

	if (tokens_count && c->pp.macro_token_bag.tokens[tokens_end_idx - 1] == HCC_TOKEN_MACRO_WHITESPACE) {
		tokens_end_idx -= 1;
		tokens_count -= 1;
	}

	U32* macro_idx_ptr;
	if (hcc_hash_table_find_or_insert(&c->pp.macro_declarations, identifier_string_id.idx_plus_one, &macro_idx_ptr)) {
		HccPPMacro* existing_macro = hcc_pp_macro_get(c, *macro_idx_ptr);
		HccToken* macro_tokens = hcc_stack_get_or_null(c->pp.macro_token_bag.tokens, tokens_start_idx);
		HccTokenValue* macro_token_values = hcc_stack_get_or_null(c->pp.macro_token_bag.token_values, token_values_start_idx);
		HccToken* existing_macro_tokens = hcc_stack_get_or_null(c->pp.macro_token_bag.tokens, existing_macro->token_cursor.tokens_start_idx);
		HccTokenValue* existing_macro_token_values = hcc_stack_get_or_null(c->pp.macro_token_bag.token_values, existing_macro->token_cursor.token_value_idx);
		HccStringId* param_string_ids = hcc_stack_get_or_null(c->pp.macro_params, params_start_idx);
		HccStringId* existing_param_string_ids = hcc_stack_get_or_null(c->pp.macro_params, existing_macro->params_start_idx);
		if (
			is_function != existing_macro->is_function ||
			(is_function && (
				params_count != existing_macro->params_count ||
				!HCC_CMP_ELMT_MANY(param_string_ids, existing_param_string_ids, params_count)
			)) ||
			tokens_count != hcc_token_cursor_tokens_count(&existing_macro->token_cursor) ||
			!HCC_CMP_ELMT_MANY(macro_tokens, existing_macro_tokens, tokens_count) ||
			!HCC_CMP_ELMT_MANY(macro_token_values, existing_macro_token_values, token_values_count)
		) {
			HccLocation* l = hcc_stack_push(c->tokengen.token_locations);
			*l = ident_location;
			hcc_tokengen_bail_error_2_ptr(c, HCC_ERROR_CODE_MACRO_ALREADY_DEFINED, l, &existing_macro->location, (int)ident_string.size, ident_string.data);
		}

		//
		// we have found an identical redefinition of a macro,
		// so just removed the parameters and tokens that where parsed and return.
		hcc_stack_resize(c->pp.macro_params, params_start_idx);
		hcc_stack_resize(c->pp.macro_token_bag.tokens, tokens_start_idx);
		hcc_stack_resize(c->pp.macro_token_bag.token_location_indices, tokens_start_idx);
		hcc_stack_resize(c->pp.macro_token_bag.token_values, token_values_start_idx);
		return;
	}
	*macro_idx_ptr = hcc_stack_count(c->pp.macros);

	HccPPMacro* macro = hcc_stack_push(c->pp.macros);
	macro->identifier_string_id = identifier_string_id;
	macro->location = ident_location;
	macro->token_cursor.tokens_start_idx = tokens_start_idx;
	macro->token_cursor.tokens_end_idx = tokens_end_idx;
	macro->token_cursor.token_value_idx = token_values_start_idx;
	macro->token_cursor.token_idx = tokens_start_idx;
	macro->params_start_idx = params_start_idx;
	macro->params_count = params_count;
	macro->is_function = is_function;
	macro->has_va_args = has_va_args;
}

void hcc_pp_parse_undef(HccCompiler* c) {
	hcc_tokengen_consume_whitespace(c);
	c->tokengen.location.code_start_idx = c->tokengen.location.code_end_idx;
	c->tokengen.location.column_start = c->tokengen.location.column_end;

	//
	// parse the identifier for the macro
	HccString ident_string = hcc_tokengen_parse_ident(c, HCC_ERROR_CODE_INVALID_TOKEN_MACRO_IDENTIFIER);
	HccStringId identifier_string_id = hcc_string_table_deduplicate(&c->string_table, (char*)ident_string.data, ident_string.size);
	hcc_tokengen_advance_column(c, ident_string.size);
	hcc_tokengen_consume_whitespace(c);

	//
	// remove the macro from the hash table. we do not need to error if the macro is not defined.
	U32 macro_idx;
	hcc_hash_table_remove(&c->pp.macro_declarations, identifier_string_id.idx_plus_one, &macro_idx);

	hcc_pp_ensure_end_of_directive(c, HCC_ERROR_CODE_TOO_MANY_UNDEF_OPERANDS, HCC_PP_DIRECTIVE_UNDEF);
}

void hcc_pp_parse_include(HccCompiler* c) {
	hcc_tokengen_consume_whitespace(c);
	c->tokengen.location.code_start_idx = c->tokengen.location.code_end_idx;
	c->tokengen.location.column_start = c->tokengen.location.column_end;

	//
	// run the tokenizer to get the single operand and expand any macros
	HccTokenBag* token_bag = &c->tokengen.token_bag;
	U32 tokens_start_idx = hcc_stack_count(token_bag->tokens);
	U32 token_values_start_idx = hcc_stack_count(token_bag->token_values);
	U32 token_location_indices_start_idx = hcc_stack_count(token_bag->token_location_indices);
	U32 token_location_start_idx = hcc_stack_count(c->tokengen.token_locations);
	hcc_tokengen_run(c, token_bag, HCC_TOKENGEN_RUN_MODE_PP_INCLUDE_OPERAND);

	//
	// error if no operands found
	if (tokens_start_idx == hcc_stack_count(token_bag->tokens)) {
		hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_INVALID_INCLUDE_OPERAND);
	}

	//
	// error if more that 1 operands found
	if (tokens_start_idx + 1 != hcc_stack_count(token_bag->tokens)) {
		hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_TOO_MANY_INCLUDE_OPERANDS);
	}

	HccToken token = *hcc_stack_get(token_bag->tokens, tokens_start_idx);
	if (token != HCC_TOKEN_STRING && token != HCC_TOKEN_INCLUDE_PATH_SYSTEM) {
		hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_INVALID_INCLUDE_OPERAND);
	}

	HccStringId path_string_id = hcc_stack_get(token_bag->token_values, token_values_start_idx)->string_id;
	HccString path_string = hcc_string_table_get(&c->string_table, path_string_id);
	if (path_string.size <= 1) { // <= as it has a null terminator
		hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_INCLUDE_PATH_IS_EMPTY);
	}

	bool search_the_include_paths = false;
	switch (token) {
		case HCC_TOKEN_STRING:
			if (hcc_file_exist(path_string.data)) {
				break;
			}

			//
			// the spec states the #include "" get 'upgraded' to a #include <>
			// if the file does not exist.
			//
			// fallthrough
		case HCC_TOKEN_INCLUDE_PATH_SYSTEM:
			search_the_include_paths = !hcc_path_is_absolute(path_string.data);
			break;
		default:
			HCC_UNREACHABLE("internal error: the token should have been checked above to ensure we never reach here");
	}

	if (search_the_include_paths) {
		//
		// we have a #include <> so search through all of the system library directories
		// and the user defined ones using the -I argument.
		//
		U32 idx;
		U32 count = hcc_stack_count(c->include_paths);
		for (idx = 0; idx < count; idx += 1) {
			//
			// build {include_path}/{path} in the string buffer
			//
			hcc_stack_clear(c->string_buffer);

			HccString include_dir_path = *hcc_stack_get(c->include_paths, idx);
			HCC_DEBUG_ASSERT(include_dir_path.size, "internal error: include directory path cannot be zero sized");

			hcc_stack_push_string(c->string_buffer, include_dir_path);
			if (include_dir_path.data[include_dir_path.size - 1] != '/') {
				*hcc_stack_push(c->string_buffer) = '/';
			}
			hcc_stack_push_string(c->string_buffer, path_string);
			*hcc_stack_push(c->string_buffer) = '\0';

			if (hcc_file_exist(c->string_buffer)) {
				path_string = hcc_string(c->string_buffer, hcc_stack_count(c->string_buffer));
				break;
			}
		}

		if (idx == count) {
			c->tokengen.location = *hcc_token_bag_location_get(c, token_bag, tokens_start_idx);
			hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_INCLUDE_PATH_DOES_NOT_EXIST);
		}
	}

	HccCodeFileId code_file_id;
	HccCodeFile* code_file;
	bool found_file = hcc_code_file_find_or_insert(c, path_string, &code_file_id, &code_file);
	if (!found_file) {
		//
		// file does not exist so read the file into memory
		//
		U64 code_size;
		char* code = hcc_file_read_all_the_codes(path_string.data, &code_size);
		if (code == NULL) {
			char os_error[512];
			hcc_get_last_system_error_string(os_error, sizeof(os_error));
			hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_FAILED_TO_OPEN_FILE_FOR_READ, path_string.data, os_error);
		}

		code_file->code = hcc_string(code, code_size);
	}

	if (!(code_file->flags & HCC_CODE_FILE_FLAGS_PRAGMA_ONCE)) {
		hcc_tokengen_location_push(c);
		hcc_tokengen_location_setup_new_file(c, code_file, true);
	}


	//
	// remove the added token for when we evaluated the include operand
	// using the call to hcc_tokengen_run.
	hcc_stack_resize(token_bag->tokens, tokens_start_idx);
	hcc_stack_resize(token_bag->token_values, token_values_start_idx);
	hcc_stack_resize(token_bag->token_location_indices, token_location_indices_start_idx);
	hcc_stack_resize(c->tokengen.token_locations, token_location_start_idx);
}

bool hcc_pp_parse_if(HccCompiler* c) {
	hcc_tokengen_consume_whitespace(c);
	c->tokengen.location.code_start_idx = c->tokengen.location.code_end_idx;
	c->tokengen.location.column_start = c->tokengen.location.column_end;

	//
	// run the tokenizer to get the #if condition as a list of tokens
	HccTokenBag* token_bag = &c->tokengen.token_bag;
	U32 tokens_start_idx = hcc_stack_count(token_bag->tokens);
	U32 token_values_start_idx = hcc_stack_count(token_bag->token_values);
	U32 token_location_indices_start_idx = hcc_stack_count(token_bag->token_location_indices);
	U32 token_location_start_idx = hcc_stack_count(c->tokengen.token_locations);
	hcc_tokengen_run(c, token_bag, HCC_TOKENGEN_RUN_MODE_PP_IF_OPERAND);

	//
	// error if no tokens found
	if (tokens_start_idx == hcc_stack_count(token_bag->tokens)) {
		hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_CONDITION_HAS_NO_PP_TOKENS);
	}

	//
	// evaluate the tokens and compute a boolean value
	U32 token_idx = tokens_start_idx;
	U32 token_value_idx = token_values_start_idx;
	bool is_true = !!hcc_pp_eval_expr(c, 0, &token_idx, &token_value_idx).u64;

	HCC_DEBUG_ASSERT(token_idx == hcc_stack_count(token_bag->tokens), "internal error: preprocessor expression has not been fully evaluated");

	//
	// remove the added expression tokens for the #if operand that were
	// generated by the call to hcc_tokengen_run.
	hcc_stack_resize(token_bag->tokens, tokens_start_idx);
	hcc_stack_resize(token_bag->token_values, token_values_start_idx);
	hcc_stack_resize(token_bag->token_location_indices, token_location_indices_start_idx);
	hcc_stack_resize(c->tokengen.token_locations, token_location_start_idx);

	return is_true;
}

void hcc_pp_parse_defined(HccCompiler* c) {
	hcc_tokengen_advance_column(c, sizeof("defined") - 1);
	hcc_tokengen_consume_whitespace(c);

	bool has_parenthesis = c->tokengen.code[c->tokengen.location.code_end_idx] == '(';
	if (has_parenthesis) {
		hcc_tokengen_advance_column(c, 1); // skip '('
		hcc_tokengen_consume_whitespace(c);
	}

	HccString macro_ident_string = hcc_tokengen_parse_ident(c, HCC_ERROR_CODE_EXPECTED_IDENTIFIER_PP_IF_DEFINED);
	HccStringId macro_string_id = hcc_string_table_deduplicate(&c->string_table, (char*)macro_ident_string.data, macro_ident_string.size);

	bool does_macro_exist = hcc_hash_table_find(&c->pp.macro_declarations, macro_string_id.idx_plus_one, NULL);
	hcc_tokengen_advance_column(c, macro_ident_string.size);

	if (has_parenthesis) {
		hcc_tokengen_consume_whitespace(c);
		if (c->tokengen.code[c->tokengen.location.code_end_idx] != ')') {
			hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_PARENTHESIS_CLOSE_DEFINED);
		}
		hcc_tokengen_advance_column(c, 1); // skip ')'
	}

	HccConstantId* basic_type_constant_ids = does_macro_exist ? c->basic_type_one_constant_ids : c->basic_type_zero_constant_ids;
	HccTokenValue token_value;
	token_value.constant_id = basic_type_constant_ids[HCC_DATA_TYPE_SINT];

	hcc_tokengen_token_add(c, HCC_TOKEN_LIT_SINT);
	hcc_tokengen_token_value_add(c, token_value);
}

bool hcc_pp_parse_ifdef(HccCompiler* c, HccPPDirective directive) {
	hcc_tokengen_consume_whitespace(c);
	c->tokengen.location.code_start_idx = c->tokengen.location.code_end_idx;
	c->tokengen.location.column_start = c->tokengen.location.column_end;

	HccString ident_string = hcc_tokengen_parse_ident(c, HCC_ERROR_CODE_INVALID_TOKEN_MACRO_IDENTIFIER);
	HccStringId identifier_string_id = hcc_string_table_deduplicate(&c->string_table, (char*)ident_string.data, ident_string.size);
	hcc_tokengen_advance_column(c, ident_string.size);
	hcc_tokengen_consume_whitespace(c);

	bool is_true = hcc_hash_table_find(&c->pp.macro_declarations, identifier_string_id.idx_plus_one, NULL);
	hcc_pp_ensure_end_of_directive(c, HCC_ERROR_CODE_TOO_MANY_IFDEF_OPERANDS, directive);
	return is_true;
}

void hcc_pp_parse_line(HccCompiler* c) {
	hcc_tokengen_consume_whitespace(c);
	c->tokengen.location.code_start_idx = c->tokengen.location.code_end_idx;
	c->tokengen.location.column_start = c->tokengen.location.column_end;

	//
	// run the tokenizer to get the #line operands as a list of tokens
	HccTokenBag* token_bag = &c->tokengen.token_bag;
	U32 tokens_start_idx = hcc_stack_count(token_bag->tokens);
	U32 token_values_start_idx = hcc_stack_count(token_bag->token_values);
	U32 token_location_indices_start_idx = hcc_stack_count(token_bag->token_location_indices);
	U32 token_location_start_idx = hcc_stack_count(c->tokengen.token_locations);
	hcc_tokengen_run(c, token_bag, HCC_TOKENGEN_RUN_MODE_PP_OPERAND);

	//
	// error if no tokens found
	if (tokens_start_idx == hcc_stack_count(token_bag->tokens)) {
		hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_INVALID_PP_LINE_OPERANDS);
	}

	//
	// get the custom line number from the token
	S64 custom_line;
	{
		HccToken token = *hcc_stack_get(token_bag->tokens, tokens_start_idx);
		if (token != HCC_TOKEN_LIT_SINT) {
			hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_INVALID_PP_LINE_OPERANDS);
		}
		HccConstantId constant_id = hcc_stack_get(token_bag->token_values, token_values_start_idx)->constant_id;
		HccConstant constant = hcc_constant_table_get(c, constant_id);

		HCC_DEBUG_ASSERT(hcc_constant_as_sint(c, constant, &custom_line), "internal error: expected to be a signed int");
		if (custom_line < 0 || custom_line > S32_MAX) {
			hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_PP_LINE_MUST_BE_MORE_THAN_ZERO, S32_MAX);
		}
	}

	//
	// get the custom path from the next token if there is one
	HccString custom_path = {0};
	if (tokens_start_idx + 1 < hcc_stack_count(token_bag->tokens)) {
		HccToken token = *hcc_stack_get(token_bag->tokens, tokens_start_idx + 1);
		if (token != HCC_TOKEN_STRING) {
			hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_INVALID_PP_LINE_OPERANDS);
		}
		HccStringId string_id = hcc_stack_get(token_bag->token_values, token_values_start_idx + 2)->string_id;
		custom_path = hcc_string_table_get(&c->string_table, string_id);
	}

	//
	// error if too many operands
	if (tokens_start_idx + 2 < hcc_stack_count(token_bag->tokens)) {
		hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_TOO_MANY_PP_LINE_OPERANDS);
	}

	//
	// store the custom line and custom path in the code file we are currently parsing
	c->tokengen.custom_line_dst = custom_line;
	c->tokengen.custom_line_src = c->tokengen.location.line_start;
	if (custom_path.data) {
		c->tokengen.location.display_path = custom_path;
	}

	//
	// remove the added operand tokens that were
	// generated by the call to hcc_tokengen_run.
	hcc_stack_resize(token_bag->tokens, tokens_start_idx);
	hcc_stack_resize(token_bag->token_values, token_values_start_idx);
	hcc_stack_resize(token_bag->token_location_indices, token_location_indices_start_idx);
	hcc_stack_resize(c->tokengen.token_locations, token_location_start_idx);
}

void hcc_pp_parse_error(HccCompiler* c) {
	hcc_tokengen_consume_whitespace(c);
	c->tokengen.location.code_start_idx = c->tokengen.location.code_end_idx;
	c->tokengen.location.column_start = c->tokengen.location.column_end;

	HccString message = hcc_string((char*)&c->tokengen.code[c->tokengen.location.code_end_idx], 0);
	hcc_tokengen_consume_until_any_byte(c, "\n");
	message.size = (char*)&c->tokengen.code[c->tokengen.location.code_end_idx] - message.data;

	hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_PP_ERROR, (int)message.size, message.data);
}

void hcc_pp_parse_warning(HccCompiler* c) {
	hcc_tokengen_consume_whitespace(c);
	c->tokengen.location.code_start_idx = c->tokengen.location.code_end_idx;
	c->tokengen.location.column_start = c->tokengen.location.column_end;

	HccString message = hcc_string((char*)&c->tokengen.code[c->tokengen.location.code_end_idx], 0);
	hcc_tokengen_consume_until_any_byte(c, "\n");
	message.size = (char*)&c->tokengen.code[c->tokengen.location.code_end_idx] - message.data;

	//
	// make a copy of the location for this warning since we overrite this when we continue tokenizing
	HccLocation* location = hcc_stack_push(c->tokengen.token_locations);
	*location = c->tokengen.location;
	location->display_line = hcc_tokengen_display_line(c);

	hcc_warn_push(c, HCC_WARN_CODE_PP_WARNING, location, NULL, (int)message.size, message.data);
}

void hcc_pp_parse_pragma(HccCompiler* c) {
	hcc_tokengen_consume_whitespace(c);
	c->tokengen.location.code_start_idx = c->tokengen.location.code_end_idx;
	c->tokengen.location.column_start = c->tokengen.location.column_end;

	//
	// check if this is STDC which is a thing that the spec states should exist
	if (
		c->tokengen.code[c->tokengen.location.code_end_idx + 0] == 'S' &&
		c->tokengen.code[c->tokengen.location.code_end_idx + 1] == 'T' &&
		c->tokengen.code[c->tokengen.location.code_end_idx + 2] == 'D' &&
		c->tokengen.code[c->tokengen.location.code_end_idx + 3] == 'C'
	) {
		HCC_ABORT("TODO: implement #pragma STDC support");
		return;
	}

	//
	// run the tokenizer to get the #pragma operands as a list of tokens
	HccTokenBag* token_bag = &c->tokengen.token_bag;
	U32 tokens_start_idx = hcc_stack_count(token_bag->tokens);
	U32 token_values_start_idx = hcc_stack_count(token_bag->token_values);
	U32 token_location_indices_start_idx = hcc_stack_count(token_bag->token_location_indices);
	U32 token_location_start_idx = hcc_stack_count(c->tokengen.token_locations);
	hcc_tokengen_run(c, token_bag, HCC_TOKENGEN_RUN_MODE_PP_OPERAND);

	//
	// if no tokens exist then we do nothing
	if (tokens_start_idx == hcc_stack_count(token_bag->tokens)) {
		return;
	}

	HccToken token = *hcc_stack_get(token_bag->tokens, tokens_start_idx);
	if (token != HCC_TOKEN_IDENT) {
		hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_INVALID_PP_PRAGMA_OPERAND);
	}

	U32 expected_tokens_count = hcc_stack_count(token_bag->tokens);
	HccStringId ident_string_id = hcc_stack_get(token_bag->token_values, token_values_start_idx)->string_id;
	switch (ident_string_id.idx_plus_one) {
		case HCC_STRING_ID_ONCE: {
			if (hcc_stack_count(c->tokengen.paused_file_stack) == 0) {
				hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_PP_PRAGMA_OPERAND_USED_IN_MAIN_FILE);
			}

			HccCodeFile* code_file = c->tokengen.location.code_file;
			code_file->flags |= HCC_CODE_FILE_FLAGS_PRAGMA_ONCE;
			expected_tokens_count = tokens_start_idx + 1;
			break;
		};
	}

	if (expected_tokens_count != hcc_stack_count(token_bag->tokens)) {
		HccString ident_string = hcc_string_table_get(&c->string_table, ident_string_id);
		hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_TOO_MANY_PP_PRAGMA_OPERANDS, (int)ident_string.size, ident_string.data);
	}

	//
	// remove the added operand tokens that were
	// generated by the call to hcc_tokengen_run.
	hcc_stack_resize(token_bag->tokens, tokens_start_idx);
	hcc_stack_resize(token_bag->token_values, token_values_start_idx);
	hcc_stack_resize(token_bag->token_location_indices, token_location_indices_start_idx);
	hcc_stack_resize(c->tokengen.token_locations, token_location_start_idx);
}

HccPPDirective hcc_pp_parse_directive_header(HccCompiler* c) {
	hcc_tokengen_advance_column(c, 1); // skip '#'
	hcc_tokengen_consume_whitespace(c);

	U8 byte = c->tokengen.code[c->tokengen.location.code_end_idx];
	switch (byte) {
		case '\r':
		case '\n':
		case '\0':
			return HCC_PP_DIRECTIVE_COUNT;
	}

	HccString ident_string = hcc_tokengen_parse_ident(c, HCC_ERROR_CODE_INVALID_TOKEN_PREPROCESSOR_DIRECTIVE);
	hcc_tokengen_advance_column(c, ident_string.size);

	HccPPDirective directive = hcc_string_to_enum_hashed_find(ident_string, hcc_pp_directive_hashes, HCC_PP_DIRECTIVE_COUNT);
	if (directive == HCC_PP_DIRECTIVE_COUNT) {
		hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_INVALID_PREPROCESSOR_DIRECTIVE, (int)ident_string.size, ident_string.data);
	}

	return directive;
}

void hcc_pp_parse_directive(HccCompiler* c) {
	HccPPDirective directive = hcc_pp_parse_directive_header(c);
	if (directive == HCC_PP_DIRECTIVE_COUNT) {
		// we only found a '#' on this line, so return
		return;
	}

#if HCC_DEBUG_CODE_PREPROCESSOR
	U32 debug_indent_level = hcc_stack_count(c->pp.if_span_stack);
	U32 debug_line = c->tokengen.location.line_end - 1;
	if (directive == HCC_PP_DIRECTIVE_ENDIF) {
		debug_indent_level -= 1;
	}
#endif

	bool is_skipping_code = false;
	bool is_skipping_until_endif = false;
	switch (directive) {
		case HCC_PP_DIRECTIVE_DEFINE:
			hcc_pp_parse_define(c);
			break;
		case HCC_PP_DIRECTIVE_UNDEF:
			hcc_pp_parse_undef(c);
			break;
		case HCC_PP_DIRECTIVE_INCLUDE:
			hcc_pp_parse_include(c);
			break;
		case HCC_PP_DIRECTIVE_LINE:
			hcc_pp_parse_line(c);
			break;
		case HCC_PP_DIRECTIVE_ERROR:
			hcc_pp_parse_error(c);
			break;
		case HCC_PP_DIRECTIVE_WARNING:
			hcc_pp_parse_warning(c);
			break;
		case HCC_PP_DIRECTIVE_PRAGMA:
			hcc_pp_parse_pragma(c);
			break;
		case HCC_PP_DIRECTIVE_IF: {
			hcc_pp_if_found_if(c, directive);
			is_skipping_code = !hcc_pp_parse_if(c);
			break;
		};
		case HCC_PP_DIRECTIVE_IFDEF:
		case HCC_PP_DIRECTIVE_IFNDEF: {
			hcc_pp_if_found_if(c, directive);
			is_skipping_code = hcc_pp_parse_ifdef(c, directive) != (directive == HCC_PP_DIRECTIVE_IFDEF);
			break;
		};
		case HCC_PP_DIRECTIVE_ENDIF:
			hcc_pp_if_ensure_one_is_open(c, directive);
			hcc_pp_if_found_endif(c);
			break;
		case HCC_PP_DIRECTIVE_ELSE:
		case HCC_PP_DIRECTIVE_ELIF:
		case HCC_PP_DIRECTIVE_ELIFDEF:
		case HCC_PP_DIRECTIVE_ELIFNDEF:
			hcc_pp_if_ensure_one_is_open(c, directive);
			hcc_pp_if_ensure_first_else(c, directive);
			if (directive == HCC_PP_DIRECTIVE_ELSE) {
				hcc_pp_if_found_else(c, directive);
			} else {
				hcc_pp_if_found_if_counterpart(c, directive);
			}

			//
			// we where just in a true block and processing the code as normal.
			// now we have come across some else directive, we just skip until the #endif.
			is_skipping_code = true;
			is_skipping_until_endif = true;
			break;
	}

#if HCC_DEBUG_CODE_PREPROCESSOR
	printf("+(%u)#%-7s at line %u\n", debug_indent_level, hcc_pp_directive_strings[directive], debug_line);
#endif

	if (is_skipping_code) {
		hcc_pp_skip_false_conditional(c, is_skipping_until_endif);
	}
}

void hcc_pp_skip_false_conditional(HccCompiler* c, bool is_skipping_until_endif) {
	bool first_non_white_space_char = false;
	U32 nested_level = hcc_stack_count(c->pp.if_span_stack);
	HccCodeFile* code_file = c->tokengen.location.code_file;
	bool is_inside_nested_comment = false;
	bool is_inside_single_line_comment = false;
	while (c->tokengen.location.code_end_idx < c->tokengen.code_size) {
		if (!(code_file->flags & HCC_CODE_FILE_FLAGS_PARSED_ONCE_OR_MORE)) {
			//
			// TODO test a SIMD optimized version of this
			//
			while (c->tokengen.location.code_end_idx < c->tokengen.code_size) {
				U8 byte = c->tokengen.code[c->tokengen.location.code_end_idx];
				if (byte == '\n') break;
				if (byte == '#') break;
				if (byte == '/' && c->tokengen.code[c->tokengen.location.code_end_idx + 1] == '/') break;
				if (byte == '/' && c->tokengen.code[c->tokengen.location.code_end_idx + 1] == '*') break;
				if (byte == '*' && c->tokengen.code[c->tokengen.location.code_end_idx + 1] == '/') break;
				first_non_white_space_char = false;
				hcc_tokengen_advance_column(c, 1);
			}
		} else {
			HccPPIfSpan* pp_if_span = hcc_pp_if_span_get(c, code_file->pp_if_span_id);
			if (is_skipping_until_endif) {
				HccPPIfSpan* first_pp_if_span = hcc_pp_if_span_get(c, pp_if_span->first_id);
				HccPPIfSpan* last_pp_if_span = hcc_pp_if_span_get(c, first_pp_if_span->last_id);
				c->tokengen.location = last_pp_if_span->location;
				code_file->pp_if_span_id = first_pp_if_span->last_id - 1;
			} else {
				HccPPIfSpan* next_pp_if_span = hcc_pp_if_span_get(c, pp_if_span->next_id);
				c->tokengen.location = next_pp_if_span->location;
				code_file->pp_if_span_id = pp_if_span->next_id - 1;
			}

			//
			// put cursor back to the start of the line
			c->tokengen.location.code_end_idx = c->tokengen.location.code_start_idx;
			c->tokengen.location.column_start = 1;
			c->tokengen.location.column_end = 1;
			first_non_white_space_char = true;
		}

		if (c->tokengen.location.code_end_idx >= c->tokengen.code_size) {
			return;
		}

		U8 byte = c->tokengen.code[c->tokengen.location.code_end_idx];
		switch (byte) {
			case '\n':
				is_inside_single_line_comment = false;
				hcc_tokengen_advance_newline(c);
				c->tokengen.location.line_start = c->tokengen.location.line_end - 1;
				c->tokengen.location.code_start_idx = c->tokengen.location.code_end_idx;
				c->tokengen.location.column_start = 1;
				first_non_white_space_char = true;
				break;
			case '#': {
				if (!first_non_white_space_char) {
					c->tokengen.location.column_end += 1;
					if (!is_inside_single_line_comment && !is_inside_nested_comment) {
						hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_PP_DIRECTIVE_NOT_FIRST_ON_LINE);
					}
					hcc_tokengen_advance_column(c, 1); // skip '#'
					break;
				}

				HccPPDirective directive = hcc_pp_parse_directive_header(c);
				if (directive == HCC_PP_DIRECTIVE_COUNT) {
					// we only found a '#' on this line, so continue;
					continue;
				}

				bool is_finished = false;
				switch (directive) {
					case HCC_PP_DIRECTIVE_DEFINE:
					case HCC_PP_DIRECTIVE_UNDEF:
					case HCC_PP_DIRECTIVE_INCLUDE:
					case HCC_PP_DIRECTIVE_LINE:
					case HCC_PP_DIRECTIVE_ERROR:
					case HCC_PP_DIRECTIVE_WARNING:
					case HCC_PP_DIRECTIVE_PRAGMA:
						//
						// consume until the new line and continue so the operands
						// of these defines do not mess with the skipping code.
						hcc_tokengen_consume_until_any_byte(c, "\n");
						break;
					case HCC_PP_DIRECTIVE_IF:
					case HCC_PP_DIRECTIVE_IFDEF:
					case HCC_PP_DIRECTIVE_IFNDEF: {
						//
						// push any if on the stack so we can keep track of when reach
						// the original if block's #endif or #else
						//
						hcc_pp_if_found_if(c, directive);
						break;
					};
					case HCC_PP_DIRECTIVE_ENDIF:
						if (hcc_stack_count(c->pp.if_span_stack) == nested_level) {
							is_finished = true;
						}
						hcc_pp_if_found_endif(c);
						break;
					case HCC_PP_DIRECTIVE_ELSE:
					case HCC_PP_DIRECTIVE_ELIF:
					case HCC_PP_DIRECTIVE_ELIFDEF:
					case HCC_PP_DIRECTIVE_ELIFNDEF:
						hcc_pp_if_ensure_first_else(c, directive);
						if (directive == HCC_PP_DIRECTIVE_ELSE) {
							hcc_pp_if_found_else(c, directive);
						} else {
							hcc_pp_if_found_if_counterpart(c, directive);
						}

						if (!is_skipping_until_endif && hcc_stack_count(c->pp.if_span_stack) == nested_level) {
							switch (directive) {
								case HCC_PP_DIRECTIVE_ELSE:
									is_finished = true;
									break;
								case HCC_PP_DIRECTIVE_ELIF:
									is_finished = hcc_pp_parse_if(c);
									break;
								case HCC_PP_DIRECTIVE_ELIFDEF:
								case HCC_PP_DIRECTIVE_ELIFNDEF:
									is_finished = hcc_pp_parse_ifdef(c, directive) == (directive == HCC_PP_DIRECTIVE_ELIFDEF);
									break;
							}
						}
						break;
				}

#if HCC_DEBUG_CODE_PREPROCESSOR
				char* plus_or_minus = is_skipping_code ? "-" : "+";
				printf("%s(%u)#%-7s at line %u\n", plus_or_minus, debug_indent_level, hcc_pp_directive_strings[directive], debug_line);
#endif

				if (is_finished) {
					return;
				}

				first_non_white_space_char = false;
				break;
			};
			case '/': {
				hcc_tokengen_advance_column(c, 1);
				char next_byte = c->tokengen.code[c->tokengen.location.code_end_idx];
				switch (next_byte) {
					case '/':
						hcc_tokengen_advance_column(c, 1);
						if (!is_inside_single_line_comment && !is_inside_nested_comment) {
							is_inside_single_line_comment = true;
						}
						break;
					case '*':
						hcc_tokengen_advance_column(c, 1);
						if (!is_inside_single_line_comment && !is_inside_nested_comment) {
							is_inside_nested_comment = true;
						}
						break;
				}
			};
			case '*': {
				hcc_tokengen_advance_column(c, 1);
				char next_byte = c->tokengen.code[c->tokengen.location.code_end_idx];
				switch (next_byte) {
					case '/':
						hcc_tokengen_advance_column(c, 1);
						is_inside_nested_comment = false;
						break;
				}
			};
		}
	}
}

void hcc_pp_copy_expand_predefined_macro(HccCompiler* c, HccPPPredefinedMacro predefined_macro) {
	switch (predefined_macro) {
		case HCC_PP_PREDEFINED_MACRO___FILE__: {
			HccTokenValue value = { .string_id = c->tokengen.location.code_file->path_string_id };
			hcc_tokengen_token_add(c, HCC_TOKEN_STRING);
			hcc_tokengen_token_value_add(c, value);
			break;
		};
		case HCC_PP_PREDEFINED_MACRO___LINE__: {
			HccBasic line_num = hcc_basic_from_sint(c, HCC_DATA_TYPE_SINT, c->tokengen.location.line_end - 1);
			HccTokenValue token_value = {
				.constant_id = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_SINT, &line_num),
			};
			hcc_tokengen_token_add(c, HCC_TOKEN_LIT_SINT);
			hcc_tokengen_token_value_add(c, token_value);
			break;
		};
		case HCC_PP_PREDEFINED_MACRO___COUNTER__: {
			HccBasic counter = hcc_basic_from_sint(c, HCC_DATA_TYPE_SINT, c->tokengen.__counter__);
			HccTokenValue token_value = {
				.constant_id = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_SINT, &counter),
			};
			hcc_tokengen_token_add(c, HCC_TOKEN_LIT_SINT);
			hcc_tokengen_token_value_add(c, token_value);
			c->tokengen.__counter__ += 1;
			break;
		};
		case HCC_PP_PREDEFINED_MACRO___HCC__:
		case HCC_PP_PREDEFINED_MACRO___HCC_GPU__:
		case HCC_PP_PREDEFINED_MACRO___HCC_X86_64__:
		case HCC_PP_PREDEFINED_MACRO___HCC_LINUX__:
		case HCC_PP_PREDEFINED_MACRO___HCC_WINDOWS__:
			return;
	}
}

void hcc_pp_copy_expand_macro_begin(HccCompiler* c, HccPPMacro* macro, HccLocation* macro_callsite_location) {
	HccPPExpand args_expand;
	HccTokenBag* args_src_bag = &c->pp.macro_token_bag;
	if (macro->is_function) {
		HCC_DEBUG_ASSERT(c->tokengen.code[c->tokengen.location.code_end_idx] == '(', "internal error: expected to be on a '(' but got '%c'", c->tokengen.code[c->tokengen.location.code_end_idx]);
		//
		// our arguments are currently in string form.
		// tokenize them before we call into the expand code.
		//
		args_expand.macro = NULL;
		args_expand.cursor.tokens_start_idx = hcc_stack_count(args_src_bag->tokens);
		args_expand.cursor.token_idx = hcc_stack_count(args_src_bag->tokens);
		args_expand.cursor.token_value_idx = hcc_stack_count(args_src_bag->token_values);

		hcc_tokengen_run(c, args_src_bag, HCC_TOKENGEN_RUN_MODE_PP_MACRO_ARGS);
		args_expand.cursor.tokens_end_idx = hcc_stack_count(args_src_bag->tokens);
	}

	//
	// make the location a stable pointer
	*hcc_stack_push(c->tokengen.token_locations) = *macro_callsite_location;
	macro_callsite_location = hcc_stack_get_last(c->tokengen.token_locations);

	HccTokenBag* dst_bag = &c->tokengen.token_bag;
	HccTokenBag* alt_dst_bag = &c->pp.macro_token_bag;
	hcc_pp_copy_expand_macro(c, macro, macro_callsite_location, macro_callsite_location, &args_expand, args_src_bag, dst_bag, alt_dst_bag, HCC_PP_EXPAND_FLAGS_DEST_IS_ORIGINAL_LOCATION);
}

bool hcc_pp_is_callable_macro(HccCompiler* c, HccStringId ident_string_id, U32* macro_idx_out) {
	U32 macro_idx;
	if (!hcc_hash_table_find(&c->pp.macro_declarations, ident_string_id.idx_plus_one, &macro_idx)) {
		return false;
	}

	for (U32 idx = 0; idx < hcc_stack_count(c->pp.expand_macro_idx_stack); idx += 1) {
		if (*hcc_stack_get(c->pp.expand_macro_idx_stack, idx) == macro_idx) {
			return false;
		}
	}

	if (macro_idx_out) {
		*macro_idx_out = macro_idx;
	}

	return true;
}

HccPPExpand* hcc_pp_expand_push_macro(HccCompiler* c, HccPPMacro* macro) {
	HccPPExpand* expand = hcc_stack_push(c->pp.expand_stack);
	*hcc_stack_push(c->pp.expand_macro_idx_stack) = macro - c->pp.macros;
	expand->cursor = macro->token_cursor;
	expand->macro = macro;
	return expand;
}

HccPPExpand* hcc_pp_expand_push_macro_arg(HccCompiler* c, U32 param_idx, U32 args_start_idx, HccLocation** callsite_location_out) {
	HccPPMacroArg* arg = hcc_stack_get(c->pp.macro_args_stack, args_start_idx + param_idx);
	if (callsite_location_out) *callsite_location_out = arg->callsite_location;

	HccPPExpand* expand = hcc_stack_push(c->pp.expand_stack);
	*hcc_stack_push(c->pp.expand_macro_idx_stack) = -1;
	expand->macro = NULL;
	expand->cursor = arg->cursor;
	return expand;
}

void hcc_pp_expand_pop(HccCompiler* c, HccPPExpand* expected_expand) {
	HccPPExpand* popped_ptr = hcc_stack_get_last(c->pp.expand_stack);
	HCC_DEBUG_ASSERT(popped_ptr == expected_expand, "internal error: we expected to pop %p but it was actually %p", expected_expand, popped_ptr);
	hcc_stack_pop(c->pp.expand_stack);
	hcc_stack_pop(c->pp.expand_macro_idx_stack);
}

void hcc_pp_copy_expand_range(HccCompiler* c, HccPPExpand* expand, HccTokenBag* dst_bag, HccTokenBag* src_bag, HccTokenBag* alt_dst_bag, HccLocation* parent_or_child_location, HccLocation* grandparent_location, HccPPExpandFlags flags, HccPPMacro* expand_macro) {
	//
	// copy each token from src_bag into the dst_bag, while looking out for macros to expand into the dst_bag
	//
	while (expand->cursor.token_idx < expand->cursor.tokens_end_idx) {
		HccToken token = *hcc_stack_get(src_bag->tokens, expand->cursor.token_idx);
		if (token == HCC_TOKEN_MACRO_WHITESPACE) {
			if ((flags & HCC_PP_EXPAND_FLAGS_DEST_IS_ORIGINAL_LOCATION) || *hcc_stack_get_last(dst_bag->tokens) == HCC_TOKEN_MACRO_WHITESPACE) {
				expand->cursor.token_idx += 1;
				continue;
			}
		}

		U32 location_idx = *hcc_stack_get(src_bag->token_location_indices, expand->cursor.token_idx);
		bool is_preexpanded_macro_arg = location_idx & HCC_PP_TOKEN_IS_PREEXPANDED_MACRO_ARG_MASK;
		location_idx &= ~HCC_PP_TOKEN_IS_PREEXPANDED_MACRO_ARG_MASK;
		HccLocation* token_location = hcc_stack_get(c->tokengen.token_locations, location_idx);

		location_idx = hcc_stack_count(c->tokengen.token_locations);
		HccLocation* location = hcc_stack_push(c->tokengen.token_locations);
		{
			if ((flags & HCC_PP_EXPAND_FLAGS_IS_ARGS) || !is_preexpanded_macro_arg) {
				//
				// location needs a parent as we are either are:
				//     - copying the contents of argument tokens
				//     - copying a macro and are not on any of the preexpanded macro argument tokens
				//
				HccLocation* parent_location;
				HccLocation* child_location;
				HccPPMacro* macro;
				if ((flags & HCC_PP_EXPAND_FLAGS_IS_ARGS)) {
					// for expanded macro argument tokens:
					// the child is the macro parameter location for all of the argument tokens.
					// the parent is the original argument token location at the callsite
					bool is_same = parent_location == grandparent_location;
					parent_location = hcc_stack_push(c->tokengen.token_locations);
					*parent_location = *token_location;
					if (!is_same && grandparent_location) {
						hcc_pp_attach_to_most_parent(c, parent_location, grandparent_location);
					}
					if (!token_location->macro) {
						parent_location->macro = expand->macro;
					}
					child_location = parent_or_child_location;
					macro = expand_macro;
				} else {
					// for expanded macro tokens:
					// the child is the original macro token location
					// the parent is the whole macro span at the callsite
					parent_location = parent_or_child_location;
					child_location = token_location;
					macro = expand_macro;
				}

				*location = *child_location;
				location->parent_location = parent_location;
				location->macro = macro;
			} else {
				//
				// we are on a argument that has been preexpanded before
				// so there is no need to setup any parent location or macro links
				*location = *token_location;
			}
		}

		if (token == HCC_TOKEN_IDENT) {
			HccStringId ident_string_id = hcc_stack_get(src_bag->token_values, expand->cursor.token_value_idx)->string_id;

			U32 macro_idx;
			if (hcc_pp_is_callable_macro(c, ident_string_id, &macro_idx)) {
				//
				// we found a callable macro, lets expand it into the dst_bag
				//
				HccPPMacro* macro = hcc_pp_macro_get(c, macro_idx);
				bool can_expand = true;
				if (macro->is_function) {
					HccToken* next_token = hcc_stack_get_or_null(src_bag->tokens, expand->cursor.token_idx + 1);
					HccToken* next_next_token = hcc_stack_get_or_null(src_bag->tokens, expand->cursor.token_idx + 2);
					can_expand = next_token &&
						(*next_token == HCC_TOKEN_PARENTHESIS_OPEN ||
							(*next_token == HCC_TOKEN_MACRO_WHITESPACE &&
								next_next_token && *next_next_token == HCC_TOKEN_PARENTHESIS_OPEN));
				}

				if (can_expand) {
					expand->cursor.token_idx += 1; // skip the identifier token
					expand->cursor.token_value_idx += 1;

					HccLocation* callsite_location = location;
					HccPPExpandFlags expand_flags = flags;
					if (expand_flags & HCC_PP_EXPAND_FLAGS_IS_ARGS) {
						expand_flags |= HCC_PP_EXPAND_FLAGS_DEST_IS_ARGS;
						expand_flags &= ~HCC_PP_EXPAND_FLAGS_IS_ARGS;
						callsite_location = location->parent_location;
					}
					hcc_pp_copy_expand_macro(c, macro, callsite_location, location, expand, src_bag, dst_bag, alt_dst_bag, expand_flags);
					continue;
				}
			}
		}

		if ((flags & HCC_PP_EXPAND_FLAGS_DEST_IS_ORIGINAL_LOCATION)) {
			HccToken bracket = token - HCC_TOKEN_BRACKET_START;
			if (bracket < HCC_TOKEN_BRACKET_COUNT) {
				if (bracket % 2 == 0) {
					hcc_tokengen_bracket_open(c, token, location);
				} else {
					hcc_tokengen_bracket_close(c, token, location);
				}
			}
		}

		//
		// copy the token/location/value
		//
		*hcc_stack_push(dst_bag->tokens) = token;

		U32 mask = (flags & (HCC_PP_EXPAND_FLAGS_IS_ARGS | HCC_PP_EXPAND_FLAGS_DEST_IS_ARGS)) ? HCC_PP_TOKEN_IS_PREEXPANDED_MACRO_ARG_MASK : 0;
		*hcc_stack_push(dst_bag->token_location_indices) = location_idx | mask;

		expand->cursor.token_idx += 1;

		U32 num_values = hcc_token_num_values(token);
		for (U32 value_idx = 0; value_idx < num_values; value_idx += 1) {
			*hcc_stack_push(dst_bag->token_values) =
				*hcc_stack_get(src_bag->token_values, expand->cursor.token_value_idx);
			expand->cursor.token_value_idx += 1;
		}
	}
}

void hcc_pp_copy_expand_macro(HccCompiler* c, HccPPMacro* macro, HccLocation* macro_callsite_location, HccLocation* parent_location, HccPPExpand* arg_expand, HccTokenBag* args_src_bag, HccTokenBag* dst_bag, HccTokenBag* alt_dst_bag, HccPPExpandFlags flags) {
	U32 restore_to_tokens_count = hcc_stack_count(alt_dst_bag->tokens);
	U32 restore_to_token_values_count = hcc_stack_count(alt_dst_bag->token_values);
	U32 restore_to_expand_args_count = hcc_stack_count(c->pp.macro_args_stack);
	U32 args_start_idx = U32_MAX;
	HccTokenBag* src_bag = &c->pp.macro_token_bag;

	if (macro->is_function) {
		args_start_idx = hcc_pp_process_macro_args(c, macro, arg_expand, args_src_bag, parent_location);
		HccLocation* final_location = hcc_token_bag_location_get(c, args_src_bag, arg_expand->cursor.tokens_end_idx - 1);
		hcc_location_merge_apply(macro_callsite_location, final_location);
	}

	HccPPExpand* macro_expand;
	if (macro->is_function) {
		//
		// copy a contents of the macro and the expanded argument tokens into the alt_dst_bag
		// this is so that the expanded tokens do not go where the macro needs to be expanded in the dst_bag
		//
		U32 tokens_start_idx = hcc_stack_count(alt_dst_bag->tokens);
		U32 token_values_start_idx = hcc_stack_count(alt_dst_bag->token_values);
		HccTokenCursor cursor = macro->token_cursor;
		while (cursor.token_idx < cursor.tokens_end_idx) {
			HccToken token = *hcc_stack_get(src_bag->tokens, cursor.token_idx);
			switch (token) {
				case HCC_TOKEN_MACRO_PARAM: {
					HccLocation* location = hcc_token_bag_location_get(c, src_bag, cursor.token_idx);
					U32 param_idx = hcc_stack_get(src_bag->token_values, cursor.token_value_idx)->macro_param_idx;

					HccPPExpand* param_arg_expand = hcc_pp_expand_push_macro_arg(c, param_idx, args_start_idx, NULL);
					param_arg_expand->macro = arg_expand->macro;

					HccLocation* grandparent_location = (flags & HCC_PP_EXPAND_FLAGS_DEST_IS_ARGS)
						? parent_location
						: parent_location->parent_location;
					hcc_pp_copy_expand_range(c, param_arg_expand, alt_dst_bag, args_src_bag, dst_bag, location, grandparent_location, HCC_PP_EXPAND_FLAGS_IS_ARGS, macro);
					hcc_pp_expand_pop(c, param_arg_expand);

					cursor.token_idx += 1;
					cursor.token_value_idx += 1;
					continue;
				};

				case HCC_TOKEN_MACRO_STRINGIFY:
				case HCC_TOKEN_MACRO_STRINGIFY_WHITESPACE: {
					U32 param_idx = hcc_stack_get(src_bag->token_values, cursor.token_value_idx)->macro_param_idx;

					HccLocation* callsite_location;
					HccPPExpand* param_arg_expand = hcc_pp_expand_push_macro_arg(c, param_idx, args_start_idx, &callsite_location);

					hcc_stack_clear(c->pp.stringify_buffer);
					HccStringId string_id = hcc_token_bag_stringify_range(c, args_src_bag, &param_arg_expand->cursor, NULL);
					hcc_pp_expand_pop(c, param_arg_expand);

					//
					// push on the location
					*hcc_stack_push(alt_dst_bag->token_location_indices) = hcc_stack_count(c->tokengen.token_locations) | HCC_PP_TOKEN_IS_PREEXPANDED_MACRO_ARG_MASK;
					HccLocation* dst_location = hcc_stack_push(c->tokengen.token_locations);
					*dst_location = *hcc_token_bag_location_get(c, src_bag, cursor.token_idx);
					dst_location->parent_location = callsite_location;
					dst_location->macro = macro;

					*hcc_stack_push(alt_dst_bag->tokens) = HCC_TOKEN_STRING;
					hcc_stack_push(alt_dst_bag->token_values)->string_id = string_id;

					cursor.token_idx += 1;
					cursor.token_value_idx += 1;
					continue;
				};

				case HCC_TOKEN_MACRO_CONCAT:
				case HCC_TOKEN_MACRO_CONCAT_WHITESPACE: {
					cursor.token_idx += 1;

					hcc_stack_clear(c->pp.stringify_buffer);

					HccLocation* before = hcc_token_bag_location_get(c, src_bag, cursor.token_idx);
					HccToken before_token = hcc_token_bag_stringify_single_or_macro_param(c, src_bag, &cursor, args_start_idx, args_src_bag, false);
					U32 before_end_idx = hcc_stack_count(c->pp.stringify_buffer) - 1;
					U32 after_start_idx = hcc_stack_count(c->pp.stringify_buffer);
					if (*hcc_stack_get(src_bag->tokens, cursor.token_idx) == HCC_TOKEN_MACRO_WHITESPACE) {
						cursor.token_idx += 1;
					}

					HccLocation* after = hcc_token_bag_location_get(c, src_bag, cursor.token_idx);
					HccToken after_token = hcc_token_bag_stringify_single_or_macro_param(c, src_bag, &cursor, args_start_idx, args_src_bag, true);
					U32 location_idx = hcc_stack_count(c->tokengen.token_locations);
					HccLocation* dst_location = hcc_stack_push(c->tokengen.token_locations);
					*dst_location = *before;
					hcc_location_merge_apply(dst_location, after);
					dst_location->parent_location = parent_location;
					dst_location->macro = macro;

					HccCodeFile* code_file = c->concat_buffer_code_file;
					hcc_stack_clear(code_file->line_code_start_indices);
					*hcc_stack_push(code_file->line_code_start_indices) = 0;
					*hcc_stack_push(code_file->line_code_start_indices) = 0;
					code_file->code = hcc_string(c->pp.stringify_buffer, hcc_stack_count(c->pp.stringify_buffer));
					hcc_tokengen_location_push(c);
					hcc_tokengen_location_setup_new_file(c, code_file, false);
					c->tokengen.location.parent_location = dst_location;

					if (before_token != HCC_TOKEN_COUNT && after_token != HCC_TOKEN_COUNT) {
						if (!hcc_token_concat_is_okay(before_token, after_token)) {
							hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_INVALID_PP_CONCAT_OPERANDS, hcc_token_strings[before_token], hcc_token_strings[after_token]);
						}
					}

					U32 token_location_start_idx = hcc_stack_count(alt_dst_bag->token_location_indices);
					hcc_tokengen_run(c, alt_dst_bag, HCC_TOKENGEN_RUN_MODE_PP_CONCAT);

					//
					// hcc_tokengen_run puts the locations in the token bag but we don't care about them.
					// what we really want is the location that spans the concatination operands and links back to their parents.
					// so just link to it as a stable pointer.
					for (U32 idx = token_location_start_idx; idx < hcc_stack_count(alt_dst_bag->token_location_indices); idx += 1) {
						*hcc_stack_get(alt_dst_bag->token_location_indices, idx) = location_idx;
					}

					//
					// remove the added locations that we don't care about
					hcc_stack_resize(c->tokengen.token_locations, location_idx + 1);
					continue;
				};
				case HCC_TOKEN_MACRO_WHITESPACE:
					if (*hcc_stack_get_last(alt_dst_bag->tokens) == HCC_TOKEN_MACRO_WHITESPACE) {
						cursor.token_idx += 1;
						continue;
					}
					break;
			}

			//
			// copy the token/location/value
			//

			*hcc_stack_push(alt_dst_bag->tokens) = token;
			*hcc_stack_push(alt_dst_bag->token_location_indices) = *hcc_stack_get(src_bag->token_location_indices, cursor.token_idx);
			cursor.token_idx += 1;

			U32 num_values = hcc_token_num_values(token);
			for (U32 value_idx = 0; value_idx < num_values; value_idx += 1) {
				*hcc_stack_push(alt_dst_bag->token_values) =
					*hcc_stack_get(src_bag->token_values, cursor.token_value_idx);
				cursor.token_value_idx += 1;
			}
		}

		//
		// setup the copy expand after so that this same macro can be expanded as a macro argument to itself
		macro_expand = hcc_pp_expand_push_macro(c, macro);
		macro_expand->cursor.token_idx = tokens_start_idx;
		macro_expand->cursor.tokens_end_idx = hcc_stack_count(alt_dst_bag->tokens);
		macro_expand->cursor.token_value_idx = token_values_start_idx;
		src_bag = alt_dst_bag;
	} else {
		//
		// just use the macros' tokens directly since this is a non function macro
		//
		macro_expand = hcc_pp_expand_push_macro(c, macro);
	}


	//
	// expand the macro tokens into the dst_bag
	//
	hcc_pp_copy_expand_range(c, macro_expand, dst_bag, src_bag, alt_dst_bag, parent_location, NULL, flags, macro);
	hcc_pp_expand_pop(c, macro_expand);

	//
	// remove all of the temporary tokens from the alt_dst_bag
	// that where generated for the expansion of the macro.
	//
	hcc_stack_resize(alt_dst_bag->tokens, restore_to_tokens_count);
	hcc_stack_resize(alt_dst_bag->token_location_indices, restore_to_tokens_count);
	hcc_stack_resize(alt_dst_bag->token_values, restore_to_token_values_count);
	hcc_stack_resize(c->pp.macro_args_stack, restore_to_expand_args_count);
}

U32 hcc_pp_process_macro_args(HccCompiler* c, HccPPMacro* macro, HccPPExpand* expand, HccTokenBag* src_bag, HccLocation* parent_location) {
	HCC_DEBUG_ASSERT(
		*hcc_stack_get(src_bag->tokens, expand->cursor.token_idx) == HCC_TOKEN_PARENTHESIS_OPEN ||
			(*hcc_stack_get(src_bag->tokens, expand->cursor.token_idx) == HCC_TOKEN_MACRO_WHITESPACE &&
				*hcc_stack_get(src_bag->tokens, expand->cursor.token_idx + 1) == HCC_TOKEN_PARENTHESIS_OPEN),
		"internal error: expected to be on a '(' for the macro function arguments"
	);
	expand->cursor.token_idx += *hcc_stack_get(src_bag->tokens, expand->cursor.token_idx) == HCC_TOKEN_MACRO_WHITESPACE ? 2 : 1;

	//
	// scan the src_bag tokens and keep a record of the token ranges for each macro argument in
	// the c->pp.macro_args_stack array
	//
	U32 args_start_idx = hcc_stack_count(c->pp.macro_args_stack);
	HccPPMacroArg* arg = hcc_pp_push_macro_arg(c, expand, src_bag, parent_location);
	U32 nested_parenthesis = 0;
	bool reached_va_args = macro->has_va_args && macro->params_count == 1;
	while (1) {
		HccToken token = *hcc_stack_get(src_bag->tokens, expand->cursor.token_idx);
		HccLocation* location = hcc_token_bag_location_get(c, src_bag, expand->cursor.token_idx);

		switch (token) {
			case HCC_TOKEN_COMMA:
				if (nested_parenthesis == 0 && !reached_va_args) {
					//
					// we found a ',' outside of nested_parenthesis,
					// so lets finalize the current argument and start the next one.
					expand->cursor.token_idx += 1;
					hcc_pp_finalize_macro_arg(c, arg, expand, src_bag);

					//
					// start the next argument
					//
					arg = hcc_pp_push_macro_arg(c, expand, src_bag, parent_location);

					U32 args_count = hcc_stack_count(c->pp.macro_args_stack) - args_start_idx;
					if (macro->has_va_args && args_count == macro->params_count) {
						//
						// we have reached the variable argument, so just group all
						// of the arguments that follow into this last argument.
						reached_va_args = true;
					}
					continue;
				}
				break;

			case HCC_TOKEN_PARENTHESIS_OPEN:
				nested_parenthesis += 1;
				expand->cursor.token_idx += 1;
				continue;

			case HCC_TOKEN_PARENTHESIS_CLOSE:
				expand->cursor.token_idx += 1;
				if (nested_parenthesis == 0) {
					goto BREAK;
				}
				nested_parenthesis -= 1;
				continue;
		}

		expand->cursor.token_idx += 1;
		expand->cursor.token_value_idx += hcc_token_num_values(token);
	}
BREAK: {}
	hcc_pp_finalize_macro_arg(c, arg, expand, src_bag);

	U32 args_count = hcc_stack_count(c->pp.macro_args_stack) - args_start_idx;
	if (args_count == 1 && arg->cursor.tokens_start_idx == arg->cursor.tokens_end_idx) {
		args_count = 0;
	}

	if (args_count < macro->params_count) {
		// this is not a error that breaks a rule in the C spec.
		// TODO: see if we want ot have a compiler option to enable this.
		// hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_NOT_ENOUGH_MACRO_ARGUMENTS, macro->params_count, args_count);

		U32 missing_count = macro->params_count - args_count;
		HccPPMacroArg* args = hcc_stack_push_many(c->pp.macro_args_stack, missing_count);
		HCC_ZERO_ELMT_MANY(args, missing_count);
	} else if (args_count > macro->params_count) {
		hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_TOO_MANY_MACRO_ARGUMENTS, macro->params_count, args_count);
	}
	return args_start_idx;
}

HccPPMacroArg* hcc_pp_push_macro_arg(HccCompiler* c, HccPPExpand* expand, HccTokenBag* src_bag, HccLocation* parent_location) {
	HccPPMacroArg* arg = hcc_stack_push(c->pp.macro_args_stack);
	arg->cursor.tokens_start_idx = expand->cursor.token_idx;
	arg->cursor.token_idx = expand->cursor.token_idx;
	arg->cursor.token_value_idx = expand->cursor.token_value_idx;
	arg->callsite_location = hcc_stack_push(c->tokengen.token_locations);
	HccLocation* src_location = hcc_token_bag_location_get(c, src_bag, expand->cursor.token_idx);
	*arg->callsite_location = *src_location;
	bool is_same = parent_location == src_location;
	if (!is_same && parent_location) {
		hcc_pp_attach_to_most_parent(c, arg->callsite_location, parent_location);
	}
	arg->callsite_location->macro = expand->macro;
	return arg;
}

void hcc_pp_finalize_macro_arg(HccCompiler* c, HccPPMacroArg* arg, HccPPExpand* expand, HccTokenBag* src_bag) {
	arg->cursor.tokens_end_idx = expand->cursor.token_idx - 1;
	HccLocation* location = hcc_token_bag_location_get(c, src_bag, expand->cursor.token_idx - 2);
	hcc_location_merge_apply(arg->callsite_location, location);
	if (*hcc_stack_get(src_bag->tokens, arg->cursor.tokens_start_idx) == HCC_TOKEN_MACRO_WHITESPACE) {
		arg->cursor.tokens_start_idx += 1;
		arg->cursor.token_idx += 1;
	}

	if (*hcc_stack_get(src_bag->tokens, arg->cursor.tokens_end_idx - 1) == HCC_TOKEN_MACRO_WHITESPACE) {
		arg->cursor.tokens_end_idx -= 1;
	}
}

void hcc_pp_attach_to_most_parent(HccCompiler* c, HccLocation* location, HccLocation* parent_location) {
	HccLocation* a = location;
	while (a) {
		HccLocation* b = parent_location;
		while (b) {
			if (a == b) {
				return;
			}

			b = b->parent_location;
		}
		a = a->parent_location;
	}

	HccLocation* prev_pl = location;
	HccLocation* pl = location;
	while (pl->parent_location) {
		prev_pl = pl;
		pl = pl->parent_location;
	}

	if (prev_pl->parent_location) {
		pl = hcc_stack_push(c->tokengen.token_locations);
		*pl = *prev_pl->parent_location;
		prev_pl->parent_location = pl;
	}
	pl->parent_location = parent_location;
}

// ===========================================
//
//
// Error
//
//
// ===========================================

const char* hcc_message_type_lang_strings[HCC_LANG_COUNT][HCC_MESSAGE_TYPE_COUNT] = {
	[HCC_LANG_ENG] = {
		[HCC_MESSAGE_TYPE_ERROR] = "error",
		[HCC_MESSAGE_TYPE_WARN] = "warning",
	},
};

const char* hcc_message_type_ascii_color_code[HCC_MESSAGE_TYPE_COUNT] = {
	[HCC_MESSAGE_TYPE_ERROR] = "\x1b[1;91m",
	[HCC_MESSAGE_TYPE_WARN] = "\x1b[1;93m",
};

const char* hcc_error_code_lang_fmt_strings[HCC_LANG_COUNT][HCC_ERROR_CODE_COUNT] = {
	[HCC_LANG_ENG] = {
		[HCC_ERROR_CODE_NONE] = "internal error: there is no error code set for this error",

		//
		// tokengen
		[HCC_ERROR_CODE_INVALID_TOKEN_MACRO_IDENTIFIER] = "invalid token '%c' for macro identifier",
		[HCC_ERROR_CODE_INVALID_TOKEN_MACRO_PARAM_IDENTIFIER] = "invalid token '%c' for macro parameter identifier",
		[HCC_ERROR_CODE_DUPLICATE_MACRO_PARAM_IDENTIFIER] = "duplicate macro argument identifier '%.*s'",
		[HCC_ERROR_CODE_INVALID_MACRO_PARAM_DELIMITER] = "expected a ',' to declaring more macro arguments or a ')' to finish declaring macro arguments",
		[HCC_ERROR_CODE_MACRO_PARAM_VA_ARG_NOT_LAST] = "cannot declare another parameter, the vararg '...' parameter must come last",
		[HCC_ERROR_CODE_MACRO_ALREADY_DEFINED] = "the '%.*s' macro has already been defined and is not identical",
		[HCC_ERROR_CODE_INVALID_INCLUDE_OPERAND] = "expected a '<' or '\"' to define the path to the file you wish to include",
		[HCC_ERROR_CODE_TOO_MANY_INCLUDE_OPERANDS] = "too many operands for the '#include' directive",
		[HCC_ERROR_CODE_INCLUDE_PATH_IS_EMPTY] = "no file path was provided for this include directive",
		[HCC_ERROR_CODE_INCLUDE_PATH_DOES_NOT_EXIST] = "cannot find the include file in any of the search paths",
		[HCC_ERROR_CODE_FAILED_TO_OPEN_FILE_FOR_READ] = "failed to open file for read at '%s': %s",
		[HCC_ERROR_CODE_CONDITION_HAS_NO_PP_TOKENS] = "condition expands to no preprocessor tokens",
		[HCC_ERROR_CODE_INVALID_PP_BINARY_OP] = "'%s' is not a valid preprocessor binary operator",
		[HCC_ERROR_CODE_INVALID_PP_UNARY_EXPR] = "'%s' is not a valid preprocessor unary expression",
		[HCC_ERROR_CODE_EXPECTED_PARENTHESIS_CLOSE] = "expected a ')' here to finish the expression",
		[HCC_ERROR_CODE_UNDEFINED_IDENTIFIER_IN_PP_EXPR] = "undefined identifier in preprocessor expression",
		[HCC_ERROR_CODE_EXPECTED_COLON_FOR_TERNARY_OP] =  "expected a ':' for the false side of the ternary expression",
		[HCC_ERROR_CODE_INVALID_PP_LINE_OPERANDS] = "expected a decimal integer for a custom line number that can be optionally followed by a string literal for a custom file path. eg. #line 210 \"path/to/file.c\"",
		[HCC_ERROR_CODE_PP_LINE_MUST_BE_MORE_THAN_ZERO] = "the decimal integer for #line must be more than 0 and no more than %d",
		[HCC_ERROR_CODE_TOO_MANY_PP_LINE_OPERANDS] = "#line has got too many operands, we only expect a custom line number and optionally a custom file path",
		[HCC_ERROR_CODE_PP_ERROR] = "#error '%.*s'",
		[HCC_ERROR_CODE_INVALID_PP_PRAGMA_OPERAND] = "the first #pragma operand must be an identifier",
		[HCC_ERROR_CODE_PP_PRAGMA_OPERAND_USED_IN_MAIN_FILE] = "#pragma once cannot be used in the main source file",
		[HCC_ERROR_CODE_TOO_MANY_PP_PRAGMA_OPERANDS] = "too many operands for the '#pragma %.*s' directive",
		[HCC_ERROR_CODE_INVALID_TOKEN_PREPROCESSOR_DIRECTIVE] =  "invalid token '%c' for preprocessor directive",
		[HCC_ERROR_CODE_INVALID_PREPROCESSOR_DIRECTIVE] =  "invalid preprocessor directive '#%.*s'",
		[HCC_ERROR_CODE_PP_ENDIF_BEFORE_IF] = "'#%s' must follow an open #if/#ifdef/#ifndef",
		[HCC_ERROR_CODE_PP_ELSEIF_CANNOT_FOLLOW_ELSE] = "'#%s' cannot follow an '#else' in the same preprocessor if chain",
		[HCC_ERROR_CODE_PP_IF_UNTERMINATED] = "missing #endif to match this unterminated '#%s'",
		[HCC_ERROR_CODE_INVALID_PP_CONCAT_OPERANDS] = "'%s' and '%s' doesn't combine into valid token",
		[HCC_ERROR_CODE_TOO_MANY_UNDEF_OPERANDS] = "#%s has too many operands, we only expect an identifier operand to undefine a macro",
		[HCC_ERROR_CODE_TOO_MANY_IFDEF_OPERANDS] = "#%s has too many operands, we only expect an identifier operand check if it is defined or not",
		[HCC_ERROR_CODE_PP_DIRECTIVE_NOT_FIRST_ON_LINE] = "invalid token '#', preprocessor directives must be the first non-whitespace on the line",
		[HCC_ERROR_CODE_INVALID_OCTAL_DIGIT] = "octal digits must be from 0 to 7 inclusively",
		[HCC_ERROR_CODE_MAX_UINT_OVERFLOW] = "integer literal is too large and will overflow a U64 integer",
		[HCC_ERROR_CODE_MAX_SINT_OVERFLOW] = "integer literal is too large and will overflow a S64 integer",
		[HCC_ERROR_CODE_MAX_SINT_OVERFLOW_DECIMAL] = "integer literal is too large and will overflow a S64 integer, consider using 'u' suffix to promote to an unsigned type. e.g. 1000u",
		[HCC_ERROR_CODE_MAX_FLOAT_OVERFLOW] = "float literal is too large and will overflow a f64",
		[HCC_ERROR_CODE_U_SUFFIX_ALREADY_USED] = "the 'u' suffix can only be applied once",
		[HCC_ERROR_CODE_U_SUFFIX_ON_FLOAT] = "the 'u' suffix cannot be applied to a floating point literal",
		[HCC_ERROR_CODE_L_SUFFIX_ON_FLOAT] = "the 'l' suffix must be applied to a double literal not a float",
		[HCC_ERROR_CODE_LONG_DOUBLE_IS_UNSUPPORTED] = "the 'l' suffix for a long double is unsupported",
		[HCC_ERROR_CODE_FLOAT_HAS_DOUBLE_FULL_STOP] = "float literals can only have a single '.'",
		[HCC_ERROR_CODE_FLOAT_MUST_BE_DECIMAL] = "octal and hexidecimal digits are not supported for float literals",
		[HCC_ERROR_CODE_FLOAT_SUFFIX_MUST_FOLLOW_DECIMAL_PLACE] = "the 'f' suffix must come after a decimal place/full stop '.' e.g. 0.f or 1.0f",
		[HCC_ERROR_CODE_INVALID_INTEGER_LITERALS] = "invalid suffix for integer literals",
		[HCC_ERROR_CODE_INVALID_FLOAT_LITERALS] = "invalid suffix for float literals",
		[HCC_ERROR_CODE_NO_BRACKETS_OPEN] = "no brackets are open to close '%s'",
		[HCC_ERROR_CODE_INVALID_CLOSE_BRACKET_PAIR] = "expected to close bracket pair with '%s' but got '%s'",
		[HCC_ERROR_CODE_UNCLOSED_STRING_LITERAL] = "unclosed string literal. close with '%c' or strings spanning to the next line must end the line with '\\'",
		[HCC_ERROR_CODE_MACRO_STARTS_WITH_CONCAT] = "macro cannot start with '##', this operator is used to concatinate two tokens. eg. ident ## ifier and 100. ## f",
		[HCC_ERROR_CODE_STRINGIFY_MUST_BE_MACRO_PARAM] = "macro stringify '#' operator can only be used on a macro parameter",
		[HCC_ERROR_CODE_INVALID_TOKEN] = "invalid token '%c'",
		[HCC_ERROR_CODE_INVALID_TOKEN_HASH_IN_PP_OPERAND] = "invalid token '#', not allowed in preprocessor operand",
		[HCC_ERROR_CODE_EXPECTED_IDENTIFIER_PP_IF_DEFINED] = "expected an 'identifier' of a macro to follow the 'defined' preprocessor unary operator",
		[HCC_ERROR_CODE_EXPECTED_PARENTHESIS_CLOSE_DEFINED] = "expected an ')' to finish the 'defined' preprocessor unary operator",
		[HCC_ERROR_CODE_INVALID_USE_OF_VA_ARGS] = "'__VA_ARGS__' can only be used in a function-like macro that has '...' as it's last parameter",
		[HCC_ERROR_CODE_VA_ARGS_IN_MACRO_PARAMETER] = "'__VA_ARGS__' cannot be used as a macro parameter. use '...' here as the  last parameter to have variable arguments for this macro. and use '__VA_ARGS__' to in the macro itself.",
		[HCC_ERROR_CODE_NOT_ENOUGH_MACRO_ARGUMENTS] = "not enough arguments. expected '%u' but got '%u'",
		[HCC_ERROR_CODE_TOO_MANY_MACRO_ARGUMENTS] = "too many arguments. expected '%u' but got '%u'",

		//
		// astgen
		[HCC_ERROR_CODE_CANNOT_FIND_FIELD] = "cannot find a '%.*s' field in the '%.*s' type",
		[HCC_ERROR_CODE_DUPLICATE_FIELD_IDENTIFIER] = "duplicate field identifier '%.*s' in '%.*s'",
		[HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_CONDITION] =  "the condition expression must be convertable to a boolean but got '%.*s'",
		[HCC_ERROR_CODE_MISSING_SEMICOLON] = "missing ';' to end the statement",
		[HCC_ERROR_CODE_REDEFINITION_IDENTIFIER_GLOBAL] = "redefinition of the '%.*s' identifier",
		[HCC_ERROR_CODE_EXPECTED_CURLY_OPEN_ENUM] = "expected '{' to declare enum type values",
		[HCC_ERROR_CODE_REIMPLEMENTATION] = "redefinition of '%.*s'",
		[HCC_ERROR_CODE_EMPTY_ENUM] = "cannot have an empty enum, please declare some identifiers inside the {}",
		[HCC_ERROR_CODE_EXPECTED_IDENTIFIER_ENUM_VALUE] = "expected an identifier for the enum value name",
		[HCC_ERROR_CODE_ENUM_VALUE_OVERFLOW] = "enum value overflows a 32 bit signed integer",
		[HCC_ERROR_CODE_ENUM_VALUE_INVALID_FORMAT] = "expected a constant integer value that fits into signed 32 bits",
		[HCC_ERROR_CODE_ENUM_VALUE_INVALID_TERMINATOR_WITH_EXPLICIT_VALUE] = "expected a ',' to declare another value or a '}' to finish the enum values",
		[HCC_ERROR_CODE_ENUM_VALUE_INVALID_TERMINATOR] = "expected an '=' to assign a value explicitly, ',' to declare another value or a '}' to finish the enum values",
		[HCC_ERROR_CODE_INTRINSIC_NOT_FOUND_FUNCTION] = "function '%.*s' is not a valid intrinsic for this compiler version",
		[HCC_ERROR_CODE_INTRINSIC_NOT_FOUND_STRUCT] = "'struct %.*s' is not a valid intrinsic for this compiler version",
		[HCC_ERROR_CODE_INTRINSIC_NOT_FOUND_UNION] = "'union %.*s' is not a valid intrinsic for this compiler version",
		[HCC_ERROR_CODE_INVALID_SPECIFIER_FOR_STRUCT] = "only one of these can be used per field: '%s' or '%s'",
		[HCC_ERROR_CODE_INVALID_SPECIFIER_CONFIG_FOR_STRUCT] = "the '%s' keyword cannot be used on this structure declaration",
		[HCC_ERROR_CODE_NOT_AVAILABLE_FOR_UNION] = "the '%s' keyword can only be used on a 'struct' and not a 'union'",
		[HCC_ERROR_CODE_EXPECTED_CURLY_OPEN_COMPOUND_TYPE] = "expected '{' to declare compound type fields",
		[HCC_ERROR_CODE_INVALID_SPECIFIER_FOR_STRUCT_FIELD] = "the '%s' keyword cannot be used on this structure field declaration",
		[HCC_ERROR_CODE_INVALID_SPECIFIER_CONFIG_FOR_STRUCT_FIELD] = "only one of these can be used per field: '%s' or '%s'",
		[HCC_ERROR_CODE_COMPOUND_FIELD_INVALID_TERMINATOR] = "expected 'type name', 'struct' or 'union' to declare another field or '}' to finish declaring the compound type fields",
		[HCC_ERROR_CODE_COMPOUND_FIELD_MISSING_NAME] = "expected an identifier for the field name",
		[HCC_ERROR_CODE_INTRINSIC_INVALID_COMPOUND_STRUCT_FIELDS_COUNT] = "expected intrinsic struct '%.*s' to have '%u' fields but got '%u'",
		[HCC_ERROR_CODE_INTRINSIC_INVALID_COMPOUND_STRUCT_FIELD] = "expected this intrinsic field to be '%.*s %.*s' for this compiler version",
		[HCC_ERROR_CODE_INTRINSIC_VECTOR_INVALID_SIZE_AND_ALIGN] = "expected the size and align for the intrinsic vector type '%.*s' to be size '%u' and align '%u' but got size '%u' and align '%u'",
		[HCC_ERROR_CODE_INTRINSIC_MATRIX_INVALID_SIZE_AND_ALIGN] = "expected the size and align for the intrinsic matrix type '%.*s' to be size '%u' and align '%u' but got size '%u' and align '%u'",
		[HCC_ERROR_CODE_MISSING_RASTERIZER_STATE_SPECIFIER] = "'%s' specifier must be placed before this struct definition before using '%s' or '%s'",
		[HCC_ERROR_CODE_POSITION_ALREADY_SPECIFIED] = "'%s' has already been specified once before in rasterizer state structure",
		[HCC_ERROR_CODE_EXPECTED_PARENTHESIS_OPEN_ALIGNAS] = "expected '(' to follow _Alignas that contains a type or integer constant. eg. _Alignas(int) or _Alignas(16)",
		[HCC_ERROR_CODE_ALIGNAS_ON_SPECIAL_COMPOUND_DATA_TYPE] = "_Alignas cannot be used on structs declare with the HCC_DEFINE_* macros",
		[HCC_ERROR_CODE_INVALID_ALIGNAS_INT_CONSTANT] = "_Alignas integer constant must be an unsigned value",
		[HCC_ERROR_CODE_INVALID_ALIGNAS_OPERAND] = "invalid _Alignas operand. expected a type or integer constant. eg. _Alignas(int) or _Alignas(16)",
		[HCC_ERROR_CODE_EXPECTED_PARENTHESIS_CLOSE_ALIGNAS] = "expected ')' to follow the type or integer constant for _Alignas",
		[HCC_ERROR_CODE_ALIGNAS_REDUCES_ALIGNMENT] = "_Alignas cannot specify a lower alignment to '%zu' when it already has '%zu'",
		[HCC_ERROR_CODE_EXPECTED_PARENTHESIS_OPEN_RESOURCE_SET_SLOT] = "expected '(' to follow __hcc_resource_set that contains the slot integer",
		[HCC_ERROR_CODE_RESOURCE_SET_SLOT_OUT_OF_BOUNDS] = "resource set slot must '0' to '%u' but got '%zu'. this can be changed in the compiler by using 'TODO compiler option'",
		[HCC_ERROR_CODE_RESOURCE_SET_MUST_BE_A_UINT] = "resource set slot must an unsigned integer value of '0' to '%u'",
		[HCC_ERROR_CODE_EXPECTED_PARENTHESIS_CLOSE_RESOURCE_SET_SLOT] = "expected ')' to follow the slot integer for the resource set",
		[HCC_ERROR_CODE_CONST_BUFFER_IN_RESOURCES_USING_BINDLESS] = "HCC_DEFINE_RESOURCES cannot contain ConstBuffer while using bindless resource model",
		[HCC_ERROR_CODE_MATCHING_RESOURCE_SLOTS_IN_RESOURCES] = "'%.*s' and '%.*s' use the same resource slot '%u'",
		[HCC_ERROR_CODE_OVERFLOW_RESOURCE_CONSTANTS_SIZE] = "HCC_DEFINE_RESOURCES constants size has a maximum size of '%u' but got '%u'",
		[HCC_ERROR_CODE_POSITION_MUST_BE_VEC4_F32] = "field marked with '%s' must be a '%.*s' but got '%.*s'",
		[HCC_ERROR_CODE_POSITION_NOT_SPECIFIED] = "'%s' must be specified for a rasterizer state structure",
		[HCC_ERROR_CODE_EXPECTED_TYPE_NAME] = "expected a 'type name' here but got '%s'",
		[HCC_ERROR_CODE_EXPECTED_PARENTHESIS_OPEN_RESOURCE_TYPE_GENERIC] = "expected '(' to specify the generic type for the '%s' resource type",
		[HCC_ERROR_CODE_EXPECTED_PARENTHESIS_CLOSE_RESOURCE_TYPE_GENERIC] = "expected ')' to follow the resource generic type",
		[HCC_ERROR_CODE_INVALID_TEXEL_TYPE] = "expected texel type to be a intrinsic type but got '%.*s'",
		[HCC_ERROR_CODE_INVALID_BUFFER_ELEMENT_TYPE] = "expected the ConstBuffer/RO/RWElementBuffer type to be defined using the HCC_DEFINE_BUFFER_ELEMENT macro but '%.*s' is not",
		[HCC_ERROR_CODE_INVALID_RESOURCE_TABLE_RESOURCE_MODEL] = "resource table types can only be used on the binding_and_bindless resource model",
		[HCC_ERROR_CODE_UNSIGNED_OR_SIGNED_ON_NON_INT_TYPE] = "'unsigned' and 'signed' cannot be used on this non-integer type",
		[HCC_ERROR_CODE_COMPLEX_ON_NON_FLOAT_TYPE] = "'_Complex' cannot be used on this non-floating-point type",
		[HCC_ERROR_CODE_MULTIPLE_TYPES_SPECIFIED] = "multiple types specfied",
		[HCC_ERROR_CODE_COMPLEX_UNSUPPORTED_AT_THIS_TIME] = "'_Complex' is unsupported at this time",
		[HCC_ERROR_CODE_UNSIGNED_AND_SIGNED] = "'unsigned' and 'signed' cannot be used together",
		[HCC_ERROR_CODE_DUPLICATE_TYPE_SPECIFIER] = "duplicate type specifier '%s'",
		[HCC_ERROR_CODE_EXPECTED_IDENTIFIER_TYPEDEF] = "expected an 'identifier' for the typedef here but got '%s'",
		[HCC_ERROR_CODE_INVALID_SPECIFIER_FOR_TYPEDEF] = "the '%s' keyword cannot be used on this typedef declaration",
		[HCC_ERROR_CODE_INTRINSIC_NOT_FOUND_TYPEDEF] = "'typedef %.*s' is not a valid intrinsic for this compiler version",
		[HCC_ERROR_CODE_INTRINSIC_INVALID_TYPEDEF] = "this intrinsic is supposed to be 'typedef %.*s %.*s' instead of 'typedef %.*s %.*s'",
		[HCC_ERROR_CODE_TYPE_MISMATCH_IMPLICIT_CAST] = "type mismatch '%.*s' is does not implicitly cast to '%.*s'",
		[HCC_ERROR_CODE_TYPE_MISMATCH] = "type mismatch '%.*s' and '%.*s'",
		[HCC_ERROR_CODE_UNSUPPORTED_BINARY_OPERATOR] = "operator '%s' is not supported for data type '%.*s' and '%.*s'",
		[HCC_ERROR_CODE_INVALID_CURLY_EXPR] = "'{' can only be used as the assignment of variable declarations or compound literals",
		[HCC_ERROR_CODE_FIELD_DESIGNATOR_ON_ARRAY_TYPE] = "field designator cannot be used for an the '%.*s' array type, please use '[' instead",
		[HCC_ERROR_CODE_EXPECTED_IDENTIFIER_FIELD_DESIGNATOR] = "expected an the field identifier that you wish to initialize from '%.*s'",
		[HCC_ERROR_CODE_ARRAY_DESIGNATOR_ON_COMPOUND_TYPE] = "array designator cannot be used for an the '%.*s' compound type, please use '.' instead",
		[HCC_ERROR_CODE_EXPECTED_INTEGER_FOR_ARRAY_IDX] = "expected a constant unsigned integer here to index a value from the '%.*s' array type",
		[HCC_ERROR_CODE_ARRAY_INDEX_OUT_OF_BOUNDS] = "index is out of bounds for this array, expected a value between '0' - '%zu'",
		[HCC_ERROR_CODE_ARRAY_DESIGNATOR_EXPECTED_SQUARE_BRACE_CLOSE] = "expected ']' to finish the array designator",
		[HCC_ERROR_CODE_EXPECTED_ASSIGN_OR_ARRAY_DESIGNATOR] = "expected an '=' to assign a value or a '[' for an array designator",
		[HCC_ERROR_CODE_EXPECTED_ASSIGN_OR_FIELD_DESIGNATOR] = "expected an '=' to assign a value or a '.' for an field designator",
		[HCC_ERROR_CODE_EXPECTED_ASSIGN] = "expected an '=' to assign a '%.*s' value",
		[HCC_ERROR_CODE_UNARY_OPERATOR_NOT_SUPPORTED] = "unary operator '%s' is not supported for the '%.*s' data type",
		[HCC_ERROR_CODE_UNDECLARED_IDENTIFIER] = "undeclared identifier '%.*s'",
		[HCC_ERROR_CODE_EXPECTED_PARENTHESIS_CLOSE_EXPR] = "expected a ')' here to finish the expression",
		[HCC_ERROR_CODE_INVALID_CAST] = "cannot cast '%.*s' to '%.*s'",
		[HCC_ERROR_CODE_INVALID_CURLY_INITIALIZER_LIST_END] = "expected a '}' to finish the initializer list or a ',' to declare another initializer",
		[HCC_ERROR_CODE_SIZEALIGNOF_TYPE_OPERAND_NOT_WRAPPED] = "the type after '%s' be wrapped in parenthesis. eg. sizeof(uint32_t)",
		[HCC_ERROR_CODE_EXPECTED_EXPR] = "expected an expression here but got '%s'",
		[HCC_ERROR_CODE_NOT_ENOUGH_FUNCTION_ARGS] = "not enough arguments, expected '%u' but got '%u' for '%.*s'",
		[HCC_ERROR_CODE_TOO_MANY_FUNCTION_ARGS] = "too many arguments, expected '%u' but got '%u' for '%.*s'",
		[HCC_ERROR_CODE_INVALID_FUNCTION_ARG_DELIMITER] = "expected a ',' to declaring more function arguments or a ')' to finish declaring function arguments",
		[HCC_ERROR_CODE_ARRAY_SUBSCRIPT_EXPECTED_SQUARE_BRACE_CLOSE] = "expected ']' to finish the array subscript",
		[HCC_ERROR_CODE_EXPECTED_IDENTIFIER_FIELD_ACCESS] = "expected an identifier for the field you wish to access from '%.*s'",
		[HCC_ERROR_CODE_MISSING_COLON_TERNARY_OP] = "expected a ':' for the false side of the ternary operator",
		[HCC_ERROR_CODE_PARENTHISES_USED_ON_NON_FUNCTION] = "unexpected '(', this can only be used when the left expression is a function or pointer to a function",
		[HCC_ERROR_CODE_SQUARE_BRACE_USED_ON_NON_ARRAY_DATA_TYPE] = "unexpected '[', this can only be used when the left expression is an array or pointer but got '%.*s'",
		[HCC_ERROR_CODE_FULL_STOP_USED_ON_NON_COMPOUND_DATA_TYPE] = "unexpected '.', this can only be used when the left expression is a struct or union type but got '%.*s'",
		[HCC_ERROR_CODE_CANNOT_ASSIGN_TO_CONST] = "cannot assign to a target that has a constant data type of '%.*s'",
		[HCC_ERROR_CODE_EXPECTED_PARENTHESIS_OPEN_CONDITION_EXPR] = "expected a '(' for the condition expression",
		[HCC_ERROR_CODE_EXPECTED_PARENTHESIS_CLOSE_CONDITION_EXPR] = "expected a ')' to finish the condition expression",
		[HCC_ERROR_CODE_EXPECTED_ARRAY_SIZE] = "expected an array size here",
		[HCC_ERROR_CODE_EXPECTED_INTEGER_CONSTANT_ARRAY_SIZE] = "expected the expression to resolve to an integer constant for the array size here",
		[HCC_ERROR_CODE_ARRAY_SIZE_CANNOT_BE_NEGATIVE] = "the array size cannot be negative",
		[HCC_ERROR_CODE_ARRAY_SIZE_CANNOT_BE_ZERO] = "the array size cannot be zero",
		[HCC_ERROR_CODE_ARRAY_DECL_EXPECTED_SQUARE_BRACE_CLOSE] = "expected a ']' after the array size expression",
		[HCC_ERROR_CODE_UNSUPPORTED_SPECIFIER] = "'%s' is currently unsupported",
		[HCC_ERROR_CODE_SPECIFIER_ALREADY_BEEN_USED] = "'%s' has already been used for this declaration",
		[HCC_ERROR_CODE_UNUSED_SPECIFIER] = "the '%s' keyword was used, so we are expecting %s for a declaration but got '%s'",
		[HCC_ERROR_CODE_UNSUPPORTED_INTRINSIC_TYPE_USED] = "unsupported intrinsic type '%.*s' has been used. if you wish to use this type, please turn on extension support for the follow types: %.*s",
		[HCC_ERROR_CODE_INVALID_SPECIFIER_VARIABLE_DECL] = "the '%s' keyword cannot be used on variable declarations",
		[HCC_ERROR_CODE_INVALID_SPECIFIER_FUNCTION_DECL] = "the '%s' keyword cannot be used on function declarations",
		[HCC_ERROR_CODE_REDEFINITION_IDENTIFIER_LOCAL] = "redefinition of '%.*s' local variable identifier",
		[HCC_ERROR_CODE_STATIC_VARIABLE_INITIALIZER_MUST_BE_CONSTANT] = "variable declaration is static, so this initializer expression must be a constant",
		[HCC_ERROR_CODE_INVALID_VARIABLE_DECL_TERMINATOR] = "expected a ';' to end the declaration or a '=' to assign to the new variable",
		[HCC_ERROR_CODE_INVALID_ELSE] = "expected either 'if' or '{' to follow the 'else' keyword",
		[HCC_ERROR_CODE_INVALID_SWITCH_CONDITION_TYPE] = "switch condition expression must be convertable to a integer type but got '%.*s'",
		[HCC_ERROR_CODE_EXPECTED_CURLY_OPEN_SWITCH_STATEMENT] = "expected a '{' to begin the switch statement",
		[HCC_ERROR_CODE_EXPECTED_WHILE_CONDITION_FOR_DO_WHILE] = "expected 'while' to define the condition of the do while loop",
		[HCC_ERROR_CODE_EXPECTED_PARENTHESIS_OPEN_FOR] = "expected a '(' to follow 'for' for the operands",
		[HCC_ERROR_CODE_EXPECTED_IDENTIFIER_FOR_VARIABLE_DECL] = "expected an identifier for a variable declaration",
		[HCC_ERROR_CODE_EXPECTED_PARENTHESIS_CLOSE_FOR] = "expected a ')' to finish the for statement condition",
		[HCC_ERROR_CODE_CASE_STATEMENT_OUTSIDE_OF_SWITCH] = "case statement must be inside a switch statement",
		[HCC_ERROR_CODE_SWITCH_CASE_VALUE_MUST_BE_A_CONSTANT] = "the value of a switch case statement must be a constant",
		[HCC_ERROR_CODE_EXPECTED_COLON_SWITCH_CASE] = "':' must follow the constant of the case statement",
		[HCC_ERROR_CODE_DEFAULT_STATMENT_OUTSIDE_OF_SWITCH] = "default case statement must be inside a switch statement",
		[HCC_ERROR_CODE_DEFAULT_STATEMENT_ALREADY_DECLARED] = "default case statement has already been declared",
		[HCC_ERROR_CODE_EXPECTED_COLON_SWITCH_DEFAULT] = "':' must follow the default keyword",
		[HCC_ERROR_CODE_INVALID_BREAK_STATEMENT_USAGE] = "'break' can only be used within a switch statement, a for loop or a while loop",
		[HCC_ERROR_CODE_INVALID_CONTINUE_STATEMENT_USAGE] = "'continue' can only be used within a switch statement, a for loop or a while loop",
		[HCC_ERROR_CODE_MULTIPLE_SHADER_STAGES_ON_FUNCTION] = "only a single shader stage can be specified in a function declaration",
		[HCC_ERROR_CODE_VERTEX_SHADER_MUST_RETURN_RASTERIZER_STATE] = "vertex shader must return a type that was declare with HCC_DEFINE_RASTERIZER_STATE",
		[HCC_ERROR_CODE_FRAGMENT_SHADER_MUST_RETURN_FRAGMENT_STATE] = "fragment shader must return a type that was declare with HCC_DEFINE_FRAGMENT_STATE",
		[HCC_ERROR_CODE_EXPECTED_IDENTIFIER_FUNCTION_PARAM] = "expected an identifier for a function parameter e.g. uint32_t param_identifier",
		[HCC_ERROR_CODE_REDEFINITION_IDENTIFIER_FUNCTION_PARAM] = "redefinition of '%.*s' function parameter identifier",
		[HCC_ERROR_CODE_FUNCTION_SHADER_PROTOTYPE_VERTEX_INVALID_COUNT] = "invalid number of paramters, expected vertex function prototype to be 'RasterizerState vertex(HccVertexInput input, Resources resources)'",
		[HCC_ERROR_CODE_FUNCTION_SHADER_PROTOTYPE_VERTEX_INVALID_INPUT] = "the first parameter of a vertex shader must be a 'const HccVertexInput'",
		[HCC_ERROR_CODE_FUNCTION_SHADER_PROTOTYPE_FRAGMENT_INVALID_COUNT] = "invalid number of paramters, expected fragment function prototype to be 'Fragment fragment(HccFragmentInput input, Resources resources, RasterizerState state)'",
		[HCC_ERROR_CODE_FUNCTION_SHADER_PROTOTYPE_FRAGMENT_INVALID_INPUT] = "the first parameter of a fragment shader must be a 'const HccFragmentInput'",
		[HCC_ERROR_CODE_FUNCTION_SHADER_PROTOTYPE_FRAGMENT_INVALID_RASTERIZER_STATE] = "the third parameter of a fragment shader must be declare with HCC_DEFINE_RASTERIZER_STATE",
		[HCC_ERROR_CODE_INTRINSIC_INVALID_FUNCTION_RETURN_DATA_TYPE] = "expected intrinsic function '%.*s' to have '%.*s' as the return data type but got '%.*s'",
		[HCC_ERROR_CODE_INTRINSIC_INVALID_FUNCTION_PARAMS_COUNT] = "expected intrinsic function '%.*s' to have '%u' parameters but got '%u'",
		[HCC_ERROR_CODE_INTRINSIC_INVALID_FUNCTION_PARAM_DATA_TYPE] = "expected intrinsic function '%.*s' parameter '%u' to have '%.*s' as the data type but got '%.*s'",
		[HCC_ERROR_CODE_FUNCTION_INVALID_TERMINATOR] = "expected a ',' to declaring more function parameters or a ')' to finish declaring function parameters",
		[HCC_ERROR_CODE_EXPECTED_SHADER_PARAM_TO_BE_CONST] = "all shader parameters must be defined with 'const'. eg. 'const %.*s %.*s'",
		[HCC_ERROR_CODE_CANNOT_CALL_SHADER_FUNCTION] = "cannot call shaders like regular functions. they can only be used as entry points",
		[HCC_ERROR_CODE_CANNOT_CALL_UNIMPLEMENTED_FUNCTION] = "cannot call a function with no implemention",
		[HCC_ERROR_CODE_REDEFINITION_OF_FUNCTION_MISMATCH_PARAM_DATA_TYPE] = "redefinition of function '%.*s' data type mismatch for parameter '%.*s', expected '%.*s' but got '%.*s'",
		[HCC_ERROR_CODE_REDEFINITION_OF_FUNCTION_TOO_MANY_PARAMETERS] = "redefinition of function '%.*s' has too many parameters, expected '%u' but got more defined",
		[HCC_ERROR_CODE_REDEFINITION_OF_FUNCTION_NOT_ENOUGH_PARAMETERS] = "redefinition of function '%.*s' has not enough parameters, expected '%u' but got '%u'",
		[HCC_ERROR_CODE_REDEFINITION_OF_FUNCTION_BODY_ALREADY_DECLARED] = "redefinition of function '%.*s', body has already been declared",
		[HCC_ERROR_CODE_FUNCTION_RECURSION] = "function '%.*s' is recursively called! callstack:\n%s",
		[HCC_ERROR_CODE_UNEXPECTED_TOKEN_FUNCTION_PROTOTYPE_END] = "unexpected token '%s', expected ';' to end the function definition or '{' to define a function body",
		[HCC_ERROR_CODE_UNEXPECTED_TOKEN] = "unexpected token '%s'",
		[HCC_ERROR_CODE_INVALID_DATA_TYPE_RASTERIZER_STATE] = "'%.*s' data type is not supported as a RasterizerState field. data type must be an intrinsic type (scalar, vector or matrix)",
		[HCC_ERROR_CODE_INVALID_DATA_TYPE_FRAGMENT_STATE] = "'%.*s' data type is not supported as a FragmentState field. data type must be an intrinsic type (scalar, vector or matrix)",
		[HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_COMPOUND_DATA_TYPE] = "'%.*s' data type is not supported as a CompoundDataType field. data type cannot be HCC_DEFINE_RASTERIZER_STATE, HCC_DEFINE_FRAGMENT_STATE, HCC_DEFINE_BUFFER_ELEMENT or HCC_DEFINE_RESOURCE_SET",
		[HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_BUFFER_ELEMENT] = "'%.*s' data type is not supported as a buffer element field. data type cannot be a resource, a pointer type, HCC_DEFINE_RASTERIZER_STATE, HCC_DEFINE_FRAGMENT_STATE, HCC_DEFINE_BUFFER_ELEMENT, HCC_DEFINE_RESOURCE_SET, HCC_DEFINE_RESOURCE_TABLE or HCC_DEFINE_RESOURCES",
		[HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_RESOURCE_SET] = "'%.*s' data type is not supported as a ResourceSet field. data type must be a resource",
		[HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_RESOURCE_TABLE] = "'%.*s' data type is not supported as a ResourceTable field. data type cannot be a ResourceSet pointer, a compound data type with resources, HCC_DEFINE_RASTERIZER_STATE, HCC_DEFINE_FRAGMENT_STATE, HCC_DEFINE_BUFFER_ELEMENT, HCC_DEFINE_RESOURCE_SET, HCC_DEFINE_RESOURCE_TABLE or HCC_DEFINE_RESOURCES",
		[HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_RESOURCES_BINDING] = "'%.*s' data type is not supported as a Resources field. data type cannot be a ResourceTable pointer, HCC_DEFINE_RASTERIZER_STATE, HCC_DEFINE_FRAGMENT_STATE, HCC_DEFINE_BUFFER_ELEMENT, HCC_DEFINE_RESOURCE_SET, HCC_DEFINE_RESOURCE_TABLE or HCC_DEFINE_RESOURCES",
		[HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_RESOURCES_BINDING_AND_BINDLESS] = "'%.*s' data type is not supported as a Resources field. data type cannot a be ConstBuffer, HCC_DEFINE_RASTERIZER_STATE, HCC_DEFINE_FRAGMENT_STATE, HCC_DEFINE_BUFFER_ELEMENT, HCC_DEFINE_RESOURCE_SET, HCC_DEFINE_RESOURCE_TABLE or HCC_DEFINE_RESOURCES",
		[HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_FUNCTION_PARAM] = "'%.*s' data type is not supported as a function parameter. data type cannot be a HCC_DEFINE_RASTERIZER_STATE, HCC_DEFINE_FRAGMENT_STATE, HCC_DEFINE_BUFFER_ELEMENT or HCC_DEFINE_RESOURCE_SET",
		[HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_FUNCTION_PARAM_INLINE] = "the function must be 'inline' if you want to use the '%.*s' data type as a function parameter. resources and array data types are only supported with the 'inline' function specifier",
		[HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_VARIABLE] = "'%.*s' data type is not supported as a function parameter. data type cannot be a HCC_DEFINE_RASTERIZER_STATE, HCC_DEFINE_FRAGMENT_STATE, HCC_DEFINE_BUFFER_ELEMENT or HCC_DEFINE_RESOURCE_SET",
		[HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_POINTER_DATA_TYPE] = "'%.*s' data type is not supported as a pointer data type. data type cannot be a HCC_DEFINE_RASTERIZER_STATE, HCC_DEFINE_FRAGMENT_STATE or HCC_DEFINE_RESOURCES",
		[HCC_ERROR_CODE_ONLY_SINGLE_POINTERS_ARE_SUPPORTED] = "only a single pointer is supported",
		[HCC_ERROR_CODE_POINTER_TO_RESOURCE_SET_TABLE_MUST_BE_CONST] = "pointers to ResourceSet's and ResourceTable's must be 'const'",
		[HCC_ERROR_CODE_LOGICAL_ADDRESSED_VAR_USED_BEFORE_ASSIGNED] = "texture, buffer or pointer has been used before it has been assigned too",
		[HCC_ERROR_CODE_LOGICAL_ADDRESSED_CONDITIONALLY_ASSIGNED_BEFORE_USE] = "texture, buffer or pointer has been conditionally assigned too before being used. we need to know these value of this variable at compile time.",
		[HCC_ERROR_CODE_NON_CONST_STATIC_VARIABLE_CANNOT_BE_LOGICALLY_ADDRESSED] = "non-const static variable cannot be a texture, buffer or pointer",
	},
};

const char* hcc_warn_code_lang_fmt_strings[HCC_LANG_COUNT][HCC_WARN_CODE_COUNT] = {
	[HCC_LANG_ENG] = {
		[HCC_WARN_CODE_PP_WARNING] = "#warning '%.*s'",

		//
		// astgen
		[HCC_WARN_CODE_CURLY_INITIALIZER_ON_SCALAR] = "'{' should ideally be for structure or array types but got '%.*s'",
		[HCC_WARN_CODE_UNUSED_INITIALIZER_REACHED_END] = "unused initializer, we have reached the end of members for the '%.*s' type",
		[HCC_WARN_CODE_NO_DESIGNATOR_AFTER_DESIGNATOR] = "you should ideally continue using field/array designators after they have been used",
	}
};

void hcc_location_merge_apply(HccLocation* before, HccLocation* after) {
	before->code_end_idx = after->code_end_idx;
	if (before->line_start != after->line_start) {
		before->column_start = after->column_start;
	}
	before->column_end = after->column_end;
	before->line_start = after->line_start;
	before->line_end = after->line_end;
}

void hcc_message_print_file_line(HccCompiler* c, HccLocation* location) {
	const char* file_path = location->display_path.data ? location->display_path.data : location->code_file->path_string.data;
	U32 display_line = location->display_line ? location->display_line : location->line_start;

	const char* error_fmt = hcc_options_is_enabled(c, HCC_OPTION_PRINT_COLOR)
		? "\x1b[1;95mfile\x1b[97m: %s:%u:%u\n\x1b[0m"
		: "file: %s:%u:%u\n";
	printf(error_fmt, file_path, display_line, location->column_start);
}

void hcc_message_print_pasted_buffer(HccCompiler* c, U32 line, U32 column) {
	const char* error_fmt = hcc_options_is_enabled(c, HCC_OPTION_PRINT_COLOR)
		? "\x1b[1;95m<pasted buffer>\x1b[97m: %u:%u\n\x1b[0m"
		: "<pasted buffer>: %u:%u\n";
	printf(error_fmt, line, column);
}

void hcc_message_print_code_line(HccCompiler* c, HccLocation* location, U32 display_line_num_size, U32 line, U32 display_line) {
	U32 line_size = hcc_code_file_line_size(location->code_file, line);

	if (line_size == 0) {
		const char* fmt = hcc_options_is_enabled(c, HCC_OPTION_PRINT_COLOR)
			? "\x1b[1;94m%*u|\x1b[0m\n"
			: "%*u|\n";
		printf(fmt, display_line_num_size, display_line);
	} else {
		HccCodeFile* code_file = location->code_file;
		U32 code_start_idx = code_file->line_code_start_indices[line];
		char* code = &code_file->code.data[code_start_idx];

		char code_without_tabs[1024];
		U32 dst_idx = 0;
		U32 src_idx = 0;
		for (; dst_idx < HCC_MIN(sizeof(code_without_tabs), line_size); dst_idx += 1, src_idx += 1) {
			char byte = code[src_idx];
			if (byte == '\t') {
				HCC_DEBUG_ASSERT_ARRAY_BOUNDS(dst_idx + 3, sizeof(code_without_tabs));
				//
				// TODO make this a customizable compiler option in HccOption
				code_without_tabs[dst_idx + 0] = ' ';
				code_without_tabs[dst_idx + 1] = ' ';
				code_without_tabs[dst_idx + 2] = ' ';
				code_without_tabs[dst_idx + 3] = ' ';
				dst_idx += 3;
				line_size += 3;
			} else {
				HCC_DEBUG_ASSERT_ARRAY_BOUNDS(dst_idx, sizeof(code_without_tabs));
				code_without_tabs[dst_idx] = byte;
			}
		}

		const char* fmt = hcc_options_is_enabled(c, HCC_OPTION_PRINT_COLOR)
			? "\x1b[1;94m%*u|\x1b[0m %.*s\n"
			: "%*u| %.*s\n";
		printf(fmt, display_line_num_size, display_line, line_size, code_without_tabs);
	}
}

void hcc_message_print_code(HccCompiler* c, HccLocation* location) {
	if (location->parent_location) {
		HccLocation* parent_location = location->parent_location;
		hcc_message_print_code(c, parent_location);
		printf("\n");

		HccPPMacro* macro = location->macro;
		if (macro) {
			HccString ident_string = hcc_string_table_get(&c->string_table, macro->identifier_string_id);

			const char* error_fmt = hcc_options_is_enabled(c, HCC_OPTION_PRINT_COLOR)
				? "\x1b[1;96mexpanded from macro\x1b[97m: %.*s\n\x1b[0m"
				: "expanded from macro: %.*s\n";
			printf(error_fmt, (int)ident_string.size, ident_string.data);
		}
	}
	hcc_message_print_file_line(c, location);

	U32 error_lines_count = location->line_end - location->line_start;

	//
	// count the number of digits in the largest line number
	U32 display_line_num_size = 0;
	U32 line = location->line_end + 2;
	while (line) {
		if (line < 10) {
			line = 0;
		} else {
			line /= 10;
		}
		display_line_num_size += 1;
	}

	//
	// TODO make this a customizable compiler option in HccOption
	U32 tab_size = 4;

	display_line_num_size = HCC_MAX(display_line_num_size, 5);
	display_line_num_size = HCC_INT_ROUND_UP_ALIGN(display_line_num_size, tab_size) - 2;

	line = location->line_start;
	U32 display_line = location->display_line ? location->display_line : location->line_start;
	if (line > 2) {
		hcc_message_print_code_line(c, location, display_line_num_size, line - 2, display_line - 2);
	}
	if (line > 1) {
		hcc_message_print_code_line(c, location, display_line_num_size, line - 1, display_line - 1);
	}

	U32 column_start = location->column_start;
	U32 column_end;
	HccCodeFile* code_file = location->code_file;
	for (U32 idx = 0; idx < error_lines_count; idx += 1) {
		U32 code_start_idx = code_file->line_code_start_indices[line + idx];
		if (idx + 1 == error_lines_count) {
			column_end = location->column_end;
		} else {
			column_end = hcc_code_file_line_size(code_file, line + idx) + 1;
		}

		hcc_message_print_code_line(c, location, display_line_num_size, line + idx, display_line + idx);

		//
		// print the padding for to get to the error location on the line
		for (U32 i = 0; i < display_line_num_size + 2; i += 1) {
			putchar(' ');
		}
		for (U32 i = 0; i < HCC_MAX(column_start, 1) - 1; i += 1) {
			if (code_file->code.data[code_start_idx + i] == '\t') {
				printf("%.*s", tab_size, "        ");
			} else {
				putchar(' ');
			}
		}

		U32 column_end_with_tabs = column_end;
		for (U32 i = column_start - 1; i < column_end - 1; i += 1) {
			if (code_file->code.data[code_start_idx + i] == '\t') {
				column_end_with_tabs += 3;
			}
		}
		column_end_with_tabs = HCC_MAX(column_end_with_tabs, column_start + 1);

		if (hcc_options_is_enabled(c, HCC_OPTION_PRINT_COLOR)) {
			printf("\x1b[1;93m");
		}
		for (U32 i = 0; i < column_end_with_tabs - column_start; i += 1) {
			putchar('^');
		}
		if (hcc_options_is_enabled(c, HCC_OPTION_PRINT_COLOR)) {
			printf("\x1b[0m");
		}
		printf("\n");
		column_start = 1;
	}

	line = location->line_end - 1;
	U32 lines_count = hcc_code_file_lines_count(code_file);
	if (line + 1 < lines_count) {
		hcc_message_print_code_line(c, location, display_line_num_size, line + 1, display_line + 1);
	}
	if (line + 2 < lines_count) {
		hcc_message_print_code_line(c, location, display_line_num_size, line + 2, display_line + 2);
	}
}

void hcc_message_print(HccCompiler* c, HccMessage* message) {
	HccLang lang = HCC_LANG_ENG;
	const char* message_type = hcc_message_type_lang_strings[lang][message->type];
	const char* message_color = hcc_options_is_enabled(c, HCC_OPTION_PRINT_COLOR)
		? hcc_message_type_ascii_color_code[message->type]
		: "";
	const char* error_fmt = hcc_options_is_enabled(c, HCC_OPTION_PRINT_COLOR)
		? "%s%s\x1b[0m: \x1b[1;97m%.*s\x1b[0m\n"
		: "%s%s: %.*s\n";
	printf(error_fmt, message_color, message_type, (int)message->string.size, message->string.data);

	hcc_message_print_code(c, message->location);

	if (message->other_location) {
		const char* error_fmt = hcc_options_is_enabled(c, HCC_OPTION_PRINT_COLOR)
			? "\x1b[1;97m\noriginally defined here\x1b[0m: \n"
			: "\noriginally defined here: ";
		printf("%s", error_fmt);

		hcc_message_print_code(c, message->other_location);
	}

	printf("\n");
}

void hcc_message_pushv(HccCompiler* c, HccMessageType type, HccMessageCode code, HccLocation* location, HccLocation* other_location, va_list va_args) {
	HccMessageSys* sys = &c->message_sys;

	HccMessage* m;
	if (c->message_sys.next_is_deferred) {
		m = hcc_stack_push(sys->deferred_elmts);
		c->message_sys.next_is_deferred = false;
	} else {
		m = hcc_stack_push(sys->elmts);
		sys->used_type_flags |= type;
	}
	m->type = type;
	m->code = code;
	m->location = hcc_stack_push(sys->locations);
	*m->location = *location;
	if (other_location) {
		m->other_location = hcc_stack_push(sys->locations);
		*m->other_location = *other_location;
	} else {
		m->other_location = NULL;
	}

	HccLang lang = HCC_LANG_ENG;
	const char* fmt = NULL;
	switch (type) {
		case HCC_MESSAGE_TYPE_ERROR: fmt = hcc_error_code_lang_fmt_strings[lang][code]; break;
		case HCC_MESSAGE_TYPE_WARN: fmt = hcc_warn_code_lang_fmt_strings[lang][code]; break;
	}

	va_list va_args_copy;
	va_copy(va_args_copy, va_args);

	//
	// add 1 so we have enough room for the null terminator that vsnprintf always outputs
	// vsnprintf will return -1 on an encoding error.
	Uptr count = vsnprintf(NULL, 0, fmt, va_args_copy) + 1;
	va_end(va_args_copy);
	HCC_DEBUG_ASSERT(count >= 1, "a vsnprintf encoding error has occurred");

	//
	// resize the stack to have enough room to store the pushed formatted string with the null terminator
	HccString string = hcc_string(hcc_stack_push_many(sys->strings, count), count);

	//
	// now call vsnprintf for real this time, with a buffer
	// to actually copy the formatted string.
	string.size = vsnprintf(string.data, string.size, fmt, va_args);
	m->string = string;
}

void hcc_message_push(HccCompiler* c, HccMessageType type, HccMessageCode code, HccLocation* location, HccLocation* other_location, ...) {
	va_list va_args;
	va_start(va_args, other_location);
	hcc_message_pushv(c, type, code, location, other_location, va_args);
	va_end(va_args);
}

void hcc_error_pushv(HccCompiler* c, HccErrorCode error_code, HccLocation* location, HccLocation* other_location, va_list va_args) {
	hcc_message_pushv(c, HCC_MESSAGE_TYPE_ERROR, error_code, location, other_location, va_args);
}

void hcc_error_push(HccCompiler* c, HccErrorCode error_code, HccLocation* location, HccLocation* other_location, ...) {
	va_list va_args;
	va_start(va_args, other_location);
	hcc_message_pushv(c, HCC_MESSAGE_TYPE_ERROR, error_code, location, other_location, va_args);
	va_end(va_args);
}

void hcc_warn_pushv(HccCompiler* c, HccWarnCode warn_code, HccLocation* location, HccLocation* other_location, va_list va_args) {
	hcc_message_pushv(c, HCC_MESSAGE_TYPE_WARN, warn_code, location, other_location, va_args);
}

void hcc_warn_push(HccCompiler* c, HccWarnCode warn_code, HccLocation* location, HccLocation* other_location, ...) {
	va_list va_args;
	va_start(va_args, other_location);
	hcc_message_pushv(c, HCC_MESSAGE_TYPE_WARN, warn_code, location, other_location, va_args);
	va_end(va_args);
}

void hcc_message_copy_deferred(HccCompiler* c, U32 start_idx, U32 count) {
	HccMessage* deferred_messages = hcc_stack_get(c->message_sys.deferred_elmts, start_idx);
	HccMessage* dst = hcc_stack_push_many(c->message_sys.elmts, count);
	HCC_COPY_ELMT_MANY(dst, deferred_messages, count);
	c->message_sys.used_type_flags |= HCC_MESSAGE_TYPE_ERROR;
}

// ===========================================
//
//
// Code File
//
//
// ===========================================

HccCodeFile* hcc_code_file_init(HccCompiler* c, HccStringId path_string_id) {
	HccCodeFile* code_file = hcc_stack_push(c->code_files);
	code_file->path_string_id = path_string_id;
	code_file->path_string = hcc_string_table_get(&c->string_table, path_string_id);
	code_file->line_code_start_indices = hcc_stack_init(U32, c->code_file_lines_cap, HCC_ALLOC_TAG_CODE_FILE_LINE_CODE_START_INDICES);
	code_file->pp_if_spans = hcc_stack_init(HccPPIfSpan, c->code_file_pp_if_spans_cap, HCC_ALLOC_TAG_CODE_FILE_PP_IF_SPANS);
	hcc_stack_push_many(code_file->line_code_start_indices, 2);
	return code_file;
}

bool hcc_code_file_find_or_insert(HccCompiler* c, HccString path_string, HccCodeFileId* code_file_id_out, HccCodeFile** code_file_out) {
	char* path_string_c = hcc_path_canonicalize(path_string.data);
	path_string = hcc_string_c(path_string_c);
	path_string.size += 1; // include the null terminator in the string
	HccStringId path_string_id = hcc_string_table_deduplicate(&c->string_table, path_string.data, path_string.size);

	U32* code_file_idx;
	if (hcc_hash_table_find_or_insert(&c->path_to_code_file_id_map, path_string_id.idx_plus_one, &code_file_idx)) {
		*code_file_id_out = ((HccCodeFileId) { .idx_plus_one = *code_file_idx + 1 });
		*code_file_out = hcc_stack_get(c->code_files, *code_file_idx);
		return true;
	}
	*code_file_idx = hcc_stack_count(c->code_files);

	*code_file_out = hcc_code_file_init(c, path_string_id);
	*code_file_id_out = ((HccCodeFileId) { .idx_plus_one = *code_file_idx + 1 });
	return false;
}

U32 hcc_code_file_line_size(HccCodeFile* code_file, U32 line) {
	U32 code_start_idx = *hcc_stack_get(code_file->line_code_start_indices, line);
	U32 code_end_idx;
	if (line >= hcc_code_file_lines_count(code_file)) {
		code_end_idx = code_file->code.size;
	} else {
		code_end_idx = *hcc_stack_get(code_file->line_code_start_indices, line + 1);

		//
		// move back until we reach the final character on a non empty line
		while (code_end_idx) {
			code_end_idx -= 1;
			U8 byte = code_file->code.data[code_end_idx];
			if (byte != '\r' && byte != '\n') {
				code_end_idx += 1;
				break;
			}
		}
	}

	if (code_start_idx < code_end_idx) {
		return code_end_idx - code_start_idx;
	} else {
		return 0;
	}
}

U32 hcc_code_file_lines_count(HccCodeFile* code_file) {
	return hcc_stack_count(code_file->line_code_start_indices) - 1;
}

// ===========================================
//
//
// Declarations
//
//
// ===========================================

bool hcc_resource_type_has_generic_type[HCC_RESOURCE_TYPE_COUNT] = {
	[HCC_RESOURCE_TYPE_CONSTBUFFER] = true,
	[HCC_RESOURCE_TYPE_ROELEMENTBUFFER] = true,
	[HCC_RESOURCE_TYPE_RWELEMENTBUFFER] = true,
	[HCC_RESOURCE_TYPE_ROTEXELBUFFER] = true,
	[HCC_RESOURCE_TYPE_RWTEXELBUFFER] = true,
	[HCC_RESOURCE_TYPE_ROTEXTURE1D] = true,
	[HCC_RESOURCE_TYPE_RWTEXTURE1D] = true,
	[HCC_RESOURCE_TYPE_ROTEXTURE1DARRAY] = true,
	[HCC_RESOURCE_TYPE_RWTEXTURE1DARRAY] = true,
	[HCC_RESOURCE_TYPE_ROTEXTURE2D] = true,
	[HCC_RESOURCE_TYPE_RWTEXTURE2D] = true,
	[HCC_RESOURCE_TYPE_ROTEXTURE2DARRAY] = true,
	[HCC_RESOURCE_TYPE_RWTEXTURE2DARRAY] = true,
	[HCC_RESOURCE_TYPE_ROTEXTURE2DMS] = true,
	[HCC_RESOURCE_TYPE_RWTEXTURE2DMS] = true,
	[HCC_RESOURCE_TYPE_ROTEXTURE2DMSARRAY] = true,
	[HCC_RESOURCE_TYPE_RWTEXTURE2DMSARRAY] = true,
	[HCC_RESOURCE_TYPE_ROTEXTURE3D] = true,
	[HCC_RESOURCE_TYPE_RWTEXTURE3D] = true,
};

const char* hcc_resource_type_strings[HCC_RESOURCE_TYPE_COUNT] = {
	[HCC_RESOURCE_TYPE_CONSTBUFFER] = "ConstBuffer",
	[HCC_RESOURCE_TYPE_ROELEMENTBUFFER] = "ROElementBuffer",
	[HCC_RESOURCE_TYPE_RWELEMENTBUFFER] = "RWElementBuffer",
	[HCC_RESOURCE_TYPE_ROBYTEBUFFER] = "ROByteBuffer",
	[HCC_RESOURCE_TYPE_RWBYTEBUFFER] = "RWByteBuffer",
	[HCC_RESOURCE_TYPE_ROTEXELBUFFER] = "ROTexelBuffer",
	[HCC_RESOURCE_TYPE_RWTEXELBUFFER] = "RWTexelBuffer",
	[HCC_RESOURCE_TYPE_ROTEXTURE1D] = "ROTexture1D",
	[HCC_RESOURCE_TYPE_RWTEXTURE1D] = "RWTexture1D",
	[HCC_RESOURCE_TYPE_ROTEXTURE1DARRAY] = "ROTexture1DArray",
	[HCC_RESOURCE_TYPE_RWTEXTURE1DARRAY] = "RWTexture1DArray",
	[HCC_RESOURCE_TYPE_ROTEXTURE2D] = "ROTexture2D",
	[HCC_RESOURCE_TYPE_RWTEXTURE2D] = "RWTexture2D",
	[HCC_RESOURCE_TYPE_ROTEXTURE2DARRAY] = "ROTexture2DArray",
	[HCC_RESOURCE_TYPE_RWTEXTURE2DARRAY] = "RWTexture2DArray",
	[HCC_RESOURCE_TYPE_ROTEXTURE2DMS] = "ROTexture2DMS",
	[HCC_RESOURCE_TYPE_RWTEXTURE2DMS] = "RWTexture2DMS",
	[HCC_RESOURCE_TYPE_ROTEXTURE2DMSARRAY] = "ROTexture2DMSArray",
	[HCC_RESOURCE_TYPE_RWTEXTURE2DMSARRAY] = "RWTexture2DMSArray",
	[HCC_RESOURCE_TYPE_ROTEXTURE3D] = "ROTexture3D",
	[HCC_RESOURCE_TYPE_RWTEXTURE3D] = "RWTexture3D",
	[HCC_RESOURCE_TYPE_SAMPLER_STATE] = "SamplerState",
};

U8 hcc_basic_type_size_and_aligns_x86_64_linux[HCC_DATA_TYPE_BASIC_COUNT] = {
	[HCC_DATA_TYPE_BOOL] = 1,
	[HCC_DATA_TYPE_CHAR] = 1,
	[HCC_DATA_TYPE_SCHAR] = 1,
	[HCC_DATA_TYPE_UCHAR] = 1,
	[HCC_DATA_TYPE_SSHORT] = 2,
	[HCC_DATA_TYPE_USHORT] = 2,
	[HCC_DATA_TYPE_SINT] = 4,
	[HCC_DATA_TYPE_UINT] = 4,
	[HCC_DATA_TYPE_SLONG] = 8,
	[HCC_DATA_TYPE_ULONG] = 8,
	[HCC_DATA_TYPE_SLONGLONG] = 8,
	[HCC_DATA_TYPE_ULONGLONG] = 8,
	[HCC_DATA_TYPE_FLOAT] = 4,
	[HCC_DATA_TYPE_DOUBLE] = 8,
};

U64 hcc_basic_type_int_mins_x86_64_linux[HCC_DATA_TYPE_BASIC_COUNT] = {
	[HCC_DATA_TYPE_CHAR] = INT8_MIN,
	[HCC_DATA_TYPE_SCHAR] = INT8_MIN,
	[HCC_DATA_TYPE_SSHORT] = INT16_MIN,
	[HCC_DATA_TYPE_SINT] = INT32_MIN,
	[HCC_DATA_TYPE_SLONG] = INT64_MIN,
	[HCC_DATA_TYPE_SLONGLONG] = INT64_MIN,
	[HCC_DATA_TYPE_UCHAR] = 0,
	[HCC_DATA_TYPE_USHORT] = 0,
	[HCC_DATA_TYPE_UINT] = 0,
	[HCC_DATA_TYPE_ULONG] = 0,
	[HCC_DATA_TYPE_ULONGLONG] = 0,
};

U64 hcc_basic_type_int_maxes_x86_64_linux[HCC_DATA_TYPE_BASIC_COUNT] = {
	[HCC_DATA_TYPE_CHAR] = INT8_MAX,
	[HCC_DATA_TYPE_SCHAR] = INT8_MAX,
	[HCC_DATA_TYPE_SSHORT] = INT16_MAX,
	[HCC_DATA_TYPE_SINT] = INT32_MAX,
	[HCC_DATA_TYPE_SLONG] = INT64_MAX,
	[HCC_DATA_TYPE_SLONGLONG] = INT64_MAX,
	[HCC_DATA_TYPE_UCHAR] = UINT8_MAX,
	[HCC_DATA_TYPE_USHORT] = UINT16_MAX,
	[HCC_DATA_TYPE_UINT] = UINT32_MAX,
	[HCC_DATA_TYPE_ULONG] = UINT64_MAX,
	[HCC_DATA_TYPE_ULONGLONG] = UINT64_MAX,
};

U8 hcc_packed_vec_sizes[HCC_VEC_COUNT] = {
	[HCC_VEC2BOOL] = 2,
	[HCC_VEC2U8] = 2,
	[HCC_VEC2U16] = 4,
	[HCC_VEC2U32] = 8,
	[HCC_VEC2U64] = 16,
	[HCC_VEC2I8] = 2,
	[HCC_VEC2I16] = 4,
	[HCC_VEC2I32] = 8,
	[HCC_VEC2I64] = 16,
	[HCC_VEC2F16] = 4,
	[HCC_VEC2F32] = 8,
	[HCC_VEC2F64] = 16,
	[HCC_VEC3BOOL] = 3,
	[HCC_VEC3U8] = 3,
	[HCC_VEC3U16] = 6,
	[HCC_VEC3U32] = 12,
	[HCC_VEC3U64] = 24,
	[HCC_VEC3I8] = 3,
	[HCC_VEC3I16] = 6,
	[HCC_VEC3I32] = 12,
	[HCC_VEC3I64] = 24,
	[HCC_VEC3F16] = 6,
	[HCC_VEC3F32] = 12,
	[HCC_VEC3F64] = 24,
	[HCC_VEC4BOOL] = 4,
	[HCC_VEC4U8] = 4,
	[HCC_VEC4U16] = 8,
	[HCC_VEC4U32] = 16,
	[HCC_VEC4U64] = 32,
	[HCC_VEC4I8] = 4,
	[HCC_VEC4I16] = 8,
	[HCC_VEC4I32] = 16,
	[HCC_VEC4I64] = 32,
	[HCC_VEC4F16] = 8,
	[HCC_VEC4F32] = 16,
	[HCC_VEC4F64] = 32,
};

U8 hcc_packed_vec_aligns[HCC_VEC_COUNT] = {
	[HCC_VEC2BOOL] = 1,
	[HCC_VEC2U8] = 1,
	[HCC_VEC2U16] = 2,
	[HCC_VEC2U32] = 4,
	[HCC_VEC2U64] = 8,
	[HCC_VEC2I8] = 1,
	[HCC_VEC2I16] = 2,
	[HCC_VEC2I32] = 4,
	[HCC_VEC2I64] = 8,
	[HCC_VEC2F16] = 2,
	[HCC_VEC2F32] = 4,
	[HCC_VEC2F64] = 8,
	[HCC_VEC3BOOL] = 1,
	[HCC_VEC3U8] = 1,
	[HCC_VEC3U16] = 2,
	[HCC_VEC3U32] = 4,
	[HCC_VEC3U64] = 8,
	[HCC_VEC3I8] = 1,
	[HCC_VEC3I16] = 2,
	[HCC_VEC3I32] = 4,
	[HCC_VEC3I64] = 8,
	[HCC_VEC3F16] = 2,
	[HCC_VEC3F32] = 4,
	[HCC_VEC3F64] = 8,
	[HCC_VEC4BOOL] = 1,
	[HCC_VEC4U8] = 1,
	[HCC_VEC4U16] = 2,
	[HCC_VEC4U32] = 4,
	[HCC_VEC4U64] = 8,
	[HCC_VEC4I8] = 1,
	[HCC_VEC4I16] = 2,
	[HCC_VEC4I32] = 4,
	[HCC_VEC4I64] = 8,
	[HCC_VEC4F16] = 2,
	[HCC_VEC4F32] = 4,
	[HCC_VEC4F64] = 8,
};

U8 hcc_vec_size_and_aligns[HCC_VEC_COUNT] = {
	[HCC_VEC2BOOL] = 2,
	[HCC_VEC2U8] = 2,
	[HCC_VEC2U16] = 4,
	[HCC_VEC2U32] = 8,
	[HCC_VEC2U64] = 16,
	[HCC_VEC2I8] = 2,
	[HCC_VEC2I16] = 4,
	[HCC_VEC2I32] = 8,
	[HCC_VEC2I64] = 16,
	[HCC_VEC2F16] = 4,
	[HCC_VEC2F32] = 8,
	[HCC_VEC2F64] = 16,
	[HCC_VEC3BOOL] = 4,
	[HCC_VEC3U8] = 4,
	[HCC_VEC3U16] = 8,
	[HCC_VEC3U32] = 16,
	[HCC_VEC3U64] = 32,
	[HCC_VEC3I8] = 4,
	[HCC_VEC3I16] = 8,
	[HCC_VEC3I32] = 16,
	[HCC_VEC3I64] = 32,
	[HCC_VEC3F16] = 8,
	[HCC_VEC3F32] = 16,
	[HCC_VEC3F64] = 32,
	[HCC_VEC4BOOL] = 4,
	[HCC_VEC4U8] = 4,
	[HCC_VEC4U16] = 8,
	[HCC_VEC4U32] = 16,
	[HCC_VEC4U64] = 32,
	[HCC_VEC4I8] = 4,
	[HCC_VEC4I16] = 8,
	[HCC_VEC4I32] = 16,
	[HCC_VEC4I64] = 32,
	[HCC_VEC4F16] = 8,
	[HCC_VEC4F32] = 16,
	[HCC_VEC4F64] = 32,
};

U8 hcc_packed_mat_sizes[HCC_MAT_COUNT] = {
	[HCC_MAT22F32] = 16,
	[HCC_MAT22F64] = 32,
	[HCC_MAT23F32] = 24,
	[HCC_MAT23F64] = 48,
	[HCC_MAT24F32] = 32,
	[HCC_MAT24F64] = 64,
	[HCC_MAT32F32] = 24,
	[HCC_MAT32F64] = 48,
	[HCC_MAT33F32] = 36,
	[HCC_MAT33F64] = 72,
	[HCC_MAT34F32] = 48,
	[HCC_MAT34F64] = 96,
	[HCC_MAT42F32] = 32,
	[HCC_MAT42F64] = 64,
	[HCC_MAT43F32] = 48,
	[HCC_MAT43F64] = 96,
	[HCC_MAT44F32] = 64,
	[HCC_MAT44F64] = 128,
};

U8 hcc_packed_mat_aligns[HCC_MAT_COUNT] = {
	[HCC_MAT22F32] = 4,
	[HCC_MAT22F64] = 8,
	[HCC_MAT23F32] = 4,
	[HCC_MAT23F64] = 8,
	[HCC_MAT24F32] = 4,
	[HCC_MAT24F64] = 8,
	[HCC_MAT32F32] = 4,
	[HCC_MAT32F64] = 8,
	[HCC_MAT33F32] = 4,
	[HCC_MAT33F64] = 8,
	[HCC_MAT34F32] = 4,
	[HCC_MAT34F64] = 8,
	[HCC_MAT42F32] = 4,
	[HCC_MAT42F64] = 8,
	[HCC_MAT43F32] = 4,
	[HCC_MAT43F64] = 8,
	[HCC_MAT44F32] = 4,
	[HCC_MAT44F64] = 8,
};

U8 hcc_mat_sizes[HCC_MAT_COUNT] = {
	[HCC_MAT22F32] = 32,
	[HCC_MAT22F64] = 64,
	[HCC_MAT23F32] = 48,
	[HCC_MAT23F64] = 96,
	[HCC_MAT24F32] = 64,
	[HCC_MAT24F64] = 128,
	[HCC_MAT32F32] = 32,
	[HCC_MAT32F64] = 64,
	[HCC_MAT33F32] = 48,
	[HCC_MAT33F64] = 96,
	[HCC_MAT34F32] = 64,
	[HCC_MAT34F64] = 128,
	[HCC_MAT42F32] = 32,
	[HCC_MAT42F64] = 64,
	[HCC_MAT43F32] = 48,
	[HCC_MAT43F64] = 96,
	[HCC_MAT44F32] = 64,
	[HCC_MAT44F64] = 128,
};

U8 hcc_mat_aligns[HCC_MAT_COUNT] = {
	[HCC_MAT22F32] = 16,
	[HCC_MAT22F64] = 32,
	[HCC_MAT23F32] = 16,
	[HCC_MAT23F64] = 32,
	[HCC_MAT24F32] = 16,
	[HCC_MAT24F64] = 32,
	[HCC_MAT32F32] = 16,
	[HCC_MAT32F64] = 32,
	[HCC_MAT33F32] = 16,
	[HCC_MAT33F64] = 32,
	[HCC_MAT34F32] = 16,
	[HCC_MAT34F64] = 32,
	[HCC_MAT42F32] = 16,
	[HCC_MAT42F64] = 32,
	[HCC_MAT43F32] = 16,
	[HCC_MAT43F64] = 32,
	[HCC_MAT44F32] = 16,
	[HCC_MAT44F64] = 32,
};

const char* hcc_intrinsic_function_strings[HCC_FUNCTION_IDX_INTRINSIC_END] = {
	//
	// libc-gpu/math.h
	//
	[HCC_FUNCTION_IDX_ISINF] = "__hcc_isinf",
	[HCC_FUNCTION_IDX_ISNAN] = "__hcc_isnan",
	[HCC_FUNCTION_IDX_FMODF] = "fmodf",
	[HCC_FUNCTION_IDX_FMOD] = "fmod",
	[HCC_FUNCTION_IDX_FABSF] = "fabsf",
	[HCC_FUNCTION_IDX_FABS] = "fabs",
	[HCC_FUNCTION_IDX_FLOORF] = "floorf",
	[HCC_FUNCTION_IDX_FLOOR] = "floor",
	[HCC_FUNCTION_IDX_CEILF] = "ceilf",
	[HCC_FUNCTION_IDX_CEIL] = "ceil",
	[HCC_FUNCTION_IDX_ROUNDF] = "roundf",
	[HCC_FUNCTION_IDX_ROUND] = "round",
	[HCC_FUNCTION_IDX_TRUNCF] = "truncf",
	[HCC_FUNCTION_IDX_TRUNC] = "trunc",
	[HCC_FUNCTION_IDX_SINF] = "sinf",
	[HCC_FUNCTION_IDX_SIN] = "sin",
	[HCC_FUNCTION_IDX_COSF] = "cosf",
	[HCC_FUNCTION_IDX_COS] = "cos",
	[HCC_FUNCTION_IDX_TANF] = "tanf",
	[HCC_FUNCTION_IDX_TAN] = "tan",
	[HCC_FUNCTION_IDX_ASINF] = "asinf",
	[HCC_FUNCTION_IDX_ASIN] = "asin",
	[HCC_FUNCTION_IDX_ACOSF] = "acosf",
	[HCC_FUNCTION_IDX_ACOS] = "acos",
	[HCC_FUNCTION_IDX_ATANF] = "atanf",
	[HCC_FUNCTION_IDX_ATAN] = "atan",
	[HCC_FUNCTION_IDX_SINHF] = "sinhf",
	[HCC_FUNCTION_IDX_SINH] = "sinh",
	[HCC_FUNCTION_IDX_COSHF] = "coshf",
	[HCC_FUNCTION_IDX_COSH] = "cosh",
	[HCC_FUNCTION_IDX_TANHF] = "tanhf",
	[HCC_FUNCTION_IDX_TANH] = "tanh",
	[HCC_FUNCTION_IDX_ASINHF] = "asinhf",
	[HCC_FUNCTION_IDX_ASINH] = "asinh",
	[HCC_FUNCTION_IDX_ACOSHF] = "acoshf",
	[HCC_FUNCTION_IDX_ACOSH] = "acosh",
	[HCC_FUNCTION_IDX_ATANHF] = "atanhf",
	[HCC_FUNCTION_IDX_ATANH] = "atanh",
	[HCC_FUNCTION_IDX_ATAN2F] = "atan2f",
	[HCC_FUNCTION_IDX_ATAN2] = "atan2",
	[HCC_FUNCTION_IDX_FMAF] = "fmaf",
	[HCC_FUNCTION_IDX_FMA] = "fma",
	[HCC_FUNCTION_IDX_SQRTF] = "sqrtf",
	[HCC_FUNCTION_IDX_SQRT] = "sqrt",
	[HCC_FUNCTION_IDX_POWF] = "powf",
	[HCC_FUNCTION_IDX_POW] = "pow",
	[HCC_FUNCTION_IDX_EXPF] = "expf",
	[HCC_FUNCTION_IDX_EXP] = "exp",
	[HCC_FUNCTION_IDX_LOGF] = "logf",
	[HCC_FUNCTION_IDX_LOG] = "log",
	[HCC_FUNCTION_IDX_EXP2F] = "exp2f",
	[HCC_FUNCTION_IDX_EXP2] = "exp2",
	[HCC_FUNCTION_IDX_LOG2F] = "log2f",
	[HCC_FUNCTION_IDX_LOG2] = "log2",

	//
	// libhccstd/math.h - half
	//
	[HCC_FUNCTION_IDX_F16TOF32] = "f16tof32",
	[HCC_FUNCTION_IDX_F16TOF64] = "f16tof64",
	[HCC_FUNCTION_IDX_F32TOF16] = "f32tof16",
	[HCC_FUNCTION_IDX_F64TOF16] = "f64tof16",
	[HCC_FUNCTION_IDX_ISINFF16] = "isinff16",
	[HCC_FUNCTION_IDX_ISNANF16] = "isnanf16",
	[HCC_FUNCTION_IDX_ADDF16] = "addf16",
	[HCC_FUNCTION_IDX_SUBF16] = "subf16",
	[HCC_FUNCTION_IDX_MULF16] = "mulf16",
	[HCC_FUNCTION_IDX_DIVF16] = "divf16",
	[HCC_FUNCTION_IDX_MODF16] = "modf16",
	[HCC_FUNCTION_IDX_EQF16] = "eqf16",
	[HCC_FUNCTION_IDX_NEQF16] = "neqf16",
	[HCC_FUNCTION_IDX_LTF16] = "ltf16",
	[HCC_FUNCTION_IDX_LTEQF16] = "lteqf16",
	[HCC_FUNCTION_IDX_GTF16] = "gtf16",
	[HCC_FUNCTION_IDX_GTEQF16] = "gteqf16",
	[HCC_FUNCTION_IDX_NOTF16] = "notf16",
	[HCC_FUNCTION_IDX_NEGF16] = "negf16",
	[HCC_FUNCTION_IDX_ABSF16] = "absf16",
	[HCC_FUNCTION_IDX_FLOORF16] = "floorf16",
	[HCC_FUNCTION_IDX_CEILF16] = "ceilf16",
	[HCC_FUNCTION_IDX_ROUNDF16] = "roundf16",
	[HCC_FUNCTION_IDX_TRUNCF16] = "truncf16",
	[HCC_FUNCTION_IDX_SINF16] = "sinf16",
	[HCC_FUNCTION_IDX_COSF16] = "cosf16",
	[HCC_FUNCTION_IDX_TANF16] = "tanf16",
	[HCC_FUNCTION_IDX_ASINF16] = "asinf16",
	[HCC_FUNCTION_IDX_ACOSF16] = "acosf16",
	[HCC_FUNCTION_IDX_ATANF16] = "atanf16",
	[HCC_FUNCTION_IDX_SINHF16] = "sinhf16",
	[HCC_FUNCTION_IDX_COSHF16] = "coshf16",
	[HCC_FUNCTION_IDX_TANHF16] = "tanhf16",
	[HCC_FUNCTION_IDX_ASINHF16] = "asinhf16",
	[HCC_FUNCTION_IDX_ACOSHF16] = "acoshf16",
	[HCC_FUNCTION_IDX_ATANHF16] = "atanhf16",
	[HCC_FUNCTION_IDX_ATAN2F16] = "atan2f16",
	[HCC_FUNCTION_IDX_FMAF16] = "fmaf16",
	[HCC_FUNCTION_IDX_SQRTF16] = "sqrtf16",
	[HCC_FUNCTION_IDX_POWF16] = "powf16",
	[HCC_FUNCTION_IDX_EXPF16] = "expf16",
	[HCC_FUNCTION_IDX_LOGF16] = "logf16",
	[HCC_FUNCTION_IDX_EXP2F16] = "exp2f16",
	[HCC_FUNCTION_IDX_LOG2F16] = "log2f16",

	//
	// libhccstd/math.h - scalar
	//
	[HCC_FUNCTION_IDX_MINF16] = "minf16",
	[HCC_FUNCTION_IDX_MINF32] = "minf32",
	[HCC_FUNCTION_IDX_MINF64] = "minf64",
	[HCC_FUNCTION_IDX_MINI8] = "mini8",
	[HCC_FUNCTION_IDX_MINI16] = "mini16",
	[HCC_FUNCTION_IDX_MINI32] = "mini32",
	[HCC_FUNCTION_IDX_MINI64] = "mini64",
	[HCC_FUNCTION_IDX_MINU8] = "minu8",
	[HCC_FUNCTION_IDX_MINU16] = "minu16",
	[HCC_FUNCTION_IDX_MINU32] = "minu32",
	[HCC_FUNCTION_IDX_MINU64] = "minu64",
	[HCC_FUNCTION_IDX_MAXF16] = "maxf16",
	[HCC_FUNCTION_IDX_MAXF32] = "maxf32",
	[HCC_FUNCTION_IDX_MAXF64] = "maxf64",
	[HCC_FUNCTION_IDX_MAXI8] = "maxi8",
	[HCC_FUNCTION_IDX_MAXI16] = "maxi16",
	[HCC_FUNCTION_IDX_MAXI32] = "maxi32",
	[HCC_FUNCTION_IDX_MAXI64] = "maxi64",
	[HCC_FUNCTION_IDX_MAXU8] = "maxu8",
	[HCC_FUNCTION_IDX_MAXU16] = "maxu16",
	[HCC_FUNCTION_IDX_MAXU32] = "maxu32",
	[HCC_FUNCTION_IDX_MAXU64] = "maxu64",
	[HCC_FUNCTION_IDX_CLAMPF16] = "clampf16",
	[HCC_FUNCTION_IDX_CLAMPF32] = "clampf32",
	[HCC_FUNCTION_IDX_CLAMPF64] = "clampf64",
	[HCC_FUNCTION_IDX_CLAMPI8] = "clampi8",
	[HCC_FUNCTION_IDX_CLAMPI16] = "clampi16",
	[HCC_FUNCTION_IDX_CLAMPI32] = "clampi32",
	[HCC_FUNCTION_IDX_CLAMPI64] = "clampi64",
	[HCC_FUNCTION_IDX_CLAMPU8] = "clampu8",
	[HCC_FUNCTION_IDX_CLAMPU16] = "clampu16",
	[HCC_FUNCTION_IDX_CLAMPU32] = "clampu32",
	[HCC_FUNCTION_IDX_CLAMPU64] = "clampu64",
	[HCC_FUNCTION_IDX_ABSI8] = "absi8",
	[HCC_FUNCTION_IDX_ABSI16] = "absi16",
	[HCC_FUNCTION_IDX_ABSI32] = "absi32",
	[HCC_FUNCTION_IDX_ABSI64] = "absi64",
	[HCC_FUNCTION_IDX_RSQRTF16] = "rsqrtf16",
	[HCC_FUNCTION_IDX_RSQRTF32] = "rsqrtf32",
	[HCC_FUNCTION_IDX_RSQRTF64] = "rsqrtf64",
	[HCC_FUNCTION_IDX_SIGNF16] = "signf16",
	[HCC_FUNCTION_IDX_SIGNF32] = "signf32",
	[HCC_FUNCTION_IDX_SIGNF64] = "signf64",
	[HCC_FUNCTION_IDX_SIGNI8] = "signi8",
	[HCC_FUNCTION_IDX_SIGNI16] = "signi16",
	[HCC_FUNCTION_IDX_SIGNI32] = "signi32",
	[HCC_FUNCTION_IDX_SIGNI64] = "signi64",
	[HCC_FUNCTION_IDX_LERPF16] = "lerpf16",
	[HCC_FUNCTION_IDX_LERPF32] = "lerpf32",
	[HCC_FUNCTION_IDX_LERPF64] = "lerpf64",
	[HCC_FUNCTION_IDX_FRACTF16] = "fractf16",
	[HCC_FUNCTION_IDX_FRACTF32] = "fractf32",
	[HCC_FUNCTION_IDX_FRACTF64] = "fractf64",
	[HCC_FUNCTION_IDX_DEGREESF16] = "degreesf16",
	[HCC_FUNCTION_IDX_DEGREESF32] = "degreesf32",
	[HCC_FUNCTION_IDX_DEGREESF64] = "degreesf64",
	[HCC_FUNCTION_IDX_RADIANSF16] = "radiansf16",
	[HCC_FUNCTION_IDX_RADIANSF32] = "radiansf32",
	[HCC_FUNCTION_IDX_RADIANSF64] = "radiansf64",
	[HCC_FUNCTION_IDX_STEPF16] = "stepf16",
	[HCC_FUNCTION_IDX_STEPF32] = "stepf32",
	[HCC_FUNCTION_IDX_STEPF64] = "stepf64",
	[HCC_FUNCTION_IDX_SMOOTHSTEPF16] = "smoothstepf16",
	[HCC_FUNCTION_IDX_SMOOTHSTEPF32] = "smoothstepf32",
	[HCC_FUNCTION_IDX_SMOOTHSTEPF64] = "smoothstepf64",
	[HCC_FUNCTION_IDX_BITSTOF16] = "bitstof16",
	[HCC_FUNCTION_IDX_BITSTOF32] = "bitstof32",
	[HCC_FUNCTION_IDX_BITSTOF64] = "bitstof64",
	[HCC_FUNCTION_IDX_BITSFROMF16] = "bitsfromf16",
	[HCC_FUNCTION_IDX_BITSFROMF32] = "bitsfromf32",
	[HCC_FUNCTION_IDX_BITSFROMF64] = "bitsfromf64",

	//
	// libhccstd/math.h - vector
	//
	[HCC_FUNCTION_IDX_SWIZZLEV2F16] = "swizzlev2f16",
	[HCC_FUNCTION_IDX_SWIZZLEV2F32] = "swizzlev2f32",
	[HCC_FUNCTION_IDX_SWIZZLEV2F64] = "swizzlev2f64",
	[HCC_FUNCTION_IDX_SWIZZLEV2I8] = "swizzlev2i8",
	[HCC_FUNCTION_IDX_SWIZZLEV2I16] = "swizzlev2i16",
	[HCC_FUNCTION_IDX_SWIZZLEV2I32] = "swizzlev2i32",
	[HCC_FUNCTION_IDX_SWIZZLEV2I64] = "swizzlev2i64",
	[HCC_FUNCTION_IDX_SWIZZLEV2U8] = "swizzlev2u8",
	[HCC_FUNCTION_IDX_SWIZZLEV2U16] = "swizzlev2u16",
	[HCC_FUNCTION_IDX_SWIZZLEV2U32] = "swizzlev2u32",
	[HCC_FUNCTION_IDX_SWIZZLEV2U64] = "swizzlev2u64",
	[HCC_FUNCTION_IDX_SWIZZLEV3F16] = "swizzlev3f16",
	[HCC_FUNCTION_IDX_SWIZZLEV3F32] = "swizzlev3f32",
	[HCC_FUNCTION_IDX_SWIZZLEV3F64] = "swizzlev3f64",
	[HCC_FUNCTION_IDX_SWIZZLEV3I8] = "swizzlev3i8",
	[HCC_FUNCTION_IDX_SWIZZLEV3I16] = "swizzlev3i16",
	[HCC_FUNCTION_IDX_SWIZZLEV3I32] = "swizzlev3i32",
	[HCC_FUNCTION_IDX_SWIZZLEV3I64] = "swizzlev3i64",
	[HCC_FUNCTION_IDX_SWIZZLEV3U8] = "swizzlev3u8",
	[HCC_FUNCTION_IDX_SWIZZLEV3U16] = "swizzlev3u16",
	[HCC_FUNCTION_IDX_SWIZZLEV3U32] = "swizzlev3u32",
	[HCC_FUNCTION_IDX_SWIZZLEV3U64] = "swizzlev3u64",
	[HCC_FUNCTION_IDX_SWIZZLEV4F16] = "swizzlev4f16",
	[HCC_FUNCTION_IDX_SWIZZLEV4F32] = "swizzlev4f32",
	[HCC_FUNCTION_IDX_SWIZZLEV4F64] = "swizzlev4f64",
	[HCC_FUNCTION_IDX_SWIZZLEV4I8] = "swizzlev4i8",
	[HCC_FUNCTION_IDX_SWIZZLEV4I16] = "swizzlev4i16",
	[HCC_FUNCTION_IDX_SWIZZLEV4I32] = "swizzlev4i32",
	[HCC_FUNCTION_IDX_SWIZZLEV4I64] = "swizzlev4i64",
	[HCC_FUNCTION_IDX_SWIZZLEV4U8] = "swizzlev4u8",
	[HCC_FUNCTION_IDX_SWIZZLEV4U16] = "swizzlev4u16",
	[HCC_FUNCTION_IDX_SWIZZLEV4U32] = "swizzlev4u32",
	[HCC_FUNCTION_IDX_SWIZZLEV4U64] = "swizzlev4u64",
	[HCC_FUNCTION_IDX_PACKV2BOOL] = "packv2bool",
	[HCC_FUNCTION_IDX_PACKV2F16] = "packv2f16",
	[HCC_FUNCTION_IDX_PACKV2F32] = "packv2f32",
	[HCC_FUNCTION_IDX_PACKV2F64] = "packv2f64",
	[HCC_FUNCTION_IDX_PACKV2I8] = "packv2i8",
	[HCC_FUNCTION_IDX_PACKV2I16] = "packv2i16",
	[HCC_FUNCTION_IDX_PACKV2I32] = "packv2i32",
	[HCC_FUNCTION_IDX_PACKV2I64] = "packv2i64",
	[HCC_FUNCTION_IDX_PACKV2U8] = "packv2u8",
	[HCC_FUNCTION_IDX_PACKV2U16] = "packv2u16",
	[HCC_FUNCTION_IDX_PACKV2U32] = "packv2u32",
	[HCC_FUNCTION_IDX_PACKV2U64] = "packv2u64",
	[HCC_FUNCTION_IDX_PACKV3BOOL] = "packv3bool",
	[HCC_FUNCTION_IDX_PACKV3F16] = "packv3f16",
	[HCC_FUNCTION_IDX_PACKV3F32] = "packv3f32",
	[HCC_FUNCTION_IDX_PACKV3F64] = "packv3f64",
	[HCC_FUNCTION_IDX_PACKV3I8] = "packv3i8",
	[HCC_FUNCTION_IDX_PACKV3I16] = "packv3i16",
	[HCC_FUNCTION_IDX_PACKV3I32] = "packv3i32",
	[HCC_FUNCTION_IDX_PACKV3I64] = "packv3i64",
	[HCC_FUNCTION_IDX_PACKV3U8] = "packv3u8",
	[HCC_FUNCTION_IDX_PACKV3U16] = "packv3u16",
	[HCC_FUNCTION_IDX_PACKV3U32] = "packv3u32",
	[HCC_FUNCTION_IDX_PACKV3U64] = "packv3u64",
	[HCC_FUNCTION_IDX_PACKV4BOOL] = "packv4bool",
	[HCC_FUNCTION_IDX_PACKV4F16] = "packv4f16",
	[HCC_FUNCTION_IDX_PACKV4F32] = "packv4f32",
	[HCC_FUNCTION_IDX_PACKV4F64] = "packv4f64",
	[HCC_FUNCTION_IDX_PACKV4I8] = "packv4i8",
	[HCC_FUNCTION_IDX_PACKV4I16] = "packv4i16",
	[HCC_FUNCTION_IDX_PACKV4I32] = "packv4i32",
	[HCC_FUNCTION_IDX_PACKV4I64] = "packv4i64",
	[HCC_FUNCTION_IDX_PACKV4U8] = "packv4u8",
	[HCC_FUNCTION_IDX_PACKV4U16] = "packv4u16",
	[HCC_FUNCTION_IDX_PACKV4U32] = "packv4u32",
	[HCC_FUNCTION_IDX_PACKV4U64] = "packv4u64",
	[HCC_FUNCTION_IDX_UNPACKV2BOOL] = "unpackv2bool",
	[HCC_FUNCTION_IDX_UNPACKV2F16] = "unpackv2f16",
	[HCC_FUNCTION_IDX_UNPACKV2F32] = "unpackv2f32",
	[HCC_FUNCTION_IDX_UNPACKV2F64] = "unpackv2f64",
	[HCC_FUNCTION_IDX_UNPACKV2I8] = "unpackv2i8",
	[HCC_FUNCTION_IDX_UNPACKV2I16] = "unpackv2i16",
	[HCC_FUNCTION_IDX_UNPACKV2I32] = "unpackv2i32",
	[HCC_FUNCTION_IDX_UNPACKV2I64] = "unpackv2i64",
	[HCC_FUNCTION_IDX_UNPACKV2U8] = "unpackv2u8",
	[HCC_FUNCTION_IDX_UNPACKV2U16] = "unpackv2u16",
	[HCC_FUNCTION_IDX_UNPACKV2U32] = "unpackv2u32",
	[HCC_FUNCTION_IDX_UNPACKV2U64] = "unpackv2u64",
	[HCC_FUNCTION_IDX_UNPACKV3BOOL] = "unpackv3bool",
	[HCC_FUNCTION_IDX_UNPACKV3F16] = "unpackv3f16",
	[HCC_FUNCTION_IDX_UNPACKV3F32] = "unpackv3f32",
	[HCC_FUNCTION_IDX_UNPACKV3F64] = "unpackv3f64",
	[HCC_FUNCTION_IDX_UNPACKV3I8] = "unpackv3i8",
	[HCC_FUNCTION_IDX_UNPACKV3I16] = "unpackv3i16",
	[HCC_FUNCTION_IDX_UNPACKV3I32] = "unpackv3i32",
	[HCC_FUNCTION_IDX_UNPACKV3I64] = "unpackv3i64",
	[HCC_FUNCTION_IDX_UNPACKV3U8] = "unpackv3u8",
	[HCC_FUNCTION_IDX_UNPACKV3U16] = "unpackv3u16",
	[HCC_FUNCTION_IDX_UNPACKV3U32] = "unpackv3u32",
	[HCC_FUNCTION_IDX_UNPACKV3U64] = "unpackv3u64",
	[HCC_FUNCTION_IDX_UNPACKV4BOOL] = "unpackv4bool",
	[HCC_FUNCTION_IDX_UNPACKV4F16] = "unpackv4f16",
	[HCC_FUNCTION_IDX_UNPACKV4F32] = "unpackv4f32",
	[HCC_FUNCTION_IDX_UNPACKV4F64] = "unpackv4f64",
	[HCC_FUNCTION_IDX_UNPACKV4I8] = "unpackv4i8",
	[HCC_FUNCTION_IDX_UNPACKV4I16] = "unpackv4i16",
	[HCC_FUNCTION_IDX_UNPACKV4I32] = "unpackv4i32",
	[HCC_FUNCTION_IDX_UNPACKV4I64] = "unpackv4i64",
	[HCC_FUNCTION_IDX_UNPACKV4U8] = "unpackv4u8",
	[HCC_FUNCTION_IDX_UNPACKV4U16] = "unpackv4u16",
	[HCC_FUNCTION_IDX_UNPACKV4U32] = "unpackv4u32",
	[HCC_FUNCTION_IDX_UNPACKV4U64] = "unpackv4u64",
	[HCC_FUNCTION_IDX_ANYV2BOOL] = "anyv2bool",
	[HCC_FUNCTION_IDX_ANYV2F16] = "anyv2f16",
	[HCC_FUNCTION_IDX_ANYV2F32] = "anyv2f32",
	[HCC_FUNCTION_IDX_ANYV2F64] = "anyv2f64",
	[HCC_FUNCTION_IDX_ANYV2I8] = "anyv2i8",
	[HCC_FUNCTION_IDX_ANYV2I16] = "anyv2i16",
	[HCC_FUNCTION_IDX_ANYV2I32] = "anyv2i32",
	[HCC_FUNCTION_IDX_ANYV2I64] = "anyv2i64",
	[HCC_FUNCTION_IDX_ANYV2U8] = "anyv2u8",
	[HCC_FUNCTION_IDX_ANYV2U16] = "anyv2u16",
	[HCC_FUNCTION_IDX_ANYV2U32] = "anyv2u32",
	[HCC_FUNCTION_IDX_ANYV2U64] = "anyv2u64",
	[HCC_FUNCTION_IDX_ANYV3BOOL] = "anyv3bool",
	[HCC_FUNCTION_IDX_ANYV3F16] = "anyv3f16",
	[HCC_FUNCTION_IDX_ANYV3F32] = "anyv3f32",
	[HCC_FUNCTION_IDX_ANYV3F64] = "anyv3f64",
	[HCC_FUNCTION_IDX_ANYV3I8] = "anyv3i8",
	[HCC_FUNCTION_IDX_ANYV3I16] = "anyv3i16",
	[HCC_FUNCTION_IDX_ANYV3I32] = "anyv3i32",
	[HCC_FUNCTION_IDX_ANYV3I64] = "anyv3i64",
	[HCC_FUNCTION_IDX_ANYV3U8] = "anyv3u8",
	[HCC_FUNCTION_IDX_ANYV3U16] = "anyv3u16",
	[HCC_FUNCTION_IDX_ANYV3U32] = "anyv3u32",
	[HCC_FUNCTION_IDX_ANYV3U64] = "anyv3u64",
	[HCC_FUNCTION_IDX_ANYV4BOOL] = "anyv4bool",
	[HCC_FUNCTION_IDX_ANYV4F16] = "anyv4f16",
	[HCC_FUNCTION_IDX_ANYV4F32] = "anyv4f32",
	[HCC_FUNCTION_IDX_ANYV4F64] = "anyv4f64",
	[HCC_FUNCTION_IDX_ANYV4I8] = "anyv4i8",
	[HCC_FUNCTION_IDX_ANYV4I16] = "anyv4i16",
	[HCC_FUNCTION_IDX_ANYV4I32] = "anyv4i32",
	[HCC_FUNCTION_IDX_ANYV4I64] = "anyv4i64",
	[HCC_FUNCTION_IDX_ANYV4U8] = "anyv4u8",
	[HCC_FUNCTION_IDX_ANYV4U16] = "anyv4u16",
	[HCC_FUNCTION_IDX_ANYV4U32] = "anyv4u32",
	[HCC_FUNCTION_IDX_ANYV4U64] = "anyv4u64",
	[HCC_FUNCTION_IDX_ALLV2BOOL] = "allv2bool",
	[HCC_FUNCTION_IDX_ALLV2F16] = "allv2f16",
	[HCC_FUNCTION_IDX_ALLV2F32] = "allv2f32",
	[HCC_FUNCTION_IDX_ALLV2F64] = "allv2f64",
	[HCC_FUNCTION_IDX_ALLV2I8] = "allv2i8",
	[HCC_FUNCTION_IDX_ALLV2I16] = "allv2i16",
	[HCC_FUNCTION_IDX_ALLV2I32] = "allv2i32",
	[HCC_FUNCTION_IDX_ALLV2I64] = "allv2i64",
	[HCC_FUNCTION_IDX_ALLV2U8] = "allv2u8",
	[HCC_FUNCTION_IDX_ALLV2U16] = "allv2u16",
	[HCC_FUNCTION_IDX_ALLV2U32] = "allv2u32",
	[HCC_FUNCTION_IDX_ALLV2U64] = "allv2u64",
	[HCC_FUNCTION_IDX_ALLV3BOOL] = "allv3bool",
	[HCC_FUNCTION_IDX_ALLV3F16] = "allv3f16",
	[HCC_FUNCTION_IDX_ALLV3F32] = "allv3f32",
	[HCC_FUNCTION_IDX_ALLV3F64] = "allv3f64",
	[HCC_FUNCTION_IDX_ALLV3I8] = "allv3i8",
	[HCC_FUNCTION_IDX_ALLV3I16] = "allv3i16",
	[HCC_FUNCTION_IDX_ALLV3I32] = "allv3i32",
	[HCC_FUNCTION_IDX_ALLV3I64] = "allv3i64",
	[HCC_FUNCTION_IDX_ALLV3U8] = "allv3u8",
	[HCC_FUNCTION_IDX_ALLV3U16] = "allv3u16",
	[HCC_FUNCTION_IDX_ALLV3U32] = "allv3u32",
	[HCC_FUNCTION_IDX_ALLV3U64] = "allv3u64",
	[HCC_FUNCTION_IDX_ALLV4BOOL] = "allv4bool",
	[HCC_FUNCTION_IDX_ALLV4F16] = "allv4f16",
	[HCC_FUNCTION_IDX_ALLV4F32] = "allv4f32",
	[HCC_FUNCTION_IDX_ALLV4F64] = "allv4f64",
	[HCC_FUNCTION_IDX_ALLV4I8] = "allv4i8",
	[HCC_FUNCTION_IDX_ALLV4I16] = "allv4i16",
	[HCC_FUNCTION_IDX_ALLV4I32] = "allv4i32",
	[HCC_FUNCTION_IDX_ALLV4I64] = "allv4i64",
	[HCC_FUNCTION_IDX_ALLV4U8] = "allv4u8",
	[HCC_FUNCTION_IDX_ALLV4U16] = "allv4u16",
	[HCC_FUNCTION_IDX_ALLV4U32] = "allv4u32",
	[HCC_FUNCTION_IDX_ALLV4U64] = "allv4u64",
	[HCC_FUNCTION_IDX_NOTV2BOOL] = "notv2bool",
	[HCC_FUNCTION_IDX_NOTV2F16] = "notv2f16",
	[HCC_FUNCTION_IDX_NOTV2F32] = "notv2f32",
	[HCC_FUNCTION_IDX_NOTV2F64] = "notv2f64",
	[HCC_FUNCTION_IDX_NOTV2I8] = "notv2i8",
	[HCC_FUNCTION_IDX_NOTV2I16] = "notv2i16",
	[HCC_FUNCTION_IDX_NOTV2I32] = "notv2i32",
	[HCC_FUNCTION_IDX_NOTV2I64] = "notv2i64",
	[HCC_FUNCTION_IDX_NOTV2U8] = "notv2u8",
	[HCC_FUNCTION_IDX_NOTV2U16] = "notv2u16",
	[HCC_FUNCTION_IDX_NOTV2U32] = "notv2u32",
	[HCC_FUNCTION_IDX_NOTV2U64] = "notv2u64",
	[HCC_FUNCTION_IDX_NOTV3BOOL] = "notv3bool",
	[HCC_FUNCTION_IDX_NOTV3F16] = "notv3f16",
	[HCC_FUNCTION_IDX_NOTV3F32] = "notv3f32",
	[HCC_FUNCTION_IDX_NOTV3F64] = "notv3f64",
	[HCC_FUNCTION_IDX_NOTV3I8] = "notv3i8",
	[HCC_FUNCTION_IDX_NOTV3I16] = "notv3i16",
	[HCC_FUNCTION_IDX_NOTV3I32] = "notv3i32",
	[HCC_FUNCTION_IDX_NOTV3I64] = "notv3i64",
	[HCC_FUNCTION_IDX_NOTV3U8] = "notv3u8",
	[HCC_FUNCTION_IDX_NOTV3U16] = "notv3u16",
	[HCC_FUNCTION_IDX_NOTV3U32] = "notv3u32",
	[HCC_FUNCTION_IDX_NOTV3U64] = "notv3u64",
	[HCC_FUNCTION_IDX_NOTV4BOOL] = "notv4bool",
	[HCC_FUNCTION_IDX_NOTV4F16] = "notv4f16",
	[HCC_FUNCTION_IDX_NOTV4F32] = "notv4f32",
	[HCC_FUNCTION_IDX_NOTV4F64] = "notv4f64",
	[HCC_FUNCTION_IDX_NOTV4I8] = "notv4i8",
	[HCC_FUNCTION_IDX_NOTV4I16] = "notv4i16",
	[HCC_FUNCTION_IDX_NOTV4I32] = "notv4i32",
	[HCC_FUNCTION_IDX_NOTV4I64] = "notv4i64",
	[HCC_FUNCTION_IDX_NOTV4U8] = "notv4u8",
	[HCC_FUNCTION_IDX_NOTV4U16] = "notv4u16",
	[HCC_FUNCTION_IDX_NOTV4U32] = "notv4u32",
	[HCC_FUNCTION_IDX_NOTV4U64] = "notv4u64",
	[HCC_FUNCTION_IDX_ADDV2F16] = "addv2f16",
	[HCC_FUNCTION_IDX_ADDV2F32] = "addv2f32",
	[HCC_FUNCTION_IDX_ADDV2F64] = "addv2f64",
	[HCC_FUNCTION_IDX_ADDV2I8] = "addv2i8",
	[HCC_FUNCTION_IDX_ADDV2I16] = "addv2i16",
	[HCC_FUNCTION_IDX_ADDV2I32] = "addv2i32",
	[HCC_FUNCTION_IDX_ADDV2I64] = "addv2i64",
	[HCC_FUNCTION_IDX_ADDV2U8] = "addv2u8",
	[HCC_FUNCTION_IDX_ADDV2U16] = "addv2u16",
	[HCC_FUNCTION_IDX_ADDV2U32] = "addv2u32",
	[HCC_FUNCTION_IDX_ADDV2U64] = "addv2u64",
	[HCC_FUNCTION_IDX_ADDV3F16] = "addv3f16",
	[HCC_FUNCTION_IDX_ADDV3F32] = "addv3f32",
	[HCC_FUNCTION_IDX_ADDV3F64] = "addv3f64",
	[HCC_FUNCTION_IDX_ADDV3I8] = "addv3i8",
	[HCC_FUNCTION_IDX_ADDV3I16] = "addv3i16",
	[HCC_FUNCTION_IDX_ADDV3I32] = "addv3i32",
	[HCC_FUNCTION_IDX_ADDV3I64] = "addv3i64",
	[HCC_FUNCTION_IDX_ADDV3U8] = "addv3u8",
	[HCC_FUNCTION_IDX_ADDV3U16] = "addv3u16",
	[HCC_FUNCTION_IDX_ADDV3U32] = "addv3u32",
	[HCC_FUNCTION_IDX_ADDV3U64] = "addv3u64",
	[HCC_FUNCTION_IDX_ADDV4F16] = "addv4f16",
	[HCC_FUNCTION_IDX_ADDV4F32] = "addv4f32",
	[HCC_FUNCTION_IDX_ADDV4F64] = "addv4f64",
	[HCC_FUNCTION_IDX_ADDV4I8] = "addv4i8",
	[HCC_FUNCTION_IDX_ADDV4I16] = "addv4i16",
	[HCC_FUNCTION_IDX_ADDV4I32] = "addv4i32",
	[HCC_FUNCTION_IDX_ADDV4I64] = "addv4i64",
	[HCC_FUNCTION_IDX_ADDV4U8] = "addv4u8",
	[HCC_FUNCTION_IDX_ADDV4U16] = "addv4u16",
	[HCC_FUNCTION_IDX_ADDV4U32] = "addv4u32",
	[HCC_FUNCTION_IDX_ADDV4U64] = "addv4u64",
	[HCC_FUNCTION_IDX_SUBV2F16] = "subv2f16",
	[HCC_FUNCTION_IDX_SUBV2F32] = "subv2f32",
	[HCC_FUNCTION_IDX_SUBV2F64] = "subv2f64",
	[HCC_FUNCTION_IDX_SUBV2I8] = "subv2i8",
	[HCC_FUNCTION_IDX_SUBV2I16] = "subv2i16",
	[HCC_FUNCTION_IDX_SUBV2I32] = "subv2i32",
	[HCC_FUNCTION_IDX_SUBV2I64] = "subv2i64",
	[HCC_FUNCTION_IDX_SUBV2U8] = "subv2u8",
	[HCC_FUNCTION_IDX_SUBV2U16] = "subv2u16",
	[HCC_FUNCTION_IDX_SUBV2U32] = "subv2u32",
	[HCC_FUNCTION_IDX_SUBV2U64] = "subv2u64",
	[HCC_FUNCTION_IDX_SUBV3F16] = "subv3f16",
	[HCC_FUNCTION_IDX_SUBV3F32] = "subv3f32",
	[HCC_FUNCTION_IDX_SUBV3F64] = "subv3f64",
	[HCC_FUNCTION_IDX_SUBV3I8] = "subv3i8",
	[HCC_FUNCTION_IDX_SUBV3I16] = "subv3i16",
	[HCC_FUNCTION_IDX_SUBV3I32] = "subv3i32",
	[HCC_FUNCTION_IDX_SUBV3I64] = "subv3i64",
	[HCC_FUNCTION_IDX_SUBV3U8] = "subv3u8",
	[HCC_FUNCTION_IDX_SUBV3U16] = "subv3u16",
	[HCC_FUNCTION_IDX_SUBV3U32] = "subv3u32",
	[HCC_FUNCTION_IDX_SUBV3U64] = "subv3u64",
	[HCC_FUNCTION_IDX_SUBV4F16] = "subv4f16",
	[HCC_FUNCTION_IDX_SUBV4F32] = "subv4f32",
	[HCC_FUNCTION_IDX_SUBV4F64] = "subv4f64",
	[HCC_FUNCTION_IDX_SUBV4I8] = "subv4i8",
	[HCC_FUNCTION_IDX_SUBV4I16] = "subv4i16",
	[HCC_FUNCTION_IDX_SUBV4I32] = "subv4i32",
	[HCC_FUNCTION_IDX_SUBV4I64] = "subv4i64",
	[HCC_FUNCTION_IDX_SUBV4U8] = "subv4u8",
	[HCC_FUNCTION_IDX_SUBV4U16] = "subv4u16",
	[HCC_FUNCTION_IDX_SUBV4U32] = "subv4u32",
	[HCC_FUNCTION_IDX_SUBV4U64] = "subv4u64",
	[HCC_FUNCTION_IDX_MULV2F16] = "mulv2f16",
	[HCC_FUNCTION_IDX_MULV2F32] = "mulv2f32",
	[HCC_FUNCTION_IDX_MULV2F64] = "mulv2f64",
	[HCC_FUNCTION_IDX_MULV2I8] = "mulv2i8",
	[HCC_FUNCTION_IDX_MULV2I16] = "mulv2i16",
	[HCC_FUNCTION_IDX_MULV2I32] = "mulv2i32",
	[HCC_FUNCTION_IDX_MULV2I64] = "mulv2i64",
	[HCC_FUNCTION_IDX_MULV2U8] = "mulv2u8",
	[HCC_FUNCTION_IDX_MULV2U16] = "mulv2u16",
	[HCC_FUNCTION_IDX_MULV2U32] = "mulv2u32",
	[HCC_FUNCTION_IDX_MULV2U64] = "mulv2u64",
	[HCC_FUNCTION_IDX_MULV3F16] = "mulv3f16",
	[HCC_FUNCTION_IDX_MULV3F32] = "mulv3f32",
	[HCC_FUNCTION_IDX_MULV3F64] = "mulv3f64",
	[HCC_FUNCTION_IDX_MULV3I8] = "mulv3i8",
	[HCC_FUNCTION_IDX_MULV3I16] = "mulv3i16",
	[HCC_FUNCTION_IDX_MULV3I32] = "mulv3i32",
	[HCC_FUNCTION_IDX_MULV3I64] = "mulv3i64",
	[HCC_FUNCTION_IDX_MULV3U8] = "mulv3u8",
	[HCC_FUNCTION_IDX_MULV3U16] = "mulv3u16",
	[HCC_FUNCTION_IDX_MULV3U32] = "mulv3u32",
	[HCC_FUNCTION_IDX_MULV3U64] = "mulv3u64",
	[HCC_FUNCTION_IDX_MULV4F16] = "mulv4f16",
	[HCC_FUNCTION_IDX_MULV4F32] = "mulv4f32",
	[HCC_FUNCTION_IDX_MULV4F64] = "mulv4f64",
	[HCC_FUNCTION_IDX_MULV4I8] = "mulv4i8",
	[HCC_FUNCTION_IDX_MULV4I16] = "mulv4i16",
	[HCC_FUNCTION_IDX_MULV4I32] = "mulv4i32",
	[HCC_FUNCTION_IDX_MULV4I64] = "mulv4i64",
	[HCC_FUNCTION_IDX_MULV4U8] = "mulv4u8",
	[HCC_FUNCTION_IDX_MULV4U16] = "mulv4u16",
	[HCC_FUNCTION_IDX_MULV4U32] = "mulv4u32",
	[HCC_FUNCTION_IDX_MULV4U64] = "mulv4u64",
	[HCC_FUNCTION_IDX_DIVV2F16] = "divv2f16",
	[HCC_FUNCTION_IDX_DIVV2F32] = "divv2f32",
	[HCC_FUNCTION_IDX_DIVV2F64] = "divv2f64",
	[HCC_FUNCTION_IDX_DIVV2I8] = "divv2i8",
	[HCC_FUNCTION_IDX_DIVV2I16] = "divv2i16",
	[HCC_FUNCTION_IDX_DIVV2I32] = "divv2i32",
	[HCC_FUNCTION_IDX_DIVV2I64] = "divv2i64",
	[HCC_FUNCTION_IDX_DIVV2U8] = "divv2u8",
	[HCC_FUNCTION_IDX_DIVV2U16] = "divv2u16",
	[HCC_FUNCTION_IDX_DIVV2U32] = "divv2u32",
	[HCC_FUNCTION_IDX_DIVV2U64] = "divv2u64",
	[HCC_FUNCTION_IDX_DIVV3F16] = "divv3f16",
	[HCC_FUNCTION_IDX_DIVV3F32] = "divv3f32",
	[HCC_FUNCTION_IDX_DIVV3F64] = "divv3f64",
	[HCC_FUNCTION_IDX_DIVV3I8] = "divv3i8",
	[HCC_FUNCTION_IDX_DIVV3I16] = "divv3i16",
	[HCC_FUNCTION_IDX_DIVV3I32] = "divv3i32",
	[HCC_FUNCTION_IDX_DIVV3I64] = "divv3i64",
	[HCC_FUNCTION_IDX_DIVV3U8] = "divv3u8",
	[HCC_FUNCTION_IDX_DIVV3U16] = "divv3u16",
	[HCC_FUNCTION_IDX_DIVV3U32] = "divv3u32",
	[HCC_FUNCTION_IDX_DIVV3U64] = "divv3u64",
	[HCC_FUNCTION_IDX_DIVV4F16] = "divv4f16",
	[HCC_FUNCTION_IDX_DIVV4F32] = "divv4f32",
	[HCC_FUNCTION_IDX_DIVV4F64] = "divv4f64",
	[HCC_FUNCTION_IDX_DIVV4I8] = "divv4i8",
	[HCC_FUNCTION_IDX_DIVV4I16] = "divv4i16",
	[HCC_FUNCTION_IDX_DIVV4I32] = "divv4i32",
	[HCC_FUNCTION_IDX_DIVV4I64] = "divv4i64",
	[HCC_FUNCTION_IDX_DIVV4U8] = "divv4u8",
	[HCC_FUNCTION_IDX_DIVV4U16] = "divv4u16",
	[HCC_FUNCTION_IDX_DIVV4U32] = "divv4u32",
	[HCC_FUNCTION_IDX_DIVV4U64] = "divv4u64",
	[HCC_FUNCTION_IDX_MODV2F16] = "modv2f16",
	[HCC_FUNCTION_IDX_MODV2F32] = "modv2f32",
	[HCC_FUNCTION_IDX_MODV2F64] = "modv2f64",
	[HCC_FUNCTION_IDX_MODV2I8] = "modv2i8",
	[HCC_FUNCTION_IDX_MODV2I16] = "modv2i16",
	[HCC_FUNCTION_IDX_MODV2I32] = "modv2i32",
	[HCC_FUNCTION_IDX_MODV2I64] = "modv2i64",
	[HCC_FUNCTION_IDX_MODV2U8] = "modv2u8",
	[HCC_FUNCTION_IDX_MODV2U16] = "modv2u16",
	[HCC_FUNCTION_IDX_MODV2U32] = "modv2u32",
	[HCC_FUNCTION_IDX_MODV2U64] = "modv2u64",
	[HCC_FUNCTION_IDX_MODV3F16] = "modv3f16",
	[HCC_FUNCTION_IDX_MODV3F32] = "modv3f32",
	[HCC_FUNCTION_IDX_MODV3F64] = "modv3f64",
	[HCC_FUNCTION_IDX_MODV3I8] = "modv3i8",
	[HCC_FUNCTION_IDX_MODV3I16] = "modv3i16",
	[HCC_FUNCTION_IDX_MODV3I32] = "modv3i32",
	[HCC_FUNCTION_IDX_MODV3I64] = "modv3i64",
	[HCC_FUNCTION_IDX_MODV3U8] = "modv3u8",
	[HCC_FUNCTION_IDX_MODV3U16] = "modv3u16",
	[HCC_FUNCTION_IDX_MODV3U32] = "modv3u32",
	[HCC_FUNCTION_IDX_MODV3U64] = "modv3u64",
	[HCC_FUNCTION_IDX_MODV4F16] = "modv4f16",
	[HCC_FUNCTION_IDX_MODV4F32] = "modv4f32",
	[HCC_FUNCTION_IDX_MODV4F64] = "modv4f64",
	[HCC_FUNCTION_IDX_MODV4I8] = "modv4i8",
	[HCC_FUNCTION_IDX_MODV4I16] = "modv4i16",
	[HCC_FUNCTION_IDX_MODV4I32] = "modv4i32",
	[HCC_FUNCTION_IDX_MODV4I64] = "modv4i64",
	[HCC_FUNCTION_IDX_MODV4U8] = "modv4u8",
	[HCC_FUNCTION_IDX_MODV4U16] = "modv4u16",
	[HCC_FUNCTION_IDX_MODV4U32] = "modv4u32",
	[HCC_FUNCTION_IDX_MODV4U64] = "modv4u64",
	[HCC_FUNCTION_IDX_EQV2F16] = "eqv2f16",
	[HCC_FUNCTION_IDX_EQV2F32] = "eqv2f32",
	[HCC_FUNCTION_IDX_EQV2F64] = "eqv2f64",
	[HCC_FUNCTION_IDX_EQV2I8] = "eqv2i8",
	[HCC_FUNCTION_IDX_EQV2I16] = "eqv2i16",
	[HCC_FUNCTION_IDX_EQV2I32] = "eqv2i32",
	[HCC_FUNCTION_IDX_EQV2I64] = "eqv2i64",
	[HCC_FUNCTION_IDX_EQV2U8] = "eqv2u8",
	[HCC_FUNCTION_IDX_EQV2U16] = "eqv2u16",
	[HCC_FUNCTION_IDX_EQV2U32] = "eqv2u32",
	[HCC_FUNCTION_IDX_EQV2U64] = "eqv2u64",
	[HCC_FUNCTION_IDX_EQV3F16] = "eqv3f16",
	[HCC_FUNCTION_IDX_EQV3F32] = "eqv3f32",
	[HCC_FUNCTION_IDX_EQV3F64] = "eqv3f64",
	[HCC_FUNCTION_IDX_EQV3I8] = "eqv3i8",
	[HCC_FUNCTION_IDX_EQV3I16] = "eqv3i16",
	[HCC_FUNCTION_IDX_EQV3I32] = "eqv3i32",
	[HCC_FUNCTION_IDX_EQV3I64] = "eqv3i64",
	[HCC_FUNCTION_IDX_EQV3U8] = "eqv3u8",
	[HCC_FUNCTION_IDX_EQV3U16] = "eqv3u16",
	[HCC_FUNCTION_IDX_EQV3U32] = "eqv3u32",
	[HCC_FUNCTION_IDX_EQV3U64] = "eqv3u64",
	[HCC_FUNCTION_IDX_EQV4F16] = "eqv4f16",
	[HCC_FUNCTION_IDX_EQV4F32] = "eqv4f32",
	[HCC_FUNCTION_IDX_EQV4F64] = "eqv4f64",
	[HCC_FUNCTION_IDX_EQV4I8] = "eqv4i8",
	[HCC_FUNCTION_IDX_EQV4I16] = "eqv4i16",
	[HCC_FUNCTION_IDX_EQV4I32] = "eqv4i32",
	[HCC_FUNCTION_IDX_EQV4I64] = "eqv4i64",
	[HCC_FUNCTION_IDX_EQV4U8] = "eqv4u8",
	[HCC_FUNCTION_IDX_EQV4U16] = "eqv4u16",
	[HCC_FUNCTION_IDX_EQV4U32] = "eqv4u32",
	[HCC_FUNCTION_IDX_EQV4U64] = "eqv4u64",
	[HCC_FUNCTION_IDX_NEQV2F16] = "neqv2f16",
	[HCC_FUNCTION_IDX_NEQV2F32] = "neqv2f32",
	[HCC_FUNCTION_IDX_NEQV2F64] = "neqv2f64",
	[HCC_FUNCTION_IDX_NEQV2I8] = "neqv2i8",
	[HCC_FUNCTION_IDX_NEQV2I16] = "neqv2i16",
	[HCC_FUNCTION_IDX_NEQV2I32] = "neqv2i32",
	[HCC_FUNCTION_IDX_NEQV2I64] = "neqv2i64",
	[HCC_FUNCTION_IDX_NEQV2U8] = "neqv2u8",
	[HCC_FUNCTION_IDX_NEQV2U16] = "neqv2u16",
	[HCC_FUNCTION_IDX_NEQV2U32] = "neqv2u32",
	[HCC_FUNCTION_IDX_NEQV2U64] = "neqv2u64",
	[HCC_FUNCTION_IDX_NEQV3F16] = "neqv3f16",
	[HCC_FUNCTION_IDX_NEQV3F32] = "neqv3f32",
	[HCC_FUNCTION_IDX_NEQV3F64] = "neqv3f64",
	[HCC_FUNCTION_IDX_NEQV3I8] = "neqv3i8",
	[HCC_FUNCTION_IDX_NEQV3I16] = "neqv3i16",
	[HCC_FUNCTION_IDX_NEQV3I32] = "neqv3i32",
	[HCC_FUNCTION_IDX_NEQV3I64] = "neqv3i64",
	[HCC_FUNCTION_IDX_NEQV3U8] = "neqv3u8",
	[HCC_FUNCTION_IDX_NEQV3U16] = "neqv3u16",
	[HCC_FUNCTION_IDX_NEQV3U32] = "neqv3u32",
	[HCC_FUNCTION_IDX_NEQV3U64] = "neqv3u64",
	[HCC_FUNCTION_IDX_NEQV4F16] = "neqv4f16",
	[HCC_FUNCTION_IDX_NEQV4F32] = "neqv4f32",
	[HCC_FUNCTION_IDX_NEQV4F64] = "neqv4f64",
	[HCC_FUNCTION_IDX_NEQV4I8] = "neqv4i8",
	[HCC_FUNCTION_IDX_NEQV4I16] = "neqv4i16",
	[HCC_FUNCTION_IDX_NEQV4I32] = "neqv4i32",
	[HCC_FUNCTION_IDX_NEQV4I64] = "neqv4i64",
	[HCC_FUNCTION_IDX_NEQV4U8] = "neqv4u8",
	[HCC_FUNCTION_IDX_NEQV4U16] = "neqv4u16",
	[HCC_FUNCTION_IDX_NEQV4U32] = "neqv4u32",
	[HCC_FUNCTION_IDX_NEQV4U64] = "neqv4u64",
	[HCC_FUNCTION_IDX_LTV2F16] = "ltv2f16",
	[HCC_FUNCTION_IDX_LTV2F32] = "ltv2f32",
	[HCC_FUNCTION_IDX_LTV2F64] = "ltv2f64",
	[HCC_FUNCTION_IDX_LTV2I8] = "ltv2i8",
	[HCC_FUNCTION_IDX_LTV2I16] = "ltv2i16",
	[HCC_FUNCTION_IDX_LTV2I32] = "ltv2i32",
	[HCC_FUNCTION_IDX_LTV2I64] = "ltv2i64",
	[HCC_FUNCTION_IDX_LTV2U8] = "ltv2u8",
	[HCC_FUNCTION_IDX_LTV2U16] = "ltv2u16",
	[HCC_FUNCTION_IDX_LTV2U32] = "ltv2u32",
	[HCC_FUNCTION_IDX_LTV2U64] = "ltv2u64",
	[HCC_FUNCTION_IDX_LTV3F16] = "ltv3f16",
	[HCC_FUNCTION_IDX_LTV3F32] = "ltv3f32",
	[HCC_FUNCTION_IDX_LTV3F64] = "ltv3f64",
	[HCC_FUNCTION_IDX_LTV3I8] = "ltv3i8",
	[HCC_FUNCTION_IDX_LTV3I16] = "ltv3i16",
	[HCC_FUNCTION_IDX_LTV3I32] = "ltv3i32",
	[HCC_FUNCTION_IDX_LTV3I64] = "ltv3i64",
	[HCC_FUNCTION_IDX_LTV3U8] = "ltv3u8",
	[HCC_FUNCTION_IDX_LTV3U16] = "ltv3u16",
	[HCC_FUNCTION_IDX_LTV3U32] = "ltv3u32",
	[HCC_FUNCTION_IDX_LTV3U64] = "ltv3u64",
	[HCC_FUNCTION_IDX_LTV4F16] = "ltv4f16",
	[HCC_FUNCTION_IDX_LTV4F32] = "ltv4f32",
	[HCC_FUNCTION_IDX_LTV4F64] = "ltv4f64",
	[HCC_FUNCTION_IDX_LTV4I8] = "ltv4i8",
	[HCC_FUNCTION_IDX_LTV4I16] = "ltv4i16",
	[HCC_FUNCTION_IDX_LTV4I32] = "ltv4i32",
	[HCC_FUNCTION_IDX_LTV4I64] = "ltv4i64",
	[HCC_FUNCTION_IDX_LTV4U8] = "ltv4u8",
	[HCC_FUNCTION_IDX_LTV4U16] = "ltv4u16",
	[HCC_FUNCTION_IDX_LTV4U32] = "ltv4u32",
	[HCC_FUNCTION_IDX_LTV4U64] = "ltv4u64",
	[HCC_FUNCTION_IDX_LTEQV2F16] = "lteqv2f16",
	[HCC_FUNCTION_IDX_LTEQV2F32] = "lteqv2f32",
	[HCC_FUNCTION_IDX_LTEQV2F64] = "lteqv2f64",
	[HCC_FUNCTION_IDX_LTEQV2I8] = "lteqv2i8",
	[HCC_FUNCTION_IDX_LTEQV2I16] = "lteqv2i16",
	[HCC_FUNCTION_IDX_LTEQV2I32] = "lteqv2i32",
	[HCC_FUNCTION_IDX_LTEQV2I64] = "lteqv2i64",
	[HCC_FUNCTION_IDX_LTEQV2U8] = "lteqv2u8",
	[HCC_FUNCTION_IDX_LTEQV2U16] = "lteqv2u16",
	[HCC_FUNCTION_IDX_LTEQV2U32] = "lteqv2u32",
	[HCC_FUNCTION_IDX_LTEQV2U64] = "lteqv2u64",
	[HCC_FUNCTION_IDX_LTEQV3F16] = "lteqv3f16",
	[HCC_FUNCTION_IDX_LTEQV3F32] = "lteqv3f32",
	[HCC_FUNCTION_IDX_LTEQV3F64] = "lteqv3f64",
	[HCC_FUNCTION_IDX_LTEQV3I8] = "lteqv3i8",
	[HCC_FUNCTION_IDX_LTEQV3I16] = "lteqv3i16",
	[HCC_FUNCTION_IDX_LTEQV3I32] = "lteqv3i32",
	[HCC_FUNCTION_IDX_LTEQV3I64] = "lteqv3i64",
	[HCC_FUNCTION_IDX_LTEQV3U8] = "lteqv3u8",
	[HCC_FUNCTION_IDX_LTEQV3U16] = "lteqv3u16",
	[HCC_FUNCTION_IDX_LTEQV3U32] = "lteqv3u32",
	[HCC_FUNCTION_IDX_LTEQV3U64] = "lteqv3u64",
	[HCC_FUNCTION_IDX_LTEQV4F16] = "lteqv4f16",
	[HCC_FUNCTION_IDX_LTEQV4F32] = "lteqv4f32",
	[HCC_FUNCTION_IDX_LTEQV4F64] = "lteqv4f64",
	[HCC_FUNCTION_IDX_LTEQV4I8] = "lteqv4i8",
	[HCC_FUNCTION_IDX_LTEQV4I16] = "lteqv4i16",
	[HCC_FUNCTION_IDX_LTEQV4I32] = "lteqv4i32",
	[HCC_FUNCTION_IDX_LTEQV4I64] = "lteqv4i64",
	[HCC_FUNCTION_IDX_LTEQV4U8] = "lteqv4u8",
	[HCC_FUNCTION_IDX_LTEQV4U16] = "lteqv4u16",
	[HCC_FUNCTION_IDX_LTEQV4U32] = "lteqv4u32",
	[HCC_FUNCTION_IDX_LTEQV4U64] = "lteqv4u64",
	[HCC_FUNCTION_IDX_GTV2F16] = "gtv2f16",
	[HCC_FUNCTION_IDX_GTV2F32] = "gtv2f32",
	[HCC_FUNCTION_IDX_GTV2F64] = "gtv2f64",
	[HCC_FUNCTION_IDX_GTV2I8] = "gtv2i8",
	[HCC_FUNCTION_IDX_GTV2I16] = "gtv2i16",
	[HCC_FUNCTION_IDX_GTV2I32] = "gtv2i32",
	[HCC_FUNCTION_IDX_GTV2I64] = "gtv2i64",
	[HCC_FUNCTION_IDX_GTV2U8] = "gtv2u8",
	[HCC_FUNCTION_IDX_GTV2U16] = "gtv2u16",
	[HCC_FUNCTION_IDX_GTV2U32] = "gtv2u32",
	[HCC_FUNCTION_IDX_GTV2U64] = "gtv2u64",
	[HCC_FUNCTION_IDX_GTV3F16] = "gtv3f16",
	[HCC_FUNCTION_IDX_GTV3F32] = "gtv3f32",
	[HCC_FUNCTION_IDX_GTV3F64] = "gtv3f64",
	[HCC_FUNCTION_IDX_GTV3I8] = "gtv3i8",
	[HCC_FUNCTION_IDX_GTV3I16] = "gtv3i16",
	[HCC_FUNCTION_IDX_GTV3I32] = "gtv3i32",
	[HCC_FUNCTION_IDX_GTV3I64] = "gtv3i64",
	[HCC_FUNCTION_IDX_GTV3U8] = "gtv3u8",
	[HCC_FUNCTION_IDX_GTV3U16] = "gtv3u16",
	[HCC_FUNCTION_IDX_GTV3U32] = "gtv3u32",
	[HCC_FUNCTION_IDX_GTV3U64] = "gtv3u64",
	[HCC_FUNCTION_IDX_GTV4F16] = "gtv4f16",
	[HCC_FUNCTION_IDX_GTV4F32] = "gtv4f32",
	[HCC_FUNCTION_IDX_GTV4F64] = "gtv4f64",
	[HCC_FUNCTION_IDX_GTV4I8] = "gtv4i8",
	[HCC_FUNCTION_IDX_GTV4I16] = "gtv4i16",
	[HCC_FUNCTION_IDX_GTV4I32] = "gtv4i32",
	[HCC_FUNCTION_IDX_GTV4I64] = "gtv4i64",
	[HCC_FUNCTION_IDX_GTV4U8] = "gtv4u8",
	[HCC_FUNCTION_IDX_GTV4U16] = "gtv4u16",
	[HCC_FUNCTION_IDX_GTV4U32] = "gtv4u32",
	[HCC_FUNCTION_IDX_GTV4U64] = "gtv4u64",
	[HCC_FUNCTION_IDX_GTEQV2F16] = "gteqv2f16",
	[HCC_FUNCTION_IDX_GTEQV2F32] = "gteqv2f32",
	[HCC_FUNCTION_IDX_GTEQV2F64] = "gteqv2f64",
	[HCC_FUNCTION_IDX_GTEQV2I8] = "gteqv2i8",
	[HCC_FUNCTION_IDX_GTEQV2I16] = "gteqv2i16",
	[HCC_FUNCTION_IDX_GTEQV2I32] = "gteqv2i32",
	[HCC_FUNCTION_IDX_GTEQV2I64] = "gteqv2i64",
	[HCC_FUNCTION_IDX_GTEQV2U8] = "gteqv2u8",
	[HCC_FUNCTION_IDX_GTEQV2U16] = "gteqv2u16",
	[HCC_FUNCTION_IDX_GTEQV2U32] = "gteqv2u32",
	[HCC_FUNCTION_IDX_GTEQV2U64] = "gteqv2u64",
	[HCC_FUNCTION_IDX_GTEQV3F16] = "gteqv3f16",
	[HCC_FUNCTION_IDX_GTEQV3F32] = "gteqv3f32",
	[HCC_FUNCTION_IDX_GTEQV3F64] = "gteqv3f64",
	[HCC_FUNCTION_IDX_GTEQV3I8] = "gteqv3i8",
	[HCC_FUNCTION_IDX_GTEQV3I16] = "gteqv3i16",
	[HCC_FUNCTION_IDX_GTEQV3I32] = "gteqv3i32",
	[HCC_FUNCTION_IDX_GTEQV3I64] = "gteqv3i64",
	[HCC_FUNCTION_IDX_GTEQV3U8] = "gteqv3u8",
	[HCC_FUNCTION_IDX_GTEQV3U16] = "gteqv3u16",
	[HCC_FUNCTION_IDX_GTEQV3U32] = "gteqv3u32",
	[HCC_FUNCTION_IDX_GTEQV3U64] = "gteqv3u64",
	[HCC_FUNCTION_IDX_GTEQV4F16] = "gteqv4f16",
	[HCC_FUNCTION_IDX_GTEQV4F32] = "gteqv4f32",
	[HCC_FUNCTION_IDX_GTEQV4F64] = "gteqv4f64",
	[HCC_FUNCTION_IDX_GTEQV4I8] = "gteqv4i8",
	[HCC_FUNCTION_IDX_GTEQV4I16] = "gteqv4i16",
	[HCC_FUNCTION_IDX_GTEQV4I32] = "gteqv4i32",
	[HCC_FUNCTION_IDX_GTEQV4I64] = "gteqv4i64",
	[HCC_FUNCTION_IDX_GTEQV4U8] = "gteqv4u8",
	[HCC_FUNCTION_IDX_GTEQV4U16] = "gteqv4u16",
	[HCC_FUNCTION_IDX_GTEQV4U32] = "gteqv4u32",
	[HCC_FUNCTION_IDX_GTEQV4U64] = "gteqv4u64",
	[HCC_FUNCTION_IDX_NEGV2F16] = "negv2f16",
	[HCC_FUNCTION_IDX_NEGV2F32] = "negv2f32",
	[HCC_FUNCTION_IDX_NEGV2F64] = "negv2f64",
	[HCC_FUNCTION_IDX_NEGV2I8] = "negv2i8",
	[HCC_FUNCTION_IDX_NEGV2I16] = "negv2i16",
	[HCC_FUNCTION_IDX_NEGV2I32] = "negv2i32",
	[HCC_FUNCTION_IDX_NEGV2I64] = "negv2i64",
	[HCC_FUNCTION_IDX_NEGV2U8] = "negv2u8",
	[HCC_FUNCTION_IDX_NEGV2U16] = "negv2u16",
	[HCC_FUNCTION_IDX_NEGV2U32] = "negv2u32",
	[HCC_FUNCTION_IDX_NEGV2U64] = "negv2u64",
	[HCC_FUNCTION_IDX_NEGV3F16] = "negv3f16",
	[HCC_FUNCTION_IDX_NEGV3F32] = "negv3f32",
	[HCC_FUNCTION_IDX_NEGV3F64] = "negv3f64",
	[HCC_FUNCTION_IDX_NEGV3I8] = "negv3i8",
	[HCC_FUNCTION_IDX_NEGV3I16] = "negv3i16",
	[HCC_FUNCTION_IDX_NEGV3I32] = "negv3i32",
	[HCC_FUNCTION_IDX_NEGV3I64] = "negv3i64",
	[HCC_FUNCTION_IDX_NEGV3U8] = "negv3u8",
	[HCC_FUNCTION_IDX_NEGV3U16] = "negv3u16",
	[HCC_FUNCTION_IDX_NEGV3U32] = "negv3u32",
	[HCC_FUNCTION_IDX_NEGV3U64] = "negv3u64",
	[HCC_FUNCTION_IDX_NEGV4F16] = "negv4f16",
	[HCC_FUNCTION_IDX_NEGV4F32] = "negv4f32",
	[HCC_FUNCTION_IDX_NEGV4F64] = "negv4f64",
	[HCC_FUNCTION_IDX_NEGV4I8] = "negv4i8",
	[HCC_FUNCTION_IDX_NEGV4I16] = "negv4i16",
	[HCC_FUNCTION_IDX_NEGV4I32] = "negv4i32",
	[HCC_FUNCTION_IDX_NEGV4I64] = "negv4i64",
	[HCC_FUNCTION_IDX_NEGV4U8] = "negv4u8",
	[HCC_FUNCTION_IDX_NEGV4U16] = "negv4u16",
	[HCC_FUNCTION_IDX_NEGV4U32] = "negv4u32",
	[HCC_FUNCTION_IDX_NEGV4U64] = "negv4u64",
	[HCC_FUNCTION_IDX_MINV2F16] = "minv2f16",
	[HCC_FUNCTION_IDX_MINV2F32] = "minv2f32",
	[HCC_FUNCTION_IDX_MINV2F64] = "minv2f64",
	[HCC_FUNCTION_IDX_MINV2I8] = "minv2i8",
	[HCC_FUNCTION_IDX_MINV2I16] = "minv2i16",
	[HCC_FUNCTION_IDX_MINV2I32] = "minv2i32",
	[HCC_FUNCTION_IDX_MINV2I64] = "minv2i64",
	[HCC_FUNCTION_IDX_MINV2U8] = "minv2u8",
	[HCC_FUNCTION_IDX_MINV2U16] = "minv2u16",
	[HCC_FUNCTION_IDX_MINV2U32] = "minv2u32",
	[HCC_FUNCTION_IDX_MINV2U64] = "minv2u64",
	[HCC_FUNCTION_IDX_MINV3F16] = "minv3f16",
	[HCC_FUNCTION_IDX_MINV3F32] = "minv3f32",
	[HCC_FUNCTION_IDX_MINV3F64] = "minv3f64",
	[HCC_FUNCTION_IDX_MINV3I8] = "minv3i8",
	[HCC_FUNCTION_IDX_MINV3I16] = "minv3i16",
	[HCC_FUNCTION_IDX_MINV3I32] = "minv3i32",
	[HCC_FUNCTION_IDX_MINV3I64] = "minv3i64",
	[HCC_FUNCTION_IDX_MINV3U8] = "minv3u8",
	[HCC_FUNCTION_IDX_MINV3U16] = "minv3u16",
	[HCC_FUNCTION_IDX_MINV3U32] = "minv3u32",
	[HCC_FUNCTION_IDX_MINV3U64] = "minv3u64",
	[HCC_FUNCTION_IDX_MINV4F16] = "minv4f16",
	[HCC_FUNCTION_IDX_MINV4F32] = "minv4f32",
	[HCC_FUNCTION_IDX_MINV4F64] = "minv4f64",
	[HCC_FUNCTION_IDX_MINV4I8] = "minv4i8",
	[HCC_FUNCTION_IDX_MINV4I16] = "minv4i16",
	[HCC_FUNCTION_IDX_MINV4I32] = "minv4i32",
	[HCC_FUNCTION_IDX_MINV4I64] = "minv4i64",
	[HCC_FUNCTION_IDX_MINV4U8] = "minv4u8",
	[HCC_FUNCTION_IDX_MINV4U16] = "minv4u16",
	[HCC_FUNCTION_IDX_MINV4U32] = "minv4u32",
	[HCC_FUNCTION_IDX_MINV4U64] = "minv4u64",
	[HCC_FUNCTION_IDX_MAXV2F16] = "maxv2f16",
	[HCC_FUNCTION_IDX_MAXV2F32] = "maxv2f32",
	[HCC_FUNCTION_IDX_MAXV2F64] = "maxv2f64",
	[HCC_FUNCTION_IDX_MAXV2I8] = "maxv2i8",
	[HCC_FUNCTION_IDX_MAXV2I16] = "maxv2i16",
	[HCC_FUNCTION_IDX_MAXV2I32] = "maxv2i32",
	[HCC_FUNCTION_IDX_MAXV2I64] = "maxv2i64",
	[HCC_FUNCTION_IDX_MAXV2U8] = "maxv2u8",
	[HCC_FUNCTION_IDX_MAXV2U16] = "maxv2u16",
	[HCC_FUNCTION_IDX_MAXV2U32] = "maxv2u32",
	[HCC_FUNCTION_IDX_MAXV2U64] = "maxv2u64",
	[HCC_FUNCTION_IDX_MAXV3F16] = "maxv3f16",
	[HCC_FUNCTION_IDX_MAXV3F32] = "maxv3f32",
	[HCC_FUNCTION_IDX_MAXV3F64] = "maxv3f64",
	[HCC_FUNCTION_IDX_MAXV3I8] = "maxv3i8",
	[HCC_FUNCTION_IDX_MAXV3I16] = "maxv3i16",
	[HCC_FUNCTION_IDX_MAXV3I32] = "maxv3i32",
	[HCC_FUNCTION_IDX_MAXV3I64] = "maxv3i64",
	[HCC_FUNCTION_IDX_MAXV3U8] = "maxv3u8",
	[HCC_FUNCTION_IDX_MAXV3U16] = "maxv3u16",
	[HCC_FUNCTION_IDX_MAXV3U32] = "maxv3u32",
	[HCC_FUNCTION_IDX_MAXV3U64] = "maxv3u64",
	[HCC_FUNCTION_IDX_MAXV4F16] = "maxv4f16",
	[HCC_FUNCTION_IDX_MAXV4F32] = "maxv4f32",
	[HCC_FUNCTION_IDX_MAXV4F64] = "maxv4f64",
	[HCC_FUNCTION_IDX_MAXV4I8] = "maxv4i8",
	[HCC_FUNCTION_IDX_MAXV4I16] = "maxv4i16",
	[HCC_FUNCTION_IDX_MAXV4I32] = "maxv4i32",
	[HCC_FUNCTION_IDX_MAXV4I64] = "maxv4i64",
	[HCC_FUNCTION_IDX_MAXV4U8] = "maxv4u8",
	[HCC_FUNCTION_IDX_MAXV4U16] = "maxv4u16",
	[HCC_FUNCTION_IDX_MAXV4U32] = "maxv4u32",
	[HCC_FUNCTION_IDX_MAXV4U64] = "maxv4u64",
	[HCC_FUNCTION_IDX_CLAMPV2F16] = "clampv2f16",
	[HCC_FUNCTION_IDX_CLAMPV2F32] = "clampv2f32",
	[HCC_FUNCTION_IDX_CLAMPV2F64] = "clampv2f64",
	[HCC_FUNCTION_IDX_CLAMPV2I8] = "clampv2i8",
	[HCC_FUNCTION_IDX_CLAMPV2I16] = "clampv2i16",
	[HCC_FUNCTION_IDX_CLAMPV2I32] = "clampv2i32",
	[HCC_FUNCTION_IDX_CLAMPV2I64] = "clampv2i64",
	[HCC_FUNCTION_IDX_CLAMPV2U8] = "clampv2u8",
	[HCC_FUNCTION_IDX_CLAMPV2U16] = "clampv2u16",
	[HCC_FUNCTION_IDX_CLAMPV2U32] = "clampv2u32",
	[HCC_FUNCTION_IDX_CLAMPV2U64] = "clampv2u64",
	[HCC_FUNCTION_IDX_CLAMPV3F16] = "clampv3f16",
	[HCC_FUNCTION_IDX_CLAMPV3F32] = "clampv3f32",
	[HCC_FUNCTION_IDX_CLAMPV3F64] = "clampv3f64",
	[HCC_FUNCTION_IDX_CLAMPV3I8] = "clampv3i8",
	[HCC_FUNCTION_IDX_CLAMPV3I16] = "clampv3i16",
	[HCC_FUNCTION_IDX_CLAMPV3I32] = "clampv3i32",
	[HCC_FUNCTION_IDX_CLAMPV3I64] = "clampv3i64",
	[HCC_FUNCTION_IDX_CLAMPV3U8] = "clampv3u8",
	[HCC_FUNCTION_IDX_CLAMPV3U16] = "clampv3u16",
	[HCC_FUNCTION_IDX_CLAMPV3U32] = "clampv3u32",
	[HCC_FUNCTION_IDX_CLAMPV3U64] = "clampv3u64",
	[HCC_FUNCTION_IDX_CLAMPV4F16] = "clampv4f16",
	[HCC_FUNCTION_IDX_CLAMPV4F32] = "clampv4f32",
	[HCC_FUNCTION_IDX_CLAMPV4F64] = "clampv4f64",
	[HCC_FUNCTION_IDX_CLAMPV4I8] = "clampv4i8",
	[HCC_FUNCTION_IDX_CLAMPV4I16] = "clampv4i16",
	[HCC_FUNCTION_IDX_CLAMPV4I32] = "clampv4i32",
	[HCC_FUNCTION_IDX_CLAMPV4I64] = "clampv4i64",
	[HCC_FUNCTION_IDX_CLAMPV4U8] = "clampv4u8",
	[HCC_FUNCTION_IDX_CLAMPV4U16] = "clampv4u16",
	[HCC_FUNCTION_IDX_CLAMPV4U32] = "clampv4u32",
	[HCC_FUNCTION_IDX_CLAMPV4U64] = "clampv4u64",
	[HCC_FUNCTION_IDX_SIGNV2F16] = "signv2f16",
	[HCC_FUNCTION_IDX_SIGNV2F32] = "signv2f32",
	[HCC_FUNCTION_IDX_SIGNV2F64] = "signv2f64",
	[HCC_FUNCTION_IDX_SIGNV2I8] = "signv2i8",
	[HCC_FUNCTION_IDX_SIGNV2I16] = "signv2i16",
	[HCC_FUNCTION_IDX_SIGNV2I32] = "signv2i32",
	[HCC_FUNCTION_IDX_SIGNV2I64] = "signv2i64",
	[HCC_FUNCTION_IDX_SIGNV3F16] = "signv3f16",
	[HCC_FUNCTION_IDX_SIGNV3F32] = "signv3f32",
	[HCC_FUNCTION_IDX_SIGNV3F64] = "signv3f64",
	[HCC_FUNCTION_IDX_SIGNV3I8] = "signv3i8",
	[HCC_FUNCTION_IDX_SIGNV3I16] = "signv3i16",
	[HCC_FUNCTION_IDX_SIGNV3I32] = "signv3i32",
	[HCC_FUNCTION_IDX_SIGNV3I64] = "signv3i64",
	[HCC_FUNCTION_IDX_SIGNV4F16] = "signv4f16",
	[HCC_FUNCTION_IDX_SIGNV4F32] = "signv4f32",
	[HCC_FUNCTION_IDX_SIGNV4F64] = "signv4f64",
	[HCC_FUNCTION_IDX_SIGNV4I8] = "signv4i8",
	[HCC_FUNCTION_IDX_SIGNV4I16] = "signv4i16",
	[HCC_FUNCTION_IDX_SIGNV4I32] = "signv4i32",
	[HCC_FUNCTION_IDX_SIGNV4I64] = "signv4i64",
	[HCC_FUNCTION_IDX_ABSV2F16] = "absv2f16",
	[HCC_FUNCTION_IDX_ABSV2F32] = "absv2f32",
	[HCC_FUNCTION_IDX_ABSV2F64] = "absv2f64",
	[HCC_FUNCTION_IDX_ABSV2I8] = "absv2i8",
	[HCC_FUNCTION_IDX_ABSV2I16] = "absv2i16",
	[HCC_FUNCTION_IDX_ABSV2I32] = "absv2i32",
	[HCC_FUNCTION_IDX_ABSV2I64] = "absv2i64",
	[HCC_FUNCTION_IDX_ABSV3F16] = "absv3f16",
	[HCC_FUNCTION_IDX_ABSV3F32] = "absv3f32",
	[HCC_FUNCTION_IDX_ABSV3F64] = "absv3f64",
	[HCC_FUNCTION_IDX_ABSV3I8] = "absv3i8",
	[HCC_FUNCTION_IDX_ABSV3I16] = "absv3i16",
	[HCC_FUNCTION_IDX_ABSV3I32] = "absv3i32",
	[HCC_FUNCTION_IDX_ABSV3I64] = "absv3i64",
	[HCC_FUNCTION_IDX_ABSV4F16] = "absv4f16",
	[HCC_FUNCTION_IDX_ABSV4F32] = "absv4f32",
	[HCC_FUNCTION_IDX_ABSV4F64] = "absv4f64",
	[HCC_FUNCTION_IDX_ABSV4I8] = "absv4i8",
	[HCC_FUNCTION_IDX_ABSV4I16] = "absv4i16",
	[HCC_FUNCTION_IDX_ABSV4I32] = "absv4i32",
	[HCC_FUNCTION_IDX_ABSV4I64] = "absv4i64",
	[HCC_FUNCTION_IDX_BITANDV2I8] = "bitandv2i8",
	[HCC_FUNCTION_IDX_BITANDV2I16] = "bitandv2i16",
	[HCC_FUNCTION_IDX_BITANDV2I32] = "bitandv2i32",
	[HCC_FUNCTION_IDX_BITANDV2I64] = "bitandv2i64",
	[HCC_FUNCTION_IDX_BITANDV2U8] = "bitandv2u8",
	[HCC_FUNCTION_IDX_BITANDV2U16] = "bitandv2u16",
	[HCC_FUNCTION_IDX_BITANDV2U32] = "bitandv2u32",
	[HCC_FUNCTION_IDX_BITANDV2U64] = "bitandv2u64",
	[HCC_FUNCTION_IDX_BITANDV3I8] = "bitandv3i8",
	[HCC_FUNCTION_IDX_BITANDV3I16] = "bitandv3i16",
	[HCC_FUNCTION_IDX_BITANDV3I32] = "bitandv3i32",
	[HCC_FUNCTION_IDX_BITANDV3I64] = "bitandv3i64",
	[HCC_FUNCTION_IDX_BITANDV3U8] = "bitandv3u8",
	[HCC_FUNCTION_IDX_BITANDV3U16] = "bitandv3u16",
	[HCC_FUNCTION_IDX_BITANDV3U32] = "bitandv3u32",
	[HCC_FUNCTION_IDX_BITANDV3U64] = "bitandv3u64",
	[HCC_FUNCTION_IDX_BITANDV4I8] = "bitandv4i8",
	[HCC_FUNCTION_IDX_BITANDV4I16] = "bitandv4i16",
	[HCC_FUNCTION_IDX_BITANDV4I32] = "bitandv4i32",
	[HCC_FUNCTION_IDX_BITANDV4I64] = "bitandv4i64",
	[HCC_FUNCTION_IDX_BITANDV4U8] = "bitandv4u8",
	[HCC_FUNCTION_IDX_BITANDV4U16] = "bitandv4u16",
	[HCC_FUNCTION_IDX_BITANDV4U32] = "bitandv4u32",
	[HCC_FUNCTION_IDX_BITANDV4U64] = "bitandv4u64",
	[HCC_FUNCTION_IDX_BITORV2I8] = "bitorv2i8",
	[HCC_FUNCTION_IDX_BITORV2I16] = "bitorv2i16",
	[HCC_FUNCTION_IDX_BITORV2I32] = "bitorv2i32",
	[HCC_FUNCTION_IDX_BITORV2I64] = "bitorv2i64",
	[HCC_FUNCTION_IDX_BITORV2U8] = "bitorv2u8",
	[HCC_FUNCTION_IDX_BITORV2U16] = "bitorv2u16",
	[HCC_FUNCTION_IDX_BITORV2U32] = "bitorv2u32",
	[HCC_FUNCTION_IDX_BITORV2U64] = "bitorv2u64",
	[HCC_FUNCTION_IDX_BITORV3I8] = "bitorv3i8",
	[HCC_FUNCTION_IDX_BITORV3I16] = "bitorv3i16",
	[HCC_FUNCTION_IDX_BITORV3I32] = "bitorv3i32",
	[HCC_FUNCTION_IDX_BITORV3I64] = "bitorv3i64",
	[HCC_FUNCTION_IDX_BITORV3U8] = "bitorv3u8",
	[HCC_FUNCTION_IDX_BITORV3U16] = "bitorv3u16",
	[HCC_FUNCTION_IDX_BITORV3U32] = "bitorv3u32",
	[HCC_FUNCTION_IDX_BITORV3U64] = "bitorv3u64",
	[HCC_FUNCTION_IDX_BITORV4I8] = "bitorv4i8",
	[HCC_FUNCTION_IDX_BITORV4I16] = "bitorv4i16",
	[HCC_FUNCTION_IDX_BITORV4I32] = "bitorv4i32",
	[HCC_FUNCTION_IDX_BITORV4I64] = "bitorv4i64",
	[HCC_FUNCTION_IDX_BITORV4U8] = "bitorv4u8",
	[HCC_FUNCTION_IDX_BITORV4U16] = "bitorv4u16",
	[HCC_FUNCTION_IDX_BITORV4U32] = "bitorv4u32",
	[HCC_FUNCTION_IDX_BITORV4U64] = "bitorv4u64",
	[HCC_FUNCTION_IDX_BITXORV2I8] = "bitxorv2i8",
	[HCC_FUNCTION_IDX_BITXORV2I16] = "bitxorv2i16",
	[HCC_FUNCTION_IDX_BITXORV2I32] = "bitxorv2i32",
	[HCC_FUNCTION_IDX_BITXORV2I64] = "bitxorv2i64",
	[HCC_FUNCTION_IDX_BITXORV2U8] = "bitxorv2u8",
	[HCC_FUNCTION_IDX_BITXORV2U16] = "bitxorv2u16",
	[HCC_FUNCTION_IDX_BITXORV2U32] = "bitxorv2u32",
	[HCC_FUNCTION_IDX_BITXORV2U64] = "bitxorv2u64",
	[HCC_FUNCTION_IDX_BITXORV3I8] = "bitxorv3i8",
	[HCC_FUNCTION_IDX_BITXORV3I16] = "bitxorv3i16",
	[HCC_FUNCTION_IDX_BITXORV3I32] = "bitxorv3i32",
	[HCC_FUNCTION_IDX_BITXORV3I64] = "bitxorv3i64",
	[HCC_FUNCTION_IDX_BITXORV3U8] = "bitxorv3u8",
	[HCC_FUNCTION_IDX_BITXORV3U16] = "bitxorv3u16",
	[HCC_FUNCTION_IDX_BITXORV3U32] = "bitxorv3u32",
	[HCC_FUNCTION_IDX_BITXORV3U64] = "bitxorv3u64",
	[HCC_FUNCTION_IDX_BITXORV4I8] = "bitxorv4i8",
	[HCC_FUNCTION_IDX_BITXORV4I16] = "bitxorv4i16",
	[HCC_FUNCTION_IDX_BITXORV4I32] = "bitxorv4i32",
	[HCC_FUNCTION_IDX_BITXORV4I64] = "bitxorv4i64",
	[HCC_FUNCTION_IDX_BITXORV4U8] = "bitxorv4u8",
	[HCC_FUNCTION_IDX_BITXORV4U16] = "bitxorv4u16",
	[HCC_FUNCTION_IDX_BITXORV4U32] = "bitxorv4u32",
	[HCC_FUNCTION_IDX_BITXORV4U64] = "bitxorv4u64",
	[HCC_FUNCTION_IDX_BITSHLV2I8] = "bitshlv2i8",
	[HCC_FUNCTION_IDX_BITSHLV2I16] = "bitshlv2i16",
	[HCC_FUNCTION_IDX_BITSHLV2I32] = "bitshlv2i32",
	[HCC_FUNCTION_IDX_BITSHLV2I64] = "bitshlv2i64",
	[HCC_FUNCTION_IDX_BITSHLV2U8] = "bitshlv2u8",
	[HCC_FUNCTION_IDX_BITSHLV2U16] = "bitshlv2u16",
	[HCC_FUNCTION_IDX_BITSHLV2U32] = "bitshlv2u32",
	[HCC_FUNCTION_IDX_BITSHLV2U64] = "bitshlv2u64",
	[HCC_FUNCTION_IDX_BITSHLV3I8] = "bitshlv3i8",
	[HCC_FUNCTION_IDX_BITSHLV3I16] = "bitshlv3i16",
	[HCC_FUNCTION_IDX_BITSHLV3I32] = "bitshlv3i32",
	[HCC_FUNCTION_IDX_BITSHLV3I64] = "bitshlv3i64",
	[HCC_FUNCTION_IDX_BITSHLV3U8] = "bitshlv3u8",
	[HCC_FUNCTION_IDX_BITSHLV3U16] = "bitshlv3u16",
	[HCC_FUNCTION_IDX_BITSHLV3U32] = "bitshlv3u32",
	[HCC_FUNCTION_IDX_BITSHLV3U64] = "bitshlv3u64",
	[HCC_FUNCTION_IDX_BITSHLV4I8] = "bitshlv4i8",
	[HCC_FUNCTION_IDX_BITSHLV4I16] = "bitshlv4i16",
	[HCC_FUNCTION_IDX_BITSHLV4I32] = "bitshlv4i32",
	[HCC_FUNCTION_IDX_BITSHLV4I64] = "bitshlv4i64",
	[HCC_FUNCTION_IDX_BITSHLV4U8] = "bitshlv4u8",
	[HCC_FUNCTION_IDX_BITSHLV4U16] = "bitshlv4u16",
	[HCC_FUNCTION_IDX_BITSHLV4U32] = "bitshlv4u32",
	[HCC_FUNCTION_IDX_BITSHLV4U64] = "bitshlv4u64",
	[HCC_FUNCTION_IDX_BITSHRV2I8] = "bitshrv2i8",
	[HCC_FUNCTION_IDX_BITSHRV2I16] = "bitshrv2i16",
	[HCC_FUNCTION_IDX_BITSHRV2I32] = "bitshrv2i32",
	[HCC_FUNCTION_IDX_BITSHRV2I64] = "bitshrv2i64",
	[HCC_FUNCTION_IDX_BITSHRV2U8] = "bitshrv2u8",
	[HCC_FUNCTION_IDX_BITSHRV2U16] = "bitshrv2u16",
	[HCC_FUNCTION_IDX_BITSHRV2U32] = "bitshrv2u32",
	[HCC_FUNCTION_IDX_BITSHRV2U64] = "bitshrv2u64",
	[HCC_FUNCTION_IDX_BITSHRV3I8] = "bitshrv3i8",
	[HCC_FUNCTION_IDX_BITSHRV3I16] = "bitshrv3i16",
	[HCC_FUNCTION_IDX_BITSHRV3I32] = "bitshrv3i32",
	[HCC_FUNCTION_IDX_BITSHRV3I64] = "bitshrv3i64",
	[HCC_FUNCTION_IDX_BITSHRV3U8] = "bitshrv3u8",
	[HCC_FUNCTION_IDX_BITSHRV3U16] = "bitshrv3u16",
	[HCC_FUNCTION_IDX_BITSHRV3U32] = "bitshrv3u32",
	[HCC_FUNCTION_IDX_BITSHRV3U64] = "bitshrv3u64",
	[HCC_FUNCTION_IDX_BITSHRV4I8] = "bitshrv4i8",
	[HCC_FUNCTION_IDX_BITSHRV4I16] = "bitshrv4i16",
	[HCC_FUNCTION_IDX_BITSHRV4I32] = "bitshrv4i32",
	[HCC_FUNCTION_IDX_BITSHRV4I64] = "bitshrv4i64",
	[HCC_FUNCTION_IDX_BITSHRV4U8] = "bitshrv4u8",
	[HCC_FUNCTION_IDX_BITSHRV4U16] = "bitshrv4u16",
	[HCC_FUNCTION_IDX_BITSHRV4U32] = "bitshrv4u32",
	[HCC_FUNCTION_IDX_BITSHRV4U64] = "bitshrv4u64",
	[HCC_FUNCTION_IDX_BITNOTV2I8] = "bitnotv2i8",
	[HCC_FUNCTION_IDX_BITNOTV2I16] = "bitnotv2i16",
	[HCC_FUNCTION_IDX_BITNOTV2I32] = "bitnotv2i32",
	[HCC_FUNCTION_IDX_BITNOTV2I64] = "bitnotv2i64",
	[HCC_FUNCTION_IDX_BITNOTV2U8] = "bitnotv2u8",
	[HCC_FUNCTION_IDX_BITNOTV2U16] = "bitnotv2u16",
	[HCC_FUNCTION_IDX_BITNOTV2U32] = "bitnotv2u32",
	[HCC_FUNCTION_IDX_BITNOTV2U64] = "bitnotv2u64",
	[HCC_FUNCTION_IDX_BITNOTV3I8] = "bitnotv3i8",
	[HCC_FUNCTION_IDX_BITNOTV3I16] = "bitnotv3i16",
	[HCC_FUNCTION_IDX_BITNOTV3I32] = "bitnotv3i32",
	[HCC_FUNCTION_IDX_BITNOTV3I64] = "bitnotv3i64",
	[HCC_FUNCTION_IDX_BITNOTV3U8] = "bitnotv3u8",
	[HCC_FUNCTION_IDX_BITNOTV3U16] = "bitnotv3u16",
	[HCC_FUNCTION_IDX_BITNOTV3U32] = "bitnotv3u32",
	[HCC_FUNCTION_IDX_BITNOTV3U64] = "bitnotv3u64",
	[HCC_FUNCTION_IDX_BITNOTV4I8] = "bitnotv4i8",
	[HCC_FUNCTION_IDX_BITNOTV4I16] = "bitnotv4i16",
	[HCC_FUNCTION_IDX_BITNOTV4I32] = "bitnotv4i32",
	[HCC_FUNCTION_IDX_BITNOTV4I64] = "bitnotv4i64",
	[HCC_FUNCTION_IDX_BITNOTV4U8] = "bitnotv4u8",
	[HCC_FUNCTION_IDX_BITNOTV4U16] = "bitnotv4u16",
	[HCC_FUNCTION_IDX_BITNOTV4U32] = "bitnotv4u32",
	[HCC_FUNCTION_IDX_BITNOTV4U64] = "bitnotv4u64",
	[HCC_FUNCTION_IDX_FMAV2F16] = "fmav2f16",
	[HCC_FUNCTION_IDX_FMAV2F32] = "fmav2f32",
	[HCC_FUNCTION_IDX_FMAV2F64] = "fmav2f64",
	[HCC_FUNCTION_IDX_FMAV3F16] = "fmav3f16",
	[HCC_FUNCTION_IDX_FMAV3F32] = "fmav3f32",
	[HCC_FUNCTION_IDX_FMAV3F64] = "fmav3f64",
	[HCC_FUNCTION_IDX_FMAV4F16] = "fmav4f16",
	[HCC_FUNCTION_IDX_FMAV4F32] = "fmav4f32",
	[HCC_FUNCTION_IDX_FMAV4F64] = "fmav4f64",
	[HCC_FUNCTION_IDX_FLOORV2F16] = "floorv2f16",
	[HCC_FUNCTION_IDX_FLOORV2F32] = "floorv2f32",
	[HCC_FUNCTION_IDX_FLOORV2F64] = "floorv2f64",
	[HCC_FUNCTION_IDX_FLOORV3F16] = "floorv3f16",
	[HCC_FUNCTION_IDX_FLOORV3F32] = "floorv3f32",
	[HCC_FUNCTION_IDX_FLOORV3F64] = "floorv3f64",
	[HCC_FUNCTION_IDX_FLOORV4F16] = "floorv4f16",
	[HCC_FUNCTION_IDX_FLOORV4F32] = "floorv4f32",
	[HCC_FUNCTION_IDX_FLOORV4F64] = "floorv4f64",
	[HCC_FUNCTION_IDX_CEILV2F16] = "ceilv2f16",
	[HCC_FUNCTION_IDX_CEILV2F32] = "ceilv2f32",
	[HCC_FUNCTION_IDX_CEILV2F64] = "ceilv2f64",
	[HCC_FUNCTION_IDX_CEILV3F16] = "ceilv3f16",
	[HCC_FUNCTION_IDX_CEILV3F32] = "ceilv3f32",
	[HCC_FUNCTION_IDX_CEILV3F64] = "ceilv3f64",
	[HCC_FUNCTION_IDX_CEILV4F16] = "ceilv4f16",
	[HCC_FUNCTION_IDX_CEILV4F32] = "ceilv4f32",
	[HCC_FUNCTION_IDX_CEILV4F64] = "ceilv4f64",
	[HCC_FUNCTION_IDX_ROUNDV2F16] = "roundv2f16",
	[HCC_FUNCTION_IDX_ROUNDV2F32] = "roundv2f32",
	[HCC_FUNCTION_IDX_ROUNDV2F64] = "roundv2f64",
	[HCC_FUNCTION_IDX_ROUNDV3F16] = "roundv3f16",
	[HCC_FUNCTION_IDX_ROUNDV3F32] = "roundv3f32",
	[HCC_FUNCTION_IDX_ROUNDV3F64] = "roundv3f64",
	[HCC_FUNCTION_IDX_ROUNDV4F16] = "roundv4f16",
	[HCC_FUNCTION_IDX_ROUNDV4F32] = "roundv4f32",
	[HCC_FUNCTION_IDX_ROUNDV4F64] = "roundv4f64",
	[HCC_FUNCTION_IDX_TRUNCV2F16] = "truncv2f16",
	[HCC_FUNCTION_IDX_TRUNCV2F32] = "truncv2f32",
	[HCC_FUNCTION_IDX_TRUNCV2F64] = "truncv2f64",
	[HCC_FUNCTION_IDX_TRUNCV3F16] = "truncv3f16",
	[HCC_FUNCTION_IDX_TRUNCV3F32] = "truncv3f32",
	[HCC_FUNCTION_IDX_TRUNCV3F64] = "truncv3f64",
	[HCC_FUNCTION_IDX_TRUNCV4F16] = "truncv4f16",
	[HCC_FUNCTION_IDX_TRUNCV4F32] = "truncv4f32",
	[HCC_FUNCTION_IDX_TRUNCV4F64] = "truncv4f64",
	[HCC_FUNCTION_IDX_FRACTV2F16] = "fractv2f16",
	[HCC_FUNCTION_IDX_FRACTV2F32] = "fractv2f32",
	[HCC_FUNCTION_IDX_FRACTV2F64] = "fractv2f64",
	[HCC_FUNCTION_IDX_FRACTV3F16] = "fractv3f16",
	[HCC_FUNCTION_IDX_FRACTV3F32] = "fractv3f32",
	[HCC_FUNCTION_IDX_FRACTV3F64] = "fractv3f64",
	[HCC_FUNCTION_IDX_FRACTV4F16] = "fractv4f16",
	[HCC_FUNCTION_IDX_FRACTV4F32] = "fractv4f32",
	[HCC_FUNCTION_IDX_FRACTV4F64] = "fractv4f64",
	[HCC_FUNCTION_IDX_RADIANSV2F16] = "radiansv2f16",
	[HCC_FUNCTION_IDX_RADIANSV2F32] = "radiansv2f32",
	[HCC_FUNCTION_IDX_RADIANSV2F64] = "radiansv2f64",
	[HCC_FUNCTION_IDX_RADIANSV3F16] = "radiansv3f16",
	[HCC_FUNCTION_IDX_RADIANSV3F32] = "radiansv3f32",
	[HCC_FUNCTION_IDX_RADIANSV3F64] = "radiansv3f64",
	[HCC_FUNCTION_IDX_RADIANSV4F16] = "radiansv4f16",
	[HCC_FUNCTION_IDX_RADIANSV4F32] = "radiansv4f32",
	[HCC_FUNCTION_IDX_RADIANSV4F64] = "radiansv4f64",
	[HCC_FUNCTION_IDX_DEGREESV2F16] = "degreesv2f16",
	[HCC_FUNCTION_IDX_DEGREESV2F32] = "degreesv2f32",
	[HCC_FUNCTION_IDX_DEGREESV2F64] = "degreesv2f64",
	[HCC_FUNCTION_IDX_DEGREESV3F16] = "degreesv3f16",
	[HCC_FUNCTION_IDX_DEGREESV3F32] = "degreesv3f32",
	[HCC_FUNCTION_IDX_DEGREESV3F64] = "degreesv3f64",
	[HCC_FUNCTION_IDX_DEGREESV4F16] = "degreesv4f16",
	[HCC_FUNCTION_IDX_DEGREESV4F32] = "degreesv4f32",
	[HCC_FUNCTION_IDX_DEGREESV4F64] = "degreesv4f64",
	[HCC_FUNCTION_IDX_STEPV2F16] = "stepv2f16",
	[HCC_FUNCTION_IDX_STEPV2F32] = "stepv2f32",
	[HCC_FUNCTION_IDX_STEPV2F64] = "stepv2f64",
	[HCC_FUNCTION_IDX_STEPV3F16] = "stepv3f16",
	[HCC_FUNCTION_IDX_STEPV3F32] = "stepv3f32",
	[HCC_FUNCTION_IDX_STEPV3F64] = "stepv3f64",
	[HCC_FUNCTION_IDX_STEPV4F16] = "stepv4f16",
	[HCC_FUNCTION_IDX_STEPV4F32] = "stepv4f32",
	[HCC_FUNCTION_IDX_STEPV4F64] = "stepv4f64",
	[HCC_FUNCTION_IDX_SMOOTHSTEPV2F16] = "smoothstepv2f16",
	[HCC_FUNCTION_IDX_SMOOTHSTEPV2F32] = "smoothstepv2f32",
	[HCC_FUNCTION_IDX_SMOOTHSTEPV2F64] = "smoothstepv2f64",
	[HCC_FUNCTION_IDX_SMOOTHSTEPV3F16] = "smoothstepv3f16",
	[HCC_FUNCTION_IDX_SMOOTHSTEPV3F32] = "smoothstepv3f32",
	[HCC_FUNCTION_IDX_SMOOTHSTEPV3F64] = "smoothstepv3f64",
	[HCC_FUNCTION_IDX_SMOOTHSTEPV4F16] = "smoothstepv4f16",
	[HCC_FUNCTION_IDX_SMOOTHSTEPV4F32] = "smoothstepv4f32",
	[HCC_FUNCTION_IDX_SMOOTHSTEPV4F64] = "smoothstepv4f64",
	[HCC_FUNCTION_IDX_BITSTOV2F16] = "bitstov2f16",
	[HCC_FUNCTION_IDX_BITSTOV2F32] = "bitstov2f32",
	[HCC_FUNCTION_IDX_BITSTOV2F64] = "bitstov2f64",
	[HCC_FUNCTION_IDX_BITSTOV3F16] = "bitstov3f16",
	[HCC_FUNCTION_IDX_BITSTOV3F32] = "bitstov3f32",
	[HCC_FUNCTION_IDX_BITSTOV3F64] = "bitstov3f64",
	[HCC_FUNCTION_IDX_BITSTOV4F16] = "bitstov4f16",
	[HCC_FUNCTION_IDX_BITSTOV4F32] = "bitstov4f32",
	[HCC_FUNCTION_IDX_BITSTOV4F64] = "bitstov4f64",
	[HCC_FUNCTION_IDX_BITSFROMV2F16] = "bitsfromv2f16",
	[HCC_FUNCTION_IDX_BITSFROMV2F32] = "bitsfromv2f32",
	[HCC_FUNCTION_IDX_BITSFROMV2F64] = "bitsfromv2f64",
	[HCC_FUNCTION_IDX_BITSFROMV3F16] = "bitsfromv3f16",
	[HCC_FUNCTION_IDX_BITSFROMV3F32] = "bitsfromv3f32",
	[HCC_FUNCTION_IDX_BITSFROMV3F64] = "bitsfromv3f64",
	[HCC_FUNCTION_IDX_BITSFROMV4F16] = "bitsfromv4f16",
	[HCC_FUNCTION_IDX_BITSFROMV4F32] = "bitsfromv4f32",
	[HCC_FUNCTION_IDX_BITSFROMV4F64] = "bitsfromv4f64",
	[HCC_FUNCTION_IDX_SINV2F16] = "sinv2f16",
	[HCC_FUNCTION_IDX_SINV2F32] = "sinv2f32",
	[HCC_FUNCTION_IDX_SINV2F64] = "sinv2f64",
	[HCC_FUNCTION_IDX_SINV3F16] = "sinv3f16",
	[HCC_FUNCTION_IDX_SINV3F32] = "sinv3f32",
	[HCC_FUNCTION_IDX_SINV3F64] = "sinv3f64",
	[HCC_FUNCTION_IDX_SINV4F16] = "sinv4f16",
	[HCC_FUNCTION_IDX_SINV4F32] = "sinv4f32",
	[HCC_FUNCTION_IDX_SINV4F64] = "sinv4f64",
	[HCC_FUNCTION_IDX_COSV2F16] = "cosv2f16",
	[HCC_FUNCTION_IDX_COSV2F32] = "cosv2f32",
	[HCC_FUNCTION_IDX_COSV2F64] = "cosv2f64",
	[HCC_FUNCTION_IDX_COSV3F16] = "cosv3f16",
	[HCC_FUNCTION_IDX_COSV3F32] = "cosv3f32",
	[HCC_FUNCTION_IDX_COSV3F64] = "cosv3f64",
	[HCC_FUNCTION_IDX_COSV4F16] = "cosv4f16",
	[HCC_FUNCTION_IDX_COSV4F32] = "cosv4f32",
	[HCC_FUNCTION_IDX_COSV4F64] = "cosv4f64",
	[HCC_FUNCTION_IDX_TANV2F16] = "tanv2f16",
	[HCC_FUNCTION_IDX_TANV2F32] = "tanv2f32",
	[HCC_FUNCTION_IDX_TANV2F64] = "tanv2f64",
	[HCC_FUNCTION_IDX_TANV3F16] = "tanv3f16",
	[HCC_FUNCTION_IDX_TANV3F32] = "tanv3f32",
	[HCC_FUNCTION_IDX_TANV3F64] = "tanv3f64",
	[HCC_FUNCTION_IDX_TANV4F16] = "tanv4f16",
	[HCC_FUNCTION_IDX_TANV4F32] = "tanv4f32",
	[HCC_FUNCTION_IDX_TANV4F64] = "tanv4f64",
	[HCC_FUNCTION_IDX_ASINV2F16] = "asinv2f16",
	[HCC_FUNCTION_IDX_ASINV2F32] = "asinv2f32",
	[HCC_FUNCTION_IDX_ASINV2F64] = "asinv2f64",
	[HCC_FUNCTION_IDX_ASINV3F16] = "asinv3f16",
	[HCC_FUNCTION_IDX_ASINV3F32] = "asinv3f32",
	[HCC_FUNCTION_IDX_ASINV3F64] = "asinv3f64",
	[HCC_FUNCTION_IDX_ASINV4F16] = "asinv4f16",
	[HCC_FUNCTION_IDX_ASINV4F32] = "asinv4f32",
	[HCC_FUNCTION_IDX_ASINV4F64] = "asinv4f64",
	[HCC_FUNCTION_IDX_ACOSV2F16] = "acosv2f16",
	[HCC_FUNCTION_IDX_ACOSV2F32] = "acosv2f32",
	[HCC_FUNCTION_IDX_ACOSV2F64] = "acosv2f64",
	[HCC_FUNCTION_IDX_ACOSV3F16] = "acosv3f16",
	[HCC_FUNCTION_IDX_ACOSV3F32] = "acosv3f32",
	[HCC_FUNCTION_IDX_ACOSV3F64] = "acosv3f64",
	[HCC_FUNCTION_IDX_ACOSV4F16] = "acosv4f16",
	[HCC_FUNCTION_IDX_ACOSV4F32] = "acosv4f32",
	[HCC_FUNCTION_IDX_ACOSV4F64] = "acosv4f64",
	[HCC_FUNCTION_IDX_ATANV2F16] = "atanv2f16",
	[HCC_FUNCTION_IDX_ATANV2F32] = "atanv2f32",
	[HCC_FUNCTION_IDX_ATANV2F64] = "atanv2f64",
	[HCC_FUNCTION_IDX_ATANV3F16] = "atanv3f16",
	[HCC_FUNCTION_IDX_ATANV3F32] = "atanv3f32",
	[HCC_FUNCTION_IDX_ATANV3F64] = "atanv3f64",
	[HCC_FUNCTION_IDX_ATANV4F16] = "atanv4f16",
	[HCC_FUNCTION_IDX_ATANV4F32] = "atanv4f32",
	[HCC_FUNCTION_IDX_ATANV4F64] = "atanv4f64",
	[HCC_FUNCTION_IDX_SINHV2F16] = "sinhv2f16",
	[HCC_FUNCTION_IDX_SINHV2F32] = "sinhv2f32",
	[HCC_FUNCTION_IDX_SINHV2F64] = "sinhv2f64",
	[HCC_FUNCTION_IDX_SINHV3F16] = "sinhv3f16",
	[HCC_FUNCTION_IDX_SINHV3F32] = "sinhv3f32",
	[HCC_FUNCTION_IDX_SINHV3F64] = "sinhv3f64",
	[HCC_FUNCTION_IDX_SINHV4F16] = "sinhv4f16",
	[HCC_FUNCTION_IDX_SINHV4F32] = "sinhv4f32",
	[HCC_FUNCTION_IDX_SINHV4F64] = "sinhv4f64",
	[HCC_FUNCTION_IDX_COSHV2F16] = "coshv2f16",
	[HCC_FUNCTION_IDX_COSHV2F32] = "coshv2f32",
	[HCC_FUNCTION_IDX_COSHV2F64] = "coshv2f64",
	[HCC_FUNCTION_IDX_COSHV3F16] = "coshv3f16",
	[HCC_FUNCTION_IDX_COSHV3F32] = "coshv3f32",
	[HCC_FUNCTION_IDX_COSHV3F64] = "coshv3f64",
	[HCC_FUNCTION_IDX_COSHV4F16] = "coshv4f16",
	[HCC_FUNCTION_IDX_COSHV4F32] = "coshv4f32",
	[HCC_FUNCTION_IDX_COSHV4F64] = "coshv4f64",
	[HCC_FUNCTION_IDX_TANHV2F16] = "tanhv2f16",
	[HCC_FUNCTION_IDX_TANHV2F32] = "tanhv2f32",
	[HCC_FUNCTION_IDX_TANHV2F64] = "tanhv2f64",
	[HCC_FUNCTION_IDX_TANHV3F16] = "tanhv3f16",
	[HCC_FUNCTION_IDX_TANHV3F32] = "tanhv3f32",
	[HCC_FUNCTION_IDX_TANHV3F64] = "tanhv3f64",
	[HCC_FUNCTION_IDX_TANHV4F16] = "tanhv4f16",
	[HCC_FUNCTION_IDX_TANHV4F32] = "tanhv4f32",
	[HCC_FUNCTION_IDX_TANHV4F64] = "tanhv4f64",
	[HCC_FUNCTION_IDX_ASINHV2F16] = "asinhv2f16",
	[HCC_FUNCTION_IDX_ASINHV2F32] = "asinhv2f32",
	[HCC_FUNCTION_IDX_ASINHV2F64] = "asinhv2f64",
	[HCC_FUNCTION_IDX_ASINHV3F16] = "asinhv3f16",
	[HCC_FUNCTION_IDX_ASINHV3F32] = "asinhv3f32",
	[HCC_FUNCTION_IDX_ASINHV3F64] = "asinhv3f64",
	[HCC_FUNCTION_IDX_ASINHV4F16] = "asinhv4f16",
	[HCC_FUNCTION_IDX_ASINHV4F32] = "asinhv4f32",
	[HCC_FUNCTION_IDX_ASINHV4F64] = "asinhv4f64",
	[HCC_FUNCTION_IDX_ACOSHV2F16] = "acoshv2f16",
	[HCC_FUNCTION_IDX_ACOSHV2F32] = "acoshv2f32",
	[HCC_FUNCTION_IDX_ACOSHV2F64] = "acoshv2f64",
	[HCC_FUNCTION_IDX_ACOSHV3F16] = "acoshv3f16",
	[HCC_FUNCTION_IDX_ACOSHV3F32] = "acoshv3f32",
	[HCC_FUNCTION_IDX_ACOSHV3F64] = "acoshv3f64",
	[HCC_FUNCTION_IDX_ACOSHV4F16] = "acoshv4f16",
	[HCC_FUNCTION_IDX_ACOSHV4F32] = "acoshv4f32",
	[HCC_FUNCTION_IDX_ACOSHV4F64] = "acoshv4f64",
	[HCC_FUNCTION_IDX_ATANHV2F16] = "atanhv2f16",
	[HCC_FUNCTION_IDX_ATANHV2F32] = "atanhv2f32",
	[HCC_FUNCTION_IDX_ATANHV2F64] = "atanhv2f64",
	[HCC_FUNCTION_IDX_ATANHV3F16] = "atanhv3f16",
	[HCC_FUNCTION_IDX_ATANHV3F32] = "atanhv3f32",
	[HCC_FUNCTION_IDX_ATANHV3F64] = "atanhv3f64",
	[HCC_FUNCTION_IDX_ATANHV4F16] = "atanhv4f16",
	[HCC_FUNCTION_IDX_ATANHV4F32] = "atanhv4f32",
	[HCC_FUNCTION_IDX_ATANHV4F64] = "atanhv4f64",
	[HCC_FUNCTION_IDX_ATAN2V2F16] = "atan2v2f16",
	[HCC_FUNCTION_IDX_ATAN2V2F32] = "atan2v2f32",
	[HCC_FUNCTION_IDX_ATAN2V2F64] = "atan2v2f64",
	[HCC_FUNCTION_IDX_ATAN2V3F16] = "atan2v3f16",
	[HCC_FUNCTION_IDX_ATAN2V3F32] = "atan2v3f32",
	[HCC_FUNCTION_IDX_ATAN2V3F64] = "atan2v3f64",
	[HCC_FUNCTION_IDX_ATAN2V4F16] = "atan2v4f16",
	[HCC_FUNCTION_IDX_ATAN2V4F32] = "atan2v4f32",
	[HCC_FUNCTION_IDX_ATAN2V4F64] = "atan2v4f64",
	[HCC_FUNCTION_IDX_POWV2F16] = "powv2f16",
	[HCC_FUNCTION_IDX_POWV2F32] = "powv2f32",
	[HCC_FUNCTION_IDX_POWV2F64] = "powv2f64",
	[HCC_FUNCTION_IDX_POWV3F16] = "powv3f16",
	[HCC_FUNCTION_IDX_POWV3F32] = "powv3f32",
	[HCC_FUNCTION_IDX_POWV3F64] = "powv3f64",
	[HCC_FUNCTION_IDX_POWV4F16] = "powv4f16",
	[HCC_FUNCTION_IDX_POWV4F32] = "powv4f32",
	[HCC_FUNCTION_IDX_POWV4F64] = "powv4f64",
	[HCC_FUNCTION_IDX_EXPV2F16] = "expv2f16",
	[HCC_FUNCTION_IDX_EXPV2F32] = "expv2f32",
	[HCC_FUNCTION_IDX_EXPV2F64] = "expv2f64",
	[HCC_FUNCTION_IDX_EXPV3F16] = "expv3f16",
	[HCC_FUNCTION_IDX_EXPV3F32] = "expv3f32",
	[HCC_FUNCTION_IDX_EXPV3F64] = "expv3f64",
	[HCC_FUNCTION_IDX_EXPV4F16] = "expv4f16",
	[HCC_FUNCTION_IDX_EXPV4F32] = "expv4f32",
	[HCC_FUNCTION_IDX_EXPV4F64] = "expv4f64",
	[HCC_FUNCTION_IDX_LOGV2F16] = "logv2f16",
	[HCC_FUNCTION_IDX_LOGV2F32] = "logv2f32",
	[HCC_FUNCTION_IDX_LOGV2F64] = "logv2f64",
	[HCC_FUNCTION_IDX_LOGV3F16] = "logv3f16",
	[HCC_FUNCTION_IDX_LOGV3F32] = "logv3f32",
	[HCC_FUNCTION_IDX_LOGV3F64] = "logv3f64",
	[HCC_FUNCTION_IDX_LOGV4F16] = "logv4f16",
	[HCC_FUNCTION_IDX_LOGV4F32] = "logv4f32",
	[HCC_FUNCTION_IDX_LOGV4F64] = "logv4f64",
	[HCC_FUNCTION_IDX_EXP2V2F16] = "exp2v2f16",
	[HCC_FUNCTION_IDX_EXP2V2F32] = "exp2v2f32",
	[HCC_FUNCTION_IDX_EXP2V2F64] = "exp2v2f64",
	[HCC_FUNCTION_IDX_EXP2V3F16] = "exp2v3f16",
	[HCC_FUNCTION_IDX_EXP2V3F32] = "exp2v3f32",
	[HCC_FUNCTION_IDX_EXP2V3F64] = "exp2v3f64",
	[HCC_FUNCTION_IDX_EXP2V4F16] = "exp2v4f16",
	[HCC_FUNCTION_IDX_EXP2V4F32] = "exp2v4f32",
	[HCC_FUNCTION_IDX_EXP2V4F64] = "exp2v4f64",
	[HCC_FUNCTION_IDX_LOG2V2F16] = "log2v2f16",
	[HCC_FUNCTION_IDX_LOG2V2F32] = "log2v2f32",
	[HCC_FUNCTION_IDX_LOG2V2F64] = "log2v2f64",
	[HCC_FUNCTION_IDX_LOG2V3F16] = "log2v3f16",
	[HCC_FUNCTION_IDX_LOG2V3F32] = "log2v3f32",
	[HCC_FUNCTION_IDX_LOG2V3F64] = "log2v3f64",
	[HCC_FUNCTION_IDX_LOG2V4F16] = "log2v4f16",
	[HCC_FUNCTION_IDX_LOG2V4F32] = "log2v4f32",
	[HCC_FUNCTION_IDX_LOG2V4F64] = "log2v4f64",
	[HCC_FUNCTION_IDX_SQRTV2F16] = "sqrtv2f16",
	[HCC_FUNCTION_IDX_SQRTV2F32] = "sqrtv2f32",
	[HCC_FUNCTION_IDX_SQRTV2F64] = "sqrtv2f64",
	[HCC_FUNCTION_IDX_SQRTV3F16] = "sqrtv3f16",
	[HCC_FUNCTION_IDX_SQRTV3F32] = "sqrtv3f32",
	[HCC_FUNCTION_IDX_SQRTV3F64] = "sqrtv3f64",
	[HCC_FUNCTION_IDX_SQRTV4F16] = "sqrtv4f16",
	[HCC_FUNCTION_IDX_SQRTV4F32] = "sqrtv4f32",
	[HCC_FUNCTION_IDX_SQRTV4F64] = "sqrtv4f64",
	[HCC_FUNCTION_IDX_RSQRTV2F16] = "rsqrtv2f16",
	[HCC_FUNCTION_IDX_RSQRTV2F32] = "rsqrtv2f32",
	[HCC_FUNCTION_IDX_RSQRTV2F64] = "rsqrtv2f64",
	[HCC_FUNCTION_IDX_RSQRTV3F16] = "rsqrtv3f16",
	[HCC_FUNCTION_IDX_RSQRTV3F32] = "rsqrtv3f32",
	[HCC_FUNCTION_IDX_RSQRTV3F64] = "rsqrtv3f64",
	[HCC_FUNCTION_IDX_RSQRTV4F16] = "rsqrtv4f16",
	[HCC_FUNCTION_IDX_RSQRTV4F32] = "rsqrtv4f32",
	[HCC_FUNCTION_IDX_RSQRTV4F64] = "rsqrtv4f64",
	[HCC_FUNCTION_IDX_ISINFV2F16] = "isinfv2f16",
	[HCC_FUNCTION_IDX_ISINFV2F32] = "isinfv2f32",
	[HCC_FUNCTION_IDX_ISINFV2F64] = "isinfv2f64",
	[HCC_FUNCTION_IDX_ISINFV3F16] = "isinfv3f16",
	[HCC_FUNCTION_IDX_ISINFV3F32] = "isinfv3f32",
	[HCC_FUNCTION_IDX_ISINFV3F64] = "isinfv3f64",
	[HCC_FUNCTION_IDX_ISINFV4F16] = "isinfv4f16",
	[HCC_FUNCTION_IDX_ISINFV4F32] = "isinfv4f32",
	[HCC_FUNCTION_IDX_ISINFV4F64] = "isinfv4f64",
	[HCC_FUNCTION_IDX_ISNANV2F16] = "isnanv2f16",
	[HCC_FUNCTION_IDX_ISNANV2F32] = "isnanv2f32",
	[HCC_FUNCTION_IDX_ISNANV2F64] = "isnanv2f64",
	[HCC_FUNCTION_IDX_ISNANV3F16] = "isnanv3f16",
	[HCC_FUNCTION_IDX_ISNANV3F32] = "isnanv3f32",
	[HCC_FUNCTION_IDX_ISNANV3F64] = "isnanv3f64",
	[HCC_FUNCTION_IDX_ISNANV4F16] = "isnanv4f16",
	[HCC_FUNCTION_IDX_ISNANV4F32] = "isnanv4f32",
	[HCC_FUNCTION_IDX_ISNANV4F64] = "isnanv4f64",
	[HCC_FUNCTION_IDX_LERPV2F16] = "lerpv2f16",
	[HCC_FUNCTION_IDX_LERPV2F32] = "lerpv2f32",
	[HCC_FUNCTION_IDX_LERPV2F64] = "lerpv2f64",
	[HCC_FUNCTION_IDX_LERPV3F16] = "lerpv3f16",
	[HCC_FUNCTION_IDX_LERPV3F32] = "lerpv3f32",
	[HCC_FUNCTION_IDX_LERPV3F64] = "lerpv3f64",
	[HCC_FUNCTION_IDX_LERPV4F16] = "lerpv4f16",
	[HCC_FUNCTION_IDX_LERPV4F32] = "lerpv4f32",
	[HCC_FUNCTION_IDX_LERPV4F64] = "lerpv4f64",
	[HCC_FUNCTION_IDX_DOTV2F16] = "dotv2f16",
	[HCC_FUNCTION_IDX_DOTV2F32] = "dotv2f32",
	[HCC_FUNCTION_IDX_DOTV2F64] = "dotv2f64",
	[HCC_FUNCTION_IDX_DOTV3F16] = "dotv3f16",
	[HCC_FUNCTION_IDX_DOTV3F32] = "dotv3f32",
	[HCC_FUNCTION_IDX_DOTV3F64] = "dotv3f64",
	[HCC_FUNCTION_IDX_DOTV4F16] = "dotv4f16",
	[HCC_FUNCTION_IDX_DOTV4F32] = "dotv4f32",
	[HCC_FUNCTION_IDX_DOTV4F64] = "dotv4f64",
	[HCC_FUNCTION_IDX_LENV2F16] = "lenv2f16",
	[HCC_FUNCTION_IDX_LENV2F32] = "lenv2f32",
	[HCC_FUNCTION_IDX_LENV2F64] = "lenv2f64",
	[HCC_FUNCTION_IDX_LENV3F16] = "lenv3f16",
	[HCC_FUNCTION_IDX_LENV3F32] = "lenv3f32",
	[HCC_FUNCTION_IDX_LENV3F64] = "lenv3f64",
	[HCC_FUNCTION_IDX_LENV4F16] = "lenv4f16",
	[HCC_FUNCTION_IDX_LENV4F32] = "lenv4f32",
	[HCC_FUNCTION_IDX_LENV4F64] = "lenv4f64",
	[HCC_FUNCTION_IDX_NORMV2F16] = "normv2f16",
	[HCC_FUNCTION_IDX_NORMV2F32] = "normv2f32",
	[HCC_FUNCTION_IDX_NORMV2F64] = "normv2f64",
	[HCC_FUNCTION_IDX_NORMV3F16] = "normv3f16",
	[HCC_FUNCTION_IDX_NORMV3F32] = "normv3f32",
	[HCC_FUNCTION_IDX_NORMV3F64] = "normv3f64",
	[HCC_FUNCTION_IDX_NORMV4F16] = "normv4f16",
	[HCC_FUNCTION_IDX_NORMV4F32] = "normv4f32",
	[HCC_FUNCTION_IDX_NORMV4F64] = "normv4f64",
	[HCC_FUNCTION_IDX_REFLECTV2F16] = "reflectv2f16",
	[HCC_FUNCTION_IDX_REFLECTV2F32] = "reflectv2f32",
	[HCC_FUNCTION_IDX_REFLECTV2F64] = "reflectv2f64",
	[HCC_FUNCTION_IDX_REFLECTV3F16] = "reflectv3f16",
	[HCC_FUNCTION_IDX_REFLECTV3F32] = "reflectv3f32",
	[HCC_FUNCTION_IDX_REFLECTV3F64] = "reflectv3f64",
	[HCC_FUNCTION_IDX_REFLECTV4F16] = "reflectv4f16",
	[HCC_FUNCTION_IDX_REFLECTV4F32] = "reflectv4f32",
	[HCC_FUNCTION_IDX_REFLECTV4F64] = "reflectv4f64",
	[HCC_FUNCTION_IDX_REFRACTV2F16] = "refractv2f16",
	[HCC_FUNCTION_IDX_REFRACTV2F32] = "refractv2f32",
	[HCC_FUNCTION_IDX_REFRACTV2F64] = "refractv2f64",
	[HCC_FUNCTION_IDX_REFRACTV3F16] = "refractv3f16",
	[HCC_FUNCTION_IDX_REFRACTV3F32] = "refractv3f32",
	[HCC_FUNCTION_IDX_REFRACTV3F64] = "refractv3f64",
	[HCC_FUNCTION_IDX_REFRACTV4F16] = "refractv4f16",
	[HCC_FUNCTION_IDX_REFRACTV4F32] = "refractv4f32",
	[HCC_FUNCTION_IDX_REFRACTV4F64] = "refractv4f64",
	[HCC_FUNCTION_IDX_PACKF16X2V2F32] = "packf16x2v2f32",
	[HCC_FUNCTION_IDX_UNPACKF16X2V2F32] = "unpackf16x2v2f32",
	[HCC_FUNCTION_IDX_PACKU16X2V2F32] = "packu16x2v2f32",
	[HCC_FUNCTION_IDX_UNPACKU16X2V2F32] = "unpacku16x2v2f32",
	[HCC_FUNCTION_IDX_PACKS16X2V2F32] = "packs16x2v2f32",
	[HCC_FUNCTION_IDX_UNPACKS16X2V2F32] = "unpacks16x2v2f32",
	[HCC_FUNCTION_IDX_PACKU8X4V4F32] = "packu8x4v4f32",
	[HCC_FUNCTION_IDX_UNPACKU8X4V4F32] = "unpacku8x4v4f32",
	[HCC_FUNCTION_IDX_PACKS8X4V4F32] = "packs8x4v4f32",
	[HCC_FUNCTION_IDX_UNPACKS8X4V4F32] = "unpacks8x4v4f32",

	//
	// libhccstd/math.h - matrix
	//
	[HCC_FUNCTION_IDX_MULM22M22F32] = "mulm22m22f32",
	[HCC_FUNCTION_IDX_MULM22M22F64] = "mulm22m22f64",
	[HCC_FUNCTION_IDX_MULM23M32F32] = "mulm23m32f32",
	[HCC_FUNCTION_IDX_MULM23M32F64] = "mulm23m32f64",
	[HCC_FUNCTION_IDX_MULM24M42F32] = "mulm24m42f32",
	[HCC_FUNCTION_IDX_MULM24M42F64] = "mulm24m42f64",
	[HCC_FUNCTION_IDX_MULM32M23F32] = "mulm32m23f32",
	[HCC_FUNCTION_IDX_MULM32M23F64] = "mulm32m23f64",
	[HCC_FUNCTION_IDX_MULM33M33F32] = "mulm33m33f32",
	[HCC_FUNCTION_IDX_MULM33M33F64] = "mulm33m33f64",
	[HCC_FUNCTION_IDX_MULM34M43F32] = "mulm34m43f32",
	[HCC_FUNCTION_IDX_MULM34M43F64] = "mulm34m43f64",
	[HCC_FUNCTION_IDX_MULM42M24F32] = "mulm42m24f32",
	[HCC_FUNCTION_IDX_MULM42M24F64] = "mulm42m24f64",
	[HCC_FUNCTION_IDX_MULM43M34F32] = "mulm43m34f32",
	[HCC_FUNCTION_IDX_MULM43M34F64] = "mulm43m34f64",
	[HCC_FUNCTION_IDX_MULM44M44F32] = "mulm44m44f32",
	[HCC_FUNCTION_IDX_MULM44M44F64] = "mulm44m44f64",
	[HCC_FUNCTION_IDX_MULSM22F32] = "mulsm22f32",
	[HCC_FUNCTION_IDX_MULSM22F64] = "mulsm22f64",
	[HCC_FUNCTION_IDX_MULSM23F32] = "mulsm23f32",
	[HCC_FUNCTION_IDX_MULSM23F64] = "mulsm23f64",
	[HCC_FUNCTION_IDX_MULSM24F32] = "mulsm24f32",
	[HCC_FUNCTION_IDX_MULSM24F64] = "mulsm24f64",
	[HCC_FUNCTION_IDX_MULSM32F32] = "mulsm32f32",
	[HCC_FUNCTION_IDX_MULSM32F64] = "mulsm32f64",
	[HCC_FUNCTION_IDX_MULSM33F32] = "mulsm33f32",
	[HCC_FUNCTION_IDX_MULSM33F64] = "mulsm33f64",
	[HCC_FUNCTION_IDX_MULSM34F32] = "mulsm34f32",
	[HCC_FUNCTION_IDX_MULSM34F64] = "mulsm34f64",
	[HCC_FUNCTION_IDX_MULSM42F32] = "mulsm42f32",
	[HCC_FUNCTION_IDX_MULSM42F64] = "mulsm42f64",
	[HCC_FUNCTION_IDX_MULSM43F32] = "mulsm43f32",
	[HCC_FUNCTION_IDX_MULSM43F64] = "mulsm43f64",
	[HCC_FUNCTION_IDX_MULSM44F32] = "mulsm44f32",
	[HCC_FUNCTION_IDX_MULSM44F64] = "mulsm44f64",
	[HCC_FUNCTION_IDX_MULM22V2F32] = "mulm22v2f32",
	[HCC_FUNCTION_IDX_MULM22V2F64] = "mulm22v2f64",
	[HCC_FUNCTION_IDX_MULM23V2F32] = "mulm23v2f32",
	[HCC_FUNCTION_IDX_MULM23V2F64] = "mulm23v2f64",
	[HCC_FUNCTION_IDX_MULM24V2F32] = "mulm24v2f32",
	[HCC_FUNCTION_IDX_MULM24V2F64] = "mulm24v2f64",
	[HCC_FUNCTION_IDX_MULM32V3F32] = "mulm32v3f32",
	[HCC_FUNCTION_IDX_MULM32V3F64] = "mulm32v3f64",
	[HCC_FUNCTION_IDX_MULM33V3F32] = "mulm33v3f32",
	[HCC_FUNCTION_IDX_MULM33V3F64] = "mulm33v3f64",
	[HCC_FUNCTION_IDX_MULM34V3F32] = "mulm34v3f32",
	[HCC_FUNCTION_IDX_MULM34V3F64] = "mulm34v3f64",
	[HCC_FUNCTION_IDX_MULM42V4F32] = "mulm42v4f32",
	[HCC_FUNCTION_IDX_MULM42V4F64] = "mulm42v4f64",
	[HCC_FUNCTION_IDX_MULM43V4F32] = "mulm43v4f32",
	[HCC_FUNCTION_IDX_MULM43V4F64] = "mulm43v4f64",
	[HCC_FUNCTION_IDX_MULM44V4F32] = "mulm44v4f32",
	[HCC_FUNCTION_IDX_MULM44V4F64] = "mulm44v4f64",
	[HCC_FUNCTION_IDX_MULV2F32M22] = "mulv2f32m22",
	[HCC_FUNCTION_IDX_MULV2F64M22] = "mulv2f64m22",
	[HCC_FUNCTION_IDX_MULV3F32M23] = "mulv3f32m23",
	[HCC_FUNCTION_IDX_MULV3F64M23] = "mulv3f64m23",
	[HCC_FUNCTION_IDX_MULV4F32M24] = "mulv4f32m24",
	[HCC_FUNCTION_IDX_MULV4F64M24] = "mulv4f64m24",
	[HCC_FUNCTION_IDX_MULV2F32M32] = "mulv2f32m32",
	[HCC_FUNCTION_IDX_MULV2F64M32] = "mulv2f64m32",
	[HCC_FUNCTION_IDX_MULV3F32M33] = "mulv3f32m33",
	[HCC_FUNCTION_IDX_MULV3F64M33] = "mulv3f64m33",
	[HCC_FUNCTION_IDX_MULV4F32M34] = "mulv4f32m34",
	[HCC_FUNCTION_IDX_MULV4F64M34] = "mulv4f64m34",
	[HCC_FUNCTION_IDX_MULV2F32M42] = "mulv2f32m42",
	[HCC_FUNCTION_IDX_MULV2F64M42] = "mulv2f64m42",
	[HCC_FUNCTION_IDX_MULV3F32M43] = "mulv3f32m43",
	[HCC_FUNCTION_IDX_MULV3F64M43] = "mulv3f64m43",
	[HCC_FUNCTION_IDX_MULV4F32M44] = "mulv4f32m44",
	[HCC_FUNCTION_IDX_MULV4F64M44] = "mulv4f64m44",
	[HCC_FUNCTION_IDX_TRANSPOSEM22F32] = "transposem22f32",
	[HCC_FUNCTION_IDX_TRANSPOSEM22F64] = "transposem22f64",
	[HCC_FUNCTION_IDX_TRANSPOSEM23F32] = "transposem23f32",
	[HCC_FUNCTION_IDX_TRANSPOSEM23F64] = "transposem23f64",
	[HCC_FUNCTION_IDX_TRANSPOSEM24F32] = "transposem24f32",
	[HCC_FUNCTION_IDX_TRANSPOSEM24F64] = "transposem24f64",
	[HCC_FUNCTION_IDX_TRANSPOSEM32F32] = "transposem32f32",
	[HCC_FUNCTION_IDX_TRANSPOSEM32F64] = "transposem32f64",
	[HCC_FUNCTION_IDX_TRANSPOSEM33F32] = "transposem33f32",
	[HCC_FUNCTION_IDX_TRANSPOSEM33F64] = "transposem33f64",
	[HCC_FUNCTION_IDX_TRANSPOSEM34F32] = "transposem34f32",
	[HCC_FUNCTION_IDX_TRANSPOSEM34F64] = "transposem34f64",
	[HCC_FUNCTION_IDX_TRANSPOSEM42F32] = "transposem42f32",
	[HCC_FUNCTION_IDX_TRANSPOSEM42F64] = "transposem42f64",
	[HCC_FUNCTION_IDX_TRANSPOSEM43F32] = "transposem43f32",
	[HCC_FUNCTION_IDX_TRANSPOSEM43F64] = "transposem43f64",
	[HCC_FUNCTION_IDX_TRANSPOSEM44F32] = "transposem44f32",
	[HCC_FUNCTION_IDX_TRANSPOSEM44F64] = "transposem44f64",
	[HCC_FUNCTION_IDX_OUTERPRODUCTV2V2F32] = "outerproductv2v2f32",
	[HCC_FUNCTION_IDX_OUTERPRODUCTV2V2F64] = "outerproductv2v2f64",
	[HCC_FUNCTION_IDX_OUTERPRODUCTV2V3F32] = "outerproductv2v3f32",
	[HCC_FUNCTION_IDX_OUTERPRODUCTV2V3F64] = "outerproductv2v3f64",
	[HCC_FUNCTION_IDX_OUTERPRODUCTV2V4F32] = "outerproductv2v4f32",
	[HCC_FUNCTION_IDX_OUTERPRODUCTV2V4F64] = "outerproductv2v4f64",
	[HCC_FUNCTION_IDX_OUTERPRODUCTV3V2F32] = "outerproductv3v2f32",
	[HCC_FUNCTION_IDX_OUTERPRODUCTV3V2F64] = "outerproductv3v2f64",
	[HCC_FUNCTION_IDX_OUTERPRODUCTV3V3F32] = "outerproductv3v3f32",
	[HCC_FUNCTION_IDX_OUTERPRODUCTV3V3F64] = "outerproductv3v3f64",
	[HCC_FUNCTION_IDX_OUTERPRODUCTV3V4F32] = "outerproductv3v4f32",
	[HCC_FUNCTION_IDX_OUTERPRODUCTV3V4F64] = "outerproductv3v4f64",
	[HCC_FUNCTION_IDX_OUTERPRODUCTV4V2F32] = "outerproductv4v2f32",
	[HCC_FUNCTION_IDX_OUTERPRODUCTV4V2F64] = "outerproductv4v2f64",
	[HCC_FUNCTION_IDX_OUTERPRODUCTV4V3F32] = "outerproductv4v3f32",
	[HCC_FUNCTION_IDX_OUTERPRODUCTV4V3F64] = "outerproductv4v3f64",
	[HCC_FUNCTION_IDX_OUTERPRODUCTV4V4F32] = "outerproductv4v4f32",
	[HCC_FUNCTION_IDX_OUTERPRODUCTV4V4F64] = "outerproductv4v4f64",
	[HCC_FUNCTION_IDX_DETERMINANTM22F32] = "determinantm22f32",
	[HCC_FUNCTION_IDX_DETERMINANTM22F64] = "determinantm22f64",
	[HCC_FUNCTION_IDX_DETERMINANTM33F32] = "determinantm33f32",
	[HCC_FUNCTION_IDX_DETERMINANTM33F64] = "determinantm33f64",
	[HCC_FUNCTION_IDX_DETERMINANTM44F32] = "determinantm44f32",
	[HCC_FUNCTION_IDX_DETERMINANTM44F64] = "determinantm44f64",
	[HCC_FUNCTION_IDX_INVERSEM22F32] = "inversem22f32",
	[HCC_FUNCTION_IDX_INVERSEM22F64] = "inversem22f64",
	[HCC_FUNCTION_IDX_INVERSEM33F32] = "inversem33f32",
	[HCC_FUNCTION_IDX_INVERSEM33F64] = "inversem33f64",
	[HCC_FUNCTION_IDX_INVERSEM44F32] = "inversem44f32",
	[HCC_FUNCTION_IDX_INVERSEM44F64] = "inversem44f64",
};

char* hcc_function_shader_stage_strings[HCC_FUNCTION_SHADER_STAGE_COUNT] = {
	[HCC_FUNCTION_SHADER_STAGE_NONE] = "none",
	[HCC_FUNCTION_SHADER_STAGE_VERTEX] = "vertex",
	[HCC_FUNCTION_SHADER_STAGE_FRAGMENT] = "fragment",
	[HCC_FUNCTION_SHADER_STAGE_COMPUTE] = "compute",
	[HCC_FUNCTION_SHADER_STAGE_MESHTASK] = "meshtask",
};

HccIntrinsicTypedef hcc_intrinsic_typedefs[HCC_TYPEDEF_IDX_INTRINSIC_END] = {
	[HCC_TYPEDEF_IDX_UINT8] = { .string_id.idx_plus_one = HCC_STRING_ID_UINT8_T, .aliased_data_type = HCC_DATA_TYPE_VOID },
	[HCC_TYPEDEF_IDX_UINT16] = { .string_id.idx_plus_one = HCC_STRING_ID_UINT16_T, .aliased_data_type = HCC_DATA_TYPE_VOID },
	[HCC_TYPEDEF_IDX_UINT32] = { .string_id.idx_plus_one = HCC_STRING_ID_UINT32_T, .aliased_data_type = HCC_DATA_TYPE_VOID },
	[HCC_TYPEDEF_IDX_UINT64] = { .string_id.idx_plus_one = HCC_STRING_ID_UINT64_T, .aliased_data_type = HCC_DATA_TYPE_VOID },
	[HCC_TYPEDEF_IDX_UINTPTR] = { .string_id.idx_plus_one = HCC_STRING_ID_UINTPTR_T, .aliased_data_type = HCC_DATA_TYPE_VOID },
	[HCC_TYPEDEF_IDX_INT8] = { .string_id.idx_plus_one = HCC_STRING_ID_INT8_T, .aliased_data_type = HCC_DATA_TYPE_VOID },
	[HCC_TYPEDEF_IDX_INT16] = { .string_id.idx_plus_one = HCC_STRING_ID_INT16_T, .aliased_data_type = HCC_DATA_TYPE_VOID },
	[HCC_TYPEDEF_IDX_INT32] = { .string_id.idx_plus_one = HCC_STRING_ID_INT32_T, .aliased_data_type = HCC_DATA_TYPE_VOID },
	[HCC_TYPEDEF_IDX_INT64] = { .string_id.idx_plus_one = HCC_STRING_ID_INT64_T, .aliased_data_type = HCC_DATA_TYPE_VOID },
	[HCC_TYPEDEF_IDX_INTPTR] = { .string_id.idx_plus_one = HCC_STRING_ID_INTPTR_T, .aliased_data_type = HCC_DATA_TYPE_VOID },
	[HCC_TYPEDEF_IDX_HALF] = { .string_id.idx_plus_one = HCC_STRING_ID_HALF, .aliased_data_type = HCC_DATA_TYPE_HALF },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC2BOOL] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC2BOOL, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC2BOOL) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC2I8] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC2I8, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC2I8) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC2I16] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC2I16, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC2I16) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC2I32] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC2I32, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC2I32) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC2I64] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC2I64, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC2I64) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC2U8] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC2U8, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC2U8) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC2U16] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC2U16, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC2U16) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC2U32] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC2U32, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC2U32) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC2U64] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC2U64, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC2U64) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC2F16] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC2F16, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC2F16) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC2F32] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC2F32, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC2F32) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC2F64] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC2F64, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC2F64) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC3BOOL] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC3BOOL, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC3BOOL) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC3I8] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC3I8, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC3I8) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC3I16] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC3I16, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC3I16) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC3I32] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC3I32, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC3I32) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC3I64] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC3I64, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC3I64) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC3U8] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC3U8, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC3U8) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC3U16] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC3U16, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC3U16) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC3U32] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC3U32, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC3U32) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC3U64] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC3U64, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC3U64) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC3F16] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC3F16, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC3F16) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC3F32] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC3F32, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC3F32) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC3F64] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC3F64, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC3F64) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC4BOOL] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC4BOOL, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC4BOOL) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC4I8] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC4I8, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC4I8) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC4I16] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC4I16, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC4I16) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC4I32] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC4I32, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC4I32) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC4I64] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC4I64, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC4I64) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC4U8] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC4U8, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC4U8) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC4U16] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC4U16, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC4U16) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC4U32] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC4U32, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC4U32) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC4U64] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC4U64, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC4U64) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC4F16] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC4F16, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC4F16) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC4F32] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC4F32, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC4F32) },
	[HCC_TYPEDEF_IDX_PVEC_START + HCC_VEC4F64] = { .string_id.idx_plus_one = HCC_STRING_ID_PVEC_START + HCC_VEC4F64, .aliased_data_type = HCC_DATA_TYPE_PVECTOR(HCC_VEC4F64) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC2BOOL] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC2BOOL, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC2BOOL) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC2I8] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC2I8, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC2I8) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC2I16] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC2I16, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC2I16) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC2I32] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC2I32, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC2I32) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC2I64] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC2I64, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC2I64) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC2U8] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC2U8, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC2U8) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC2U16] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC2U16, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC2U16) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC2U32] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC2U32, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC2U32) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC2U64] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC2U64, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC2U64) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC2F16] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC2F16, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC2F16) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC2F32] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC2F32, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC2F32) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC2F64] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC2F64, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC2F64) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC3BOOL] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC3BOOL, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC3BOOL) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC3I8] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC3I8, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC3I8) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC3I16] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC3I16, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC3I16) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC3I32] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC3I32, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC3I32) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC3I64] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC3I64, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC3I64) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC3U8] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC3U8, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC3U8) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC3U16] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC3U16, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC3U16) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC3U32] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC3U32, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC3U32) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC3U64] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC3U64, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC3U64) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC3F16] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC3F16, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC3F16) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC3F32] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC3F32, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC3F32) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC3F64] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC3F64, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC3F64) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC4BOOL] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC4BOOL, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC4BOOL) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC4I8] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC4I8, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC4I8) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC4I16] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC4I16, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC4I16) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC4I32] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC4I32, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC4I32) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC4I64] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC4I64, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC4I64) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC4U8] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC4U8, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC4U8) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC4U16] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC4U16, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC4U16) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC4U32] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC4U32, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC4U32) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC4U64] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC4U64, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC4U64) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC4F16] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC4F16, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC4F16) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC4F32] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC4F32, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC4F32) },
	[HCC_TYPEDEF_IDX_VEC_START + HCC_VEC4F64] = { .string_id.idx_plus_one = HCC_STRING_ID_VEC_START + HCC_VEC4F64, .aliased_data_type = HCC_DATA_TYPE_VECTOR(HCC_VEC4F64) },
	[HCC_TYPEDEF_IDX_PMAT_START + HCC_MAT22F32] = { .string_id.idx_plus_one = HCC_STRING_ID_PMAT_START + HCC_MAT22F32, .aliased_data_type = HCC_DATA_TYPE_PMATRIX(HCC_MAT22F32) },
	[HCC_TYPEDEF_IDX_PMAT_START + HCC_MAT22F64] = { .string_id.idx_plus_one = HCC_STRING_ID_PMAT_START + HCC_MAT22F64, .aliased_data_type = HCC_DATA_TYPE_PMATRIX(HCC_MAT22F64) },
	[HCC_TYPEDEF_IDX_PMAT_START + HCC_MAT23F32] = { .string_id.idx_plus_one = HCC_STRING_ID_PMAT_START + HCC_MAT23F32, .aliased_data_type = HCC_DATA_TYPE_PMATRIX(HCC_MAT23F32) },
	[HCC_TYPEDEF_IDX_PMAT_START + HCC_MAT23F64] = { .string_id.idx_plus_one = HCC_STRING_ID_PMAT_START + HCC_MAT23F64, .aliased_data_type = HCC_DATA_TYPE_PMATRIX(HCC_MAT23F64) },
	[HCC_TYPEDEF_IDX_PMAT_START + HCC_MAT24F32] = { .string_id.idx_plus_one = HCC_STRING_ID_PMAT_START + HCC_MAT24F32, .aliased_data_type = HCC_DATA_TYPE_PMATRIX(HCC_MAT24F32) },
	[HCC_TYPEDEF_IDX_PMAT_START + HCC_MAT24F64] = { .string_id.idx_plus_one = HCC_STRING_ID_PMAT_START + HCC_MAT24F64, .aliased_data_type = HCC_DATA_TYPE_PMATRIX(HCC_MAT24F64) },
	[HCC_TYPEDEF_IDX_PMAT_START + HCC_MAT32F32] = { .string_id.idx_plus_one = HCC_STRING_ID_PMAT_START + HCC_MAT32F32, .aliased_data_type = HCC_DATA_TYPE_PMATRIX(HCC_MAT32F32) },
	[HCC_TYPEDEF_IDX_PMAT_START + HCC_MAT32F64] = { .string_id.idx_plus_one = HCC_STRING_ID_PMAT_START + HCC_MAT32F64, .aliased_data_type = HCC_DATA_TYPE_PMATRIX(HCC_MAT32F64) },
	[HCC_TYPEDEF_IDX_PMAT_START + HCC_MAT33F32] = { .string_id.idx_plus_one = HCC_STRING_ID_PMAT_START + HCC_MAT33F32, .aliased_data_type = HCC_DATA_TYPE_PMATRIX(HCC_MAT33F32) },
	[HCC_TYPEDEF_IDX_PMAT_START + HCC_MAT33F64] = { .string_id.idx_plus_one = HCC_STRING_ID_PMAT_START + HCC_MAT33F64, .aliased_data_type = HCC_DATA_TYPE_PMATRIX(HCC_MAT33F64) },
	[HCC_TYPEDEF_IDX_PMAT_START + HCC_MAT34F32] = { .string_id.idx_plus_one = HCC_STRING_ID_PMAT_START + HCC_MAT34F32, .aliased_data_type = HCC_DATA_TYPE_PMATRIX(HCC_MAT34F32) },
	[HCC_TYPEDEF_IDX_PMAT_START + HCC_MAT34F64] = { .string_id.idx_plus_one = HCC_STRING_ID_PMAT_START + HCC_MAT34F64, .aliased_data_type = HCC_DATA_TYPE_PMATRIX(HCC_MAT34F64) },
	[HCC_TYPEDEF_IDX_PMAT_START + HCC_MAT42F32] = { .string_id.idx_plus_one = HCC_STRING_ID_PMAT_START + HCC_MAT42F32, .aliased_data_type = HCC_DATA_TYPE_PMATRIX(HCC_MAT42F32) },
	[HCC_TYPEDEF_IDX_PMAT_START + HCC_MAT42F64] = { .string_id.idx_plus_one = HCC_STRING_ID_PMAT_START + HCC_MAT42F64, .aliased_data_type = HCC_DATA_TYPE_PMATRIX(HCC_MAT42F64) },
	[HCC_TYPEDEF_IDX_PMAT_START + HCC_MAT43F32] = { .string_id.idx_plus_one = HCC_STRING_ID_PMAT_START + HCC_MAT43F32, .aliased_data_type = HCC_DATA_TYPE_PMATRIX(HCC_MAT43F32) },
	[HCC_TYPEDEF_IDX_PMAT_START + HCC_MAT43F64] = { .string_id.idx_plus_one = HCC_STRING_ID_PMAT_START + HCC_MAT43F64, .aliased_data_type = HCC_DATA_TYPE_PMATRIX(HCC_MAT43F64) },
	[HCC_TYPEDEF_IDX_PMAT_START + HCC_MAT44F32] = { .string_id.idx_plus_one = HCC_STRING_ID_PMAT_START + HCC_MAT44F32, .aliased_data_type = HCC_DATA_TYPE_PMATRIX(HCC_MAT44F32) },
	[HCC_TYPEDEF_IDX_PMAT_START + HCC_MAT44F64] = { .string_id.idx_plus_one = HCC_STRING_ID_PMAT_START + HCC_MAT44F64, .aliased_data_type = HCC_DATA_TYPE_PMATRIX(HCC_MAT44F64) },
	[HCC_TYPEDEF_IDX_MAT_START + HCC_MAT22F32] = { .string_id.idx_plus_one = HCC_STRING_ID_MAT_START + HCC_MAT22F32, .aliased_data_type = HCC_DATA_TYPE_MATRIX(HCC_MAT22F32) },
	[HCC_TYPEDEF_IDX_MAT_START + HCC_MAT22F64] = { .string_id.idx_plus_one = HCC_STRING_ID_MAT_START + HCC_MAT22F64, .aliased_data_type = HCC_DATA_TYPE_MATRIX(HCC_MAT22F64) },
	[HCC_TYPEDEF_IDX_MAT_START + HCC_MAT23F32] = { .string_id.idx_plus_one = HCC_STRING_ID_MAT_START + HCC_MAT23F32, .aliased_data_type = HCC_DATA_TYPE_MATRIX(HCC_MAT23F32) },
	[HCC_TYPEDEF_IDX_MAT_START + HCC_MAT23F64] = { .string_id.idx_plus_one = HCC_STRING_ID_MAT_START + HCC_MAT23F64, .aliased_data_type = HCC_DATA_TYPE_MATRIX(HCC_MAT23F64) },
	[HCC_TYPEDEF_IDX_MAT_START + HCC_MAT24F32] = { .string_id.idx_plus_one = HCC_STRING_ID_MAT_START + HCC_MAT24F32, .aliased_data_type = HCC_DATA_TYPE_MATRIX(HCC_MAT24F32) },
	[HCC_TYPEDEF_IDX_MAT_START + HCC_MAT24F64] = { .string_id.idx_plus_one = HCC_STRING_ID_MAT_START + HCC_MAT24F64, .aliased_data_type = HCC_DATA_TYPE_MATRIX(HCC_MAT24F64) },
	[HCC_TYPEDEF_IDX_MAT_START + HCC_MAT32F32] = { .string_id.idx_plus_one = HCC_STRING_ID_MAT_START + HCC_MAT32F32, .aliased_data_type = HCC_DATA_TYPE_MATRIX(HCC_MAT32F32) },
	[HCC_TYPEDEF_IDX_MAT_START + HCC_MAT32F64] = { .string_id.idx_plus_one = HCC_STRING_ID_MAT_START + HCC_MAT32F64, .aliased_data_type = HCC_DATA_TYPE_MATRIX(HCC_MAT32F64) },
	[HCC_TYPEDEF_IDX_MAT_START + HCC_MAT33F32] = { .string_id.idx_plus_one = HCC_STRING_ID_MAT_START + HCC_MAT33F32, .aliased_data_type = HCC_DATA_TYPE_MATRIX(HCC_MAT33F32) },
	[HCC_TYPEDEF_IDX_MAT_START + HCC_MAT33F64] = { .string_id.idx_plus_one = HCC_STRING_ID_MAT_START + HCC_MAT33F64, .aliased_data_type = HCC_DATA_TYPE_MATRIX(HCC_MAT33F64) },
	[HCC_TYPEDEF_IDX_MAT_START + HCC_MAT34F32] = { .string_id.idx_plus_one = HCC_STRING_ID_MAT_START + HCC_MAT34F32, .aliased_data_type = HCC_DATA_TYPE_MATRIX(HCC_MAT34F32) },
	[HCC_TYPEDEF_IDX_MAT_START + HCC_MAT34F64] = { .string_id.idx_plus_one = HCC_STRING_ID_MAT_START + HCC_MAT34F64, .aliased_data_type = HCC_DATA_TYPE_MATRIX(HCC_MAT34F64) },
	[HCC_TYPEDEF_IDX_MAT_START + HCC_MAT42F32] = { .string_id.idx_plus_one = HCC_STRING_ID_MAT_START + HCC_MAT42F32, .aliased_data_type = HCC_DATA_TYPE_MATRIX(HCC_MAT42F32) },
	[HCC_TYPEDEF_IDX_MAT_START + HCC_MAT42F64] = { .string_id.idx_plus_one = HCC_STRING_ID_MAT_START + HCC_MAT42F64, .aliased_data_type = HCC_DATA_TYPE_MATRIX(HCC_MAT42F64) },
	[HCC_TYPEDEF_IDX_MAT_START + HCC_MAT43F32] = { .string_id.idx_plus_one = HCC_STRING_ID_MAT_START + HCC_MAT43F32, .aliased_data_type = HCC_DATA_TYPE_MATRIX(HCC_MAT43F32) },
	[HCC_TYPEDEF_IDX_MAT_START + HCC_MAT43F64] = { .string_id.idx_plus_one = HCC_STRING_ID_MAT_START + HCC_MAT43F64, .aliased_data_type = HCC_DATA_TYPE_MATRIX(HCC_MAT43F64) },
	[HCC_TYPEDEF_IDX_MAT_START + HCC_MAT44F32] = { .string_id.idx_plus_one = HCC_STRING_ID_MAT_START + HCC_MAT44F32, .aliased_data_type = HCC_DATA_TYPE_MATRIX(HCC_MAT44F32) },
	[HCC_TYPEDEF_IDX_MAT_START + HCC_MAT44F64] = { .string_id.idx_plus_one = HCC_STRING_ID_MAT_START + HCC_MAT44F64, .aliased_data_type = HCC_DATA_TYPE_MATRIX(HCC_MAT44F64) },
	[HCC_TYPEDEF_IDX_VERTEX_INPUT] = { .string_id.idx_plus_one = HCC_STRING_ID_HCC_VERTEX_INPUT, .aliased_data_type = HCC_DATA_TYPE_STRUCT(HCC_STRUCT_IDX_VERTEX_INPUT) },
	[HCC_TYPEDEF_IDX_FRAGMENT_INPUT] = { .string_id.idx_plus_one = HCC_STRING_ID_HCC_FRAGMENT_INPUT, .aliased_data_type = HCC_DATA_TYPE_STRUCT(HCC_STRUCT_IDX_FRAGMENT_INPUT) },
};

HccIntrinsicStruct hcc_intrinsic_structs[HCC_STRUCT_IDX_INTRINSIC_END] = {
	[HCC_STRUCT_IDX_VERTEX_INPUT] = {
		.string_id.idx_plus_one = HCC_STRING_ID_HCC_VERTEX_INPUT,
		.fields_count = 2,
		.fields = {
			[HCC_VERTEX_INPUT_VERTEX_INDEX] = { .data_type = HCC_DATA_TYPE_TYPEDEF(HCC_TYPEDEF_IDX_INT32), .string_id.idx_plus_one = HCC_STRING_ID_VERTEX_IDX },
			[HCC_VERTEX_INPUT_INSTANCE_INDEX] = { .data_type = HCC_DATA_TYPE_TYPEDEF(HCC_TYPEDEF_IDX_INT32), .string_id.idx_plus_one = HCC_STRING_ID_INSTANCE_IDX },
		},
	},
	[HCC_STRUCT_IDX_FRAGMENT_INPUT] = {
		.string_id.idx_plus_one = HCC_STRING_ID_HCC_FRAGMENT_INPUT,
		.fields_count = 1,
		.fields = {
			[HCC_FRAGMENT_INPUT_FRAG_COORD] = { .data_type = HCC_DATA_TYPE_TYPEDEF(HCC_TYPEDEF_IDX_VEC_START + HCC_VEC4F32), .string_id.idx_plus_one = HCC_STRING_ID_FRAG_COORD },
		},
	},
	[HCC_STRUCT_IDX_HALF] = {
		.string_id.idx_plus_one = HCC_STRING_ID_HALF,
		.fields_count = 1,
		.fields = {
			[HCC_FRAGMENT_INPUT_FRAG_COORD] = { .data_type = HCC_DATA_TYPE_UINT16, .string_id.idx_plus_one = HCC_STRING_ID__BITS },
		},
	},
};

HccIntrinsicFunction hcc_intrinsic_functions[HCC_FUNCTION_IDX_INTRINSIC_END] = {
	//
	// libc-gpu/math.h
	//
	[HCC_FUNCTION_IDX_ISINF] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_GENERIC_FLOAT }, },
	[HCC_FUNCTION_IDX_ISNAN] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_GENERIC_FLOAT }, },
	[HCC_FUNCTION_IDX_FMODF] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_FLOAT, HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_FMOD] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_DOUBLE, HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_FABSF] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_FABS] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_FLOORF] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_FLOOR] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_CEILF] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_CEIL] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_ROUNDF] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_ROUND] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_TRUNCF] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_TRUNC] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_SINF] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_SIN] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_COSF] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_COS] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_TANF] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_TAN] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_ASINF] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_ASIN] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_ACOSF] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_ACOS] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_ATANF] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_ATAN] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_SINHF] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_SINH] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_COSHF] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_COSH] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_TANHF] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_TANH] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_ASINHF] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_ASINH] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_ACOSHF] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_ACOSH] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_ATANHF] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_ATANH] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_ATAN2F] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_FLOAT, HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_ATAN2] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_DOUBLE, HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_FMAF] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 3, .param_data_types = { HCC_DATA_TYPE_FLOAT, HCC_DATA_TYPE_FLOAT, HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_FMA] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 3, .param_data_types = { HCC_DATA_TYPE_DOUBLE, HCC_DATA_TYPE_DOUBLE, HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_SQRTF] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_SQRT] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_POWF] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_POW] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_EXPF] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_EXP] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_LOGF] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_LOG] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_EXP2F] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_EXP2] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_LOG2F] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_LOG2] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },

	//
	// libhccstd/math.h - half
	//
	[HCC_FUNCTION_IDX_F16TOF32] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_F16TOF64] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_F32TOF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_F64TOF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_ISINFF16] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_ISNANF16] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_ADDF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF, HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_SUBF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF, HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_MULF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF, HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_DIVF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF, HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_MODF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF, HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_EQF16] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF, HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_NEQF16] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF, HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_LTF16] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF, HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_LTEQF16] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF, HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_GTF16] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF, HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_GTEQF16] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF, HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_NOTF16] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_NEGF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_ABSF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_FLOORF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_CEILF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_ROUNDF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_TRUNCF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_SINF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_COSF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_TANF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_ASINF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_ACOSF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_ATANF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_SINHF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_COSHF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_TANHF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_ASINHF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_ACOSHF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_ATANHF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_ATAN2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF, HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_FMAF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF, HCC_DATA_TYPE_TYPEDEF_HALF, HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_SQRTF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_POWF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_EXPF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_LOGF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_EXP2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_LOG2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },

	//
	// libhccstd/math.h - scalar
	//
	[HCC_FUNCTION_IDX_MINF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF, HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_MINF32] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_FLOAT, HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_MINF64] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_DOUBLE, HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_MINI8] = { .return_data_type = HCC_DATA_TYPE_INT8, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_INT8, HCC_DATA_TYPE_INT8 }, },
	[HCC_FUNCTION_IDX_MINI16] = { .return_data_type = HCC_DATA_TYPE_INT16, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_INT16, HCC_DATA_TYPE_INT16 }, },
	[HCC_FUNCTION_IDX_MINI32] = { .return_data_type = HCC_DATA_TYPE_INT32, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_INT32, HCC_DATA_TYPE_INT32 }, },
	[HCC_FUNCTION_IDX_MINI64] = { .return_data_type = HCC_DATA_TYPE_INT64, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_INT64, HCC_DATA_TYPE_INT64 }, },
	[HCC_FUNCTION_IDX_MINU8] = { .return_data_type = HCC_DATA_TYPE_UINT8, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_MINU16] = { .return_data_type = HCC_DATA_TYPE_UINT16, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_UINT16, HCC_DATA_TYPE_UINT16 }, },
	[HCC_FUNCTION_IDX_MINU32] = { .return_data_type = HCC_DATA_TYPE_UINT32, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_UINT32, HCC_DATA_TYPE_UINT32 }, },
	[HCC_FUNCTION_IDX_MINU64] = { .return_data_type = HCC_DATA_TYPE_UINT64, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_UINT64, HCC_DATA_TYPE_UINT64 }, },
	[HCC_FUNCTION_IDX_MAXF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF, HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_MAXF32] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_FLOAT, HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_MAXF64] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_DOUBLE, HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_MAXI8] = { .return_data_type = HCC_DATA_TYPE_INT8, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_INT8, HCC_DATA_TYPE_INT8 }, },
	[HCC_FUNCTION_IDX_MAXI16] = { .return_data_type = HCC_DATA_TYPE_INT16, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_INT16, HCC_DATA_TYPE_INT16 }, },
	[HCC_FUNCTION_IDX_MAXI32] = { .return_data_type = HCC_DATA_TYPE_INT32, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_INT32, HCC_DATA_TYPE_INT32 }, },
	[HCC_FUNCTION_IDX_MAXI64] = { .return_data_type = HCC_DATA_TYPE_INT64, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_INT64, HCC_DATA_TYPE_INT64 }, },
	[HCC_FUNCTION_IDX_MAXU8] = { .return_data_type = HCC_DATA_TYPE_UINT8, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_MAXU16] = { .return_data_type = HCC_DATA_TYPE_UINT16, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_UINT16, HCC_DATA_TYPE_UINT16 }, },
	[HCC_FUNCTION_IDX_MAXU32] = { .return_data_type = HCC_DATA_TYPE_UINT32, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_UINT32, HCC_DATA_TYPE_UINT32 }, },
	[HCC_FUNCTION_IDX_MAXU64] = { .return_data_type = HCC_DATA_TYPE_UINT64, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_UINT64, HCC_DATA_TYPE_UINT64 }, },
	[HCC_FUNCTION_IDX_CLAMPF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF, HCC_DATA_TYPE_TYPEDEF_HALF, HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_CLAMPF32] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 3, .param_data_types = { HCC_DATA_TYPE_FLOAT, HCC_DATA_TYPE_FLOAT, HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_CLAMPF64] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 3, .param_data_types = { HCC_DATA_TYPE_DOUBLE, HCC_DATA_TYPE_DOUBLE, HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_CLAMPI8] = { .return_data_type = HCC_DATA_TYPE_INT8, .params_count = 3, .param_data_types = { HCC_DATA_TYPE_INT8, HCC_DATA_TYPE_INT8, HCC_DATA_TYPE_INT8 }, },
	[HCC_FUNCTION_IDX_CLAMPI16] = { .return_data_type = HCC_DATA_TYPE_INT16, .params_count = 3, .param_data_types = { HCC_DATA_TYPE_INT16, HCC_DATA_TYPE_INT16, HCC_DATA_TYPE_INT16 }, },
	[HCC_FUNCTION_IDX_CLAMPI32] = { .return_data_type = HCC_DATA_TYPE_INT32, .params_count = 3, .param_data_types = { HCC_DATA_TYPE_INT32, HCC_DATA_TYPE_INT32, HCC_DATA_TYPE_INT32 }, },
	[HCC_FUNCTION_IDX_CLAMPI64] = { .return_data_type = HCC_DATA_TYPE_INT64, .params_count = 3, .param_data_types = { HCC_DATA_TYPE_INT64, HCC_DATA_TYPE_INT64, HCC_DATA_TYPE_INT64 }, },
	[HCC_FUNCTION_IDX_CLAMPU8] = { .return_data_type = HCC_DATA_TYPE_UINT8, .params_count = 3, .param_data_types = { HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_CLAMPU16] = { .return_data_type = HCC_DATA_TYPE_UINT16, .params_count = 3, .param_data_types = { HCC_DATA_TYPE_UINT16, HCC_DATA_TYPE_UINT16, HCC_DATA_TYPE_UINT16 }, },
	[HCC_FUNCTION_IDX_CLAMPU32] = { .return_data_type = HCC_DATA_TYPE_UINT32, .params_count = 3, .param_data_types = { HCC_DATA_TYPE_UINT32, HCC_DATA_TYPE_UINT32, HCC_DATA_TYPE_UINT32 }, },
	[HCC_FUNCTION_IDX_CLAMPU64] = { .return_data_type = HCC_DATA_TYPE_UINT64, .params_count = 3, .param_data_types = { HCC_DATA_TYPE_UINT64, HCC_DATA_TYPE_UINT64, HCC_DATA_TYPE_UINT64 }, },
	[HCC_FUNCTION_IDX_ABSI8] = { .return_data_type = HCC_DATA_TYPE_INT8, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_INT8 }, },
	[HCC_FUNCTION_IDX_ABSI16] = { .return_data_type = HCC_DATA_TYPE_INT16, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_INT16 }, },
	[HCC_FUNCTION_IDX_ABSI32] = { .return_data_type = HCC_DATA_TYPE_INT32, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_INT32 }, },
	[HCC_FUNCTION_IDX_ABSI64] = { .return_data_type = HCC_DATA_TYPE_INT64, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_INT64 }, },
	[HCC_FUNCTION_IDX_RSQRTF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_RSQRTF32] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_RSQRTF64] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_SIGNF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_SIGNF32] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_SIGNF64] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_SIGNI8] = { .return_data_type = HCC_DATA_TYPE_INT8, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_INT8 }, },
	[HCC_FUNCTION_IDX_SIGNI16] = { .return_data_type = HCC_DATA_TYPE_INT16, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_INT16 }, },
	[HCC_FUNCTION_IDX_SIGNI32] = { .return_data_type = HCC_DATA_TYPE_INT32, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_INT32 }, },
	[HCC_FUNCTION_IDX_SIGNI64] = { .return_data_type = HCC_DATA_TYPE_INT64, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_INT64 }, },
	[HCC_FUNCTION_IDX_LERPF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF, HCC_DATA_TYPE_TYPEDEF_HALF, HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_LERPF32] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 3, .param_data_types = { HCC_DATA_TYPE_FLOAT, HCC_DATA_TYPE_FLOAT, HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_LERPF64] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 3, .param_data_types = { HCC_DATA_TYPE_DOUBLE, HCC_DATA_TYPE_DOUBLE, HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_FRACTF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_FRACTF32] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_FRACTF64] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_DEGREESF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_DEGREESF32] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_DEGREESF64] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_RADIANSF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_RADIANSF32] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_RADIANSF64] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_STEPF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF, HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_STEPF32] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_FLOAT, HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_STEPF64] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_DOUBLE, HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_SMOOTHSTEPF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF, HCC_DATA_TYPE_TYPEDEF_HALF, HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_SMOOTHSTEPF32] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 3, .param_data_types = { HCC_DATA_TYPE_FLOAT, HCC_DATA_TYPE_FLOAT, HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_SMOOTHSTEPF64] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 3, .param_data_types = { HCC_DATA_TYPE_DOUBLE, HCC_DATA_TYPE_DOUBLE, HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_BITSTOF16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_UINT16 }, },
	[HCC_FUNCTION_IDX_BITSTOF32] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_UINT32 }, },
	[HCC_FUNCTION_IDX_BITSTOF64] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_UINT64 }, },
	[HCC_FUNCTION_IDX_BITSFROMF16] = { .return_data_type = HCC_DATA_TYPE_UINT16, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_HALF }, },
	[HCC_FUNCTION_IDX_BITSFROMF32] = { .return_data_type = HCC_DATA_TYPE_UINT32, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_BITSFROMF64] = { .return_data_type = HCC_DATA_TYPE_UINT64, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_DOUBLE }, },

	//
	// libhccstd/math.h - vector
	//
	[HCC_FUNCTION_IDX_SWIZZLEV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV2I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV2I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV2I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV2I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV2U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV2U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV2U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV2U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 4, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 4, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 4, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV3I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), .params_count = 4, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV3I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), .params_count = 4, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV3I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), .params_count = 4, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV3I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), .params_count = 4, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV3U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), .params_count = 4, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV3U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), .params_count = 4, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV3U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), .params_count = 4, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV3U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), .params_count = 4, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 5, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 5, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 5, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV4I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), .params_count = 5, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV4I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), .params_count = 5, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV4I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), .params_count = 5, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV4I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), .params_count = 5, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV4U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), .params_count = 5, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV4U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), .params_count = 5, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV4U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), .params_count = 5, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_SWIZZLEV4U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), .params_count = 5, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8, HCC_DATA_TYPE_UINT8 }, },
	[HCC_FUNCTION_IDX_PACKV2BOOL] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC2BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL) }, },
	[HCC_FUNCTION_IDX_PACKV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_PACKV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_PACKV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_PACKV2I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC2I8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8) }, },
	[HCC_FUNCTION_IDX_PACKV2I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC2I16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_PACKV2I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC2I32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_PACKV2I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC2I64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_PACKV2U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC2U8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8) }, },
	[HCC_FUNCTION_IDX_PACKV2U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC2U16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16) }, },
	[HCC_FUNCTION_IDX_PACKV2U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC2U32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32) }, },
	[HCC_FUNCTION_IDX_PACKV2U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC2U64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64) }, },
	[HCC_FUNCTION_IDX_PACKV3BOOL] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC3BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL) }, },
	[HCC_FUNCTION_IDX_PACKV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_PACKV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_PACKV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_PACKV3I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC3I8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8) }, },
	[HCC_FUNCTION_IDX_PACKV3I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC3I16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_PACKV3I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC3I32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_PACKV3I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC3I64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_PACKV3U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC3U8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8) }, },
	[HCC_FUNCTION_IDX_PACKV3U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC3U16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16) }, },
	[HCC_FUNCTION_IDX_PACKV3U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC3U32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32) }, },
	[HCC_FUNCTION_IDX_PACKV3U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC3U64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64) }, },
	[HCC_FUNCTION_IDX_PACKV4BOOL] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC4BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL) }, },
	[HCC_FUNCTION_IDX_PACKV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_PACKV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_PACKV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_PACKV4I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC4I8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8) }, },
	[HCC_FUNCTION_IDX_PACKV4I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC4I16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_PACKV4I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC4I32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_PACKV4I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC4I64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_PACKV4U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC4U8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8) }, },
	[HCC_FUNCTION_IDX_PACKV4U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC4U16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16) }, },
	[HCC_FUNCTION_IDX_PACKV4U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC4U32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32) }, },
	[HCC_FUNCTION_IDX_PACKV4U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC4U64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64) }, },
	[HCC_FUNCTION_IDX_UNPACKV2BOOL] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC2BOOL) }, },
	[HCC_FUNCTION_IDX_UNPACKV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_UNPACKV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_UNPACKV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_UNPACKV2I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC2I8) }, },
	[HCC_FUNCTION_IDX_UNPACKV2I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_UNPACKV2I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_UNPACKV2I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_UNPACKV2U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC2U8) }, },
	[HCC_FUNCTION_IDX_UNPACKV2U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC2U16) }, },
	[HCC_FUNCTION_IDX_UNPACKV2U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC2U32) }, },
	[HCC_FUNCTION_IDX_UNPACKV2U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC2U64) }, },
	[HCC_FUNCTION_IDX_UNPACKV3BOOL] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC3BOOL) }, },
	[HCC_FUNCTION_IDX_UNPACKV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_UNPACKV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_UNPACKV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_UNPACKV3I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC3I8) }, },
	[HCC_FUNCTION_IDX_UNPACKV3I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_UNPACKV3I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_UNPACKV3I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_UNPACKV3U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC3U8) }, },
	[HCC_FUNCTION_IDX_UNPACKV3U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC3U16) }, },
	[HCC_FUNCTION_IDX_UNPACKV3U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC3U32) }, },
	[HCC_FUNCTION_IDX_UNPACKV3U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC3U64) }, },
	[HCC_FUNCTION_IDX_UNPACKV4BOOL] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC4BOOL) }, },
	[HCC_FUNCTION_IDX_UNPACKV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_UNPACKV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_UNPACKV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_UNPACKV4I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC4I8) }, },
	[HCC_FUNCTION_IDX_UNPACKV4I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_UNPACKV4I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_UNPACKV4I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_UNPACKV4U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC4U8) }, },
	[HCC_FUNCTION_IDX_UNPACKV4U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC4U16) }, },
	[HCC_FUNCTION_IDX_UNPACKV4U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC4U32) }, },
	[HCC_FUNCTION_IDX_UNPACKV4U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_PVECTOR(HCC_VEC4U64) }, },
	[HCC_FUNCTION_IDX_ANYV2BOOL] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL) }, },
	[HCC_FUNCTION_IDX_ANYV2F16] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_ANYV2F32] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_ANYV2F64] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_ANYV2I8] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8) }, },
	[HCC_FUNCTION_IDX_ANYV2I16] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_ANYV2I32] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_ANYV2I64] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_ANYV2U8] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8) }, },
	[HCC_FUNCTION_IDX_ANYV2U16] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16) }, },
	[HCC_FUNCTION_IDX_ANYV2U32] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32) }, },
	[HCC_FUNCTION_IDX_ANYV2U64] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64) }, },
	[HCC_FUNCTION_IDX_ANYV3BOOL] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL) }, },
	[HCC_FUNCTION_IDX_ANYV3F16] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_ANYV3F32] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_ANYV3F64] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_ANYV3I8] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8) }, },
	[HCC_FUNCTION_IDX_ANYV3I16] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_ANYV3I32] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_ANYV3I64] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_ANYV3U8] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8) }, },
	[HCC_FUNCTION_IDX_ANYV3U16] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16) }, },
	[HCC_FUNCTION_IDX_ANYV3U32] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32) }, },
	[HCC_FUNCTION_IDX_ANYV3U64] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64) }, },
	[HCC_FUNCTION_IDX_ANYV4BOOL] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL) }, },
	[HCC_FUNCTION_IDX_ANYV4F16] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_ANYV4F32] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_ANYV4F64] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_ANYV4I8] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8) }, },
	[HCC_FUNCTION_IDX_ANYV4I16] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_ANYV4I32] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_ANYV4I64] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_ANYV4U8] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8) }, },
	[HCC_FUNCTION_IDX_ANYV4U16] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16) }, },
	[HCC_FUNCTION_IDX_ANYV4U32] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32) }, },
	[HCC_FUNCTION_IDX_ANYV4U64] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64) }, },
	[HCC_FUNCTION_IDX_ALLV2BOOL] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL) }, },
	[HCC_FUNCTION_IDX_ALLV2F16] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_ALLV2F32] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_ALLV2F64] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_ALLV2I8] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8) }, },
	[HCC_FUNCTION_IDX_ALLV2I16] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_ALLV2I32] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_ALLV2I64] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_ALLV2U8] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8) }, },
	[HCC_FUNCTION_IDX_ALLV2U16] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16) }, },
	[HCC_FUNCTION_IDX_ALLV2U32] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32) }, },
	[HCC_FUNCTION_IDX_ALLV2U64] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64) }, },
	[HCC_FUNCTION_IDX_ALLV3BOOL] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL) }, },
	[HCC_FUNCTION_IDX_ALLV3F16] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_ALLV3F32] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_ALLV3F64] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_ALLV3I8] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8) }, },
	[HCC_FUNCTION_IDX_ALLV3I16] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_ALLV3I32] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_ALLV3I64] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_ALLV3U8] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8) }, },
	[HCC_FUNCTION_IDX_ALLV3U16] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16) }, },
	[HCC_FUNCTION_IDX_ALLV3U32] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32) }, },
	[HCC_FUNCTION_IDX_ALLV3U64] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64) }, },
	[HCC_FUNCTION_IDX_ALLV4BOOL] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL) }, },
	[HCC_FUNCTION_IDX_ALLV4F16] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_ALLV4F32] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_ALLV4F64] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_ALLV4I8] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8) }, },
	[HCC_FUNCTION_IDX_ALLV4I16] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_ALLV4I32] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_ALLV4I64] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_ALLV4U8] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8) }, },
	[HCC_FUNCTION_IDX_ALLV4U16] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16) }, },
	[HCC_FUNCTION_IDX_ALLV4U32] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32) }, },
	[HCC_FUNCTION_IDX_ALLV4U64] = { .return_data_type = HCC_DATA_TYPE_BOOL, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64) }, },
	[HCC_FUNCTION_IDX_NOTV2BOOL] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL) }, },
	[HCC_FUNCTION_IDX_NOTV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_NOTV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_NOTV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_NOTV2I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8) }, },
	[HCC_FUNCTION_IDX_NOTV2I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_NOTV2I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_NOTV2I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_NOTV2U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8) }, },
	[HCC_FUNCTION_IDX_NOTV2U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16) }, },
	[HCC_FUNCTION_IDX_NOTV2U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32) }, },
	[HCC_FUNCTION_IDX_NOTV2U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64) }, },
	[HCC_FUNCTION_IDX_NOTV3BOOL] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL) }, },
	[HCC_FUNCTION_IDX_NOTV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_NOTV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_NOTV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_NOTV3I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8) }, },
	[HCC_FUNCTION_IDX_NOTV3I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_NOTV3I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_NOTV3I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_NOTV3U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8) }, },
	[HCC_FUNCTION_IDX_NOTV3U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16) }, },
	[HCC_FUNCTION_IDX_NOTV3U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32) }, },
	[HCC_FUNCTION_IDX_NOTV3U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64) }, },
	[HCC_FUNCTION_IDX_NOTV4BOOL] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL) }, },
	[HCC_FUNCTION_IDX_NOTV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_NOTV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_NOTV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_NOTV4I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8) }, },
	[HCC_FUNCTION_IDX_NOTV4I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_NOTV4I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_NOTV4I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_NOTV4U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8) }, },
	[HCC_FUNCTION_IDX_NOTV4U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16) }, },
	[HCC_FUNCTION_IDX_NOTV4U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32) }, },
	[HCC_FUNCTION_IDX_NOTV4U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64) }, },
	[HCC_FUNCTION_IDX_ADDV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_ADDV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_ADDV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_ADDV2I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8) }, },
	[HCC_FUNCTION_IDX_ADDV2I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_ADDV2I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_ADDV2I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_ADDV2U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8) }, },
	[HCC_FUNCTION_IDX_ADDV2U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16) }, },
	[HCC_FUNCTION_IDX_ADDV2U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32) }, },
	[HCC_FUNCTION_IDX_ADDV2U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64) }, },
	[HCC_FUNCTION_IDX_ADDV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_ADDV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_ADDV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_ADDV3I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8) }, },
	[HCC_FUNCTION_IDX_ADDV3I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_ADDV3I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_ADDV3I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_ADDV3U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8) }, },
	[HCC_FUNCTION_IDX_ADDV3U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16) }, },
	[HCC_FUNCTION_IDX_ADDV3U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32) }, },
	[HCC_FUNCTION_IDX_ADDV3U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64) }, },
	[HCC_FUNCTION_IDX_ADDV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_ADDV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_ADDV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_ADDV4I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8) }, },
	[HCC_FUNCTION_IDX_ADDV4I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_ADDV4I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_ADDV4I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_ADDV4U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8) }, },
	[HCC_FUNCTION_IDX_ADDV4U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16) }, },
	[HCC_FUNCTION_IDX_ADDV4U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32) }, },
	[HCC_FUNCTION_IDX_ADDV4U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64) }, },
	[HCC_FUNCTION_IDX_SUBV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_SUBV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_SUBV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_SUBV2I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8) }, },
	[HCC_FUNCTION_IDX_SUBV2I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_SUBV2I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_SUBV2I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_SUBV2U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8) }, },
	[HCC_FUNCTION_IDX_SUBV2U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16) }, },
	[HCC_FUNCTION_IDX_SUBV2U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32) }, },
	[HCC_FUNCTION_IDX_SUBV2U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64) }, },
	[HCC_FUNCTION_IDX_SUBV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_SUBV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_SUBV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_SUBV3I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8) }, },
	[HCC_FUNCTION_IDX_SUBV3I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_SUBV3I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_SUBV3I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_SUBV3U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8) }, },
	[HCC_FUNCTION_IDX_SUBV3U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16) }, },
	[HCC_FUNCTION_IDX_SUBV3U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32) }, },
	[HCC_FUNCTION_IDX_SUBV3U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64) }, },
	[HCC_FUNCTION_IDX_SUBV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_SUBV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_SUBV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_SUBV4I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8) }, },
	[HCC_FUNCTION_IDX_SUBV4I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_SUBV4I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_SUBV4I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_SUBV4U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8) }, },
	[HCC_FUNCTION_IDX_SUBV4U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16) }, },
	[HCC_FUNCTION_IDX_SUBV4U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32) }, },
	[HCC_FUNCTION_IDX_SUBV4U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64) }, },
	[HCC_FUNCTION_IDX_MULV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_MULV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_MULV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_MULV2I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8) }, },
	[HCC_FUNCTION_IDX_MULV2I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_MULV2I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_MULV2I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_MULV2U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8) }, },
	[HCC_FUNCTION_IDX_MULV2U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16) }, },
	[HCC_FUNCTION_IDX_MULV2U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32) }, },
	[HCC_FUNCTION_IDX_MULV2U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64) }, },
	[HCC_FUNCTION_IDX_MULV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_MULV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_MULV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_MULV3I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8) }, },
	[HCC_FUNCTION_IDX_MULV3I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_MULV3I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_MULV3I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_MULV3U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8) }, },
	[HCC_FUNCTION_IDX_MULV3U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16) }, },
	[HCC_FUNCTION_IDX_MULV3U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32) }, },
	[HCC_FUNCTION_IDX_MULV3U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64) }, },
	[HCC_FUNCTION_IDX_MULV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_MULV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_MULV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_MULV4I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8) }, },
	[HCC_FUNCTION_IDX_MULV4I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_MULV4I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_MULV4I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_MULV4U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8) }, },
	[HCC_FUNCTION_IDX_MULV4U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16) }, },
	[HCC_FUNCTION_IDX_MULV4U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32) }, },
	[HCC_FUNCTION_IDX_MULV4U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64) }, },
	[HCC_FUNCTION_IDX_DIVV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_DIVV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_DIVV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_DIVV2I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8) }, },
	[HCC_FUNCTION_IDX_DIVV2I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_DIVV2I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_DIVV2I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_DIVV2U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8) }, },
	[HCC_FUNCTION_IDX_DIVV2U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16) }, },
	[HCC_FUNCTION_IDX_DIVV2U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32) }, },
	[HCC_FUNCTION_IDX_DIVV2U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64) }, },
	[HCC_FUNCTION_IDX_DIVV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_DIVV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_DIVV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_DIVV3I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8) }, },
	[HCC_FUNCTION_IDX_DIVV3I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_DIVV3I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_DIVV3I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_DIVV3U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8) }, },
	[HCC_FUNCTION_IDX_DIVV3U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16) }, },
	[HCC_FUNCTION_IDX_DIVV3U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32) }, },
	[HCC_FUNCTION_IDX_DIVV3U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64) }, },
	[HCC_FUNCTION_IDX_DIVV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_DIVV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_DIVV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_DIVV4I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8) }, },
	[HCC_FUNCTION_IDX_DIVV4I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_DIVV4I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_DIVV4I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_DIVV4U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8) }, },
	[HCC_FUNCTION_IDX_DIVV4U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16) }, },
	[HCC_FUNCTION_IDX_DIVV4U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32) }, },
	[HCC_FUNCTION_IDX_DIVV4U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64) }, },
	[HCC_FUNCTION_IDX_MODV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_MODV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_MODV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_MODV2I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8) }, },
	[HCC_FUNCTION_IDX_MODV2I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_MODV2I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_MODV2I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_MODV2U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8) }, },
	[HCC_FUNCTION_IDX_MODV2U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16) }, },
	[HCC_FUNCTION_IDX_MODV2U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32) }, },
	[HCC_FUNCTION_IDX_MODV2U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64) }, },
	[HCC_FUNCTION_IDX_MODV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_MODV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_MODV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_MODV3I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8) }, },
	[HCC_FUNCTION_IDX_MODV3I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_MODV3I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_MODV3I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_MODV3U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8) }, },
	[HCC_FUNCTION_IDX_MODV3U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16) }, },
	[HCC_FUNCTION_IDX_MODV3U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32) }, },
	[HCC_FUNCTION_IDX_MODV3U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64) }, },
	[HCC_FUNCTION_IDX_MODV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_MODV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_MODV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_MODV4I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8) }, },
	[HCC_FUNCTION_IDX_MODV4I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_MODV4I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_MODV4I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_MODV4U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8) }, },
	[HCC_FUNCTION_IDX_MODV4U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16) }, },
	[HCC_FUNCTION_IDX_MODV4U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32) }, },
	[HCC_FUNCTION_IDX_MODV4U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64) }, },
	[HCC_FUNCTION_IDX_EQV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_EQV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_EQV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_EQV2I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8) }, },
	[HCC_FUNCTION_IDX_EQV2I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_EQV2I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_EQV2I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_EQV2U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8) }, },
	[HCC_FUNCTION_IDX_EQV2U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16) }, },
	[HCC_FUNCTION_IDX_EQV2U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32) }, },
	[HCC_FUNCTION_IDX_EQV2U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64) }, },
	[HCC_FUNCTION_IDX_EQV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_EQV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_EQV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_EQV3I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8) }, },
	[HCC_FUNCTION_IDX_EQV3I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_EQV3I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_EQV3I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_EQV3U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8) }, },
	[HCC_FUNCTION_IDX_EQV3U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16) }, },
	[HCC_FUNCTION_IDX_EQV3U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32) }, },
	[HCC_FUNCTION_IDX_EQV3U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64) }, },
	[HCC_FUNCTION_IDX_EQV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_EQV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_EQV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_EQV4I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8) }, },
	[HCC_FUNCTION_IDX_EQV4I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_EQV4I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_EQV4I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_EQV4U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8) }, },
	[HCC_FUNCTION_IDX_EQV4U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16) }, },
	[HCC_FUNCTION_IDX_EQV4U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32) }, },
	[HCC_FUNCTION_IDX_EQV4U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64) }, },
	[HCC_FUNCTION_IDX_NEQV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_NEQV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_NEQV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_NEQV2I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8) }, },
	[HCC_FUNCTION_IDX_NEQV2I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_NEQV2I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_NEQV2I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_NEQV2U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8) }, },
	[HCC_FUNCTION_IDX_NEQV2U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16) }, },
	[HCC_FUNCTION_IDX_NEQV2U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32) }, },
	[HCC_FUNCTION_IDX_NEQV2U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64) }, },
	[HCC_FUNCTION_IDX_NEQV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_NEQV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_NEQV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_NEQV3I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8) }, },
	[HCC_FUNCTION_IDX_NEQV3I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_NEQV3I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_NEQV3I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_NEQV3U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8) }, },
	[HCC_FUNCTION_IDX_NEQV3U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16) }, },
	[HCC_FUNCTION_IDX_NEQV3U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32) }, },
	[HCC_FUNCTION_IDX_NEQV3U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64) }, },
	[HCC_FUNCTION_IDX_NEQV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_NEQV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_NEQV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_NEQV4I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8) }, },
	[HCC_FUNCTION_IDX_NEQV4I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_NEQV4I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_NEQV4I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_NEQV4U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8) }, },
	[HCC_FUNCTION_IDX_NEQV4U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16) }, },
	[HCC_FUNCTION_IDX_NEQV4U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32) }, },
	[HCC_FUNCTION_IDX_NEQV4U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64) }, },
	[HCC_FUNCTION_IDX_LTV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_LTV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_LTV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_LTV2I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8) }, },
	[HCC_FUNCTION_IDX_LTV2I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_LTV2I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_LTV2I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_LTV2U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8) }, },
	[HCC_FUNCTION_IDX_LTV2U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16) }, },
	[HCC_FUNCTION_IDX_LTV2U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32) }, },
	[HCC_FUNCTION_IDX_LTV2U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64) }, },
	[HCC_FUNCTION_IDX_LTV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_LTV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_LTV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_LTV3I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8) }, },
	[HCC_FUNCTION_IDX_LTV3I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_LTV3I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_LTV3I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_LTV3U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8) }, },
	[HCC_FUNCTION_IDX_LTV3U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16) }, },
	[HCC_FUNCTION_IDX_LTV3U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32) }, },
	[HCC_FUNCTION_IDX_LTV3U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64) }, },
	[HCC_FUNCTION_IDX_LTV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_LTV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_LTV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_LTV4I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8) }, },
	[HCC_FUNCTION_IDX_LTV4I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_LTV4I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_LTV4I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_LTV4U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8) }, },
	[HCC_FUNCTION_IDX_LTV4U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16) }, },
	[HCC_FUNCTION_IDX_LTV4U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32) }, },
	[HCC_FUNCTION_IDX_LTV4U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64) }, },
	[HCC_FUNCTION_IDX_LTEQV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_LTEQV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_LTEQV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_LTEQV2I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8) }, },
	[HCC_FUNCTION_IDX_LTEQV2I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_LTEQV2I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_LTEQV2I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_LTEQV2U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8) }, },
	[HCC_FUNCTION_IDX_LTEQV2U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16) }, },
	[HCC_FUNCTION_IDX_LTEQV2U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32) }, },
	[HCC_FUNCTION_IDX_LTEQV2U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64) }, },
	[HCC_FUNCTION_IDX_LTEQV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_LTEQV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_LTEQV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_LTEQV3I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8) }, },
	[HCC_FUNCTION_IDX_LTEQV3I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_LTEQV3I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_LTEQV3I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_LTEQV3U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8) }, },
	[HCC_FUNCTION_IDX_LTEQV3U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16) }, },
	[HCC_FUNCTION_IDX_LTEQV3U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32) }, },
	[HCC_FUNCTION_IDX_LTEQV3U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64) }, },
	[HCC_FUNCTION_IDX_LTEQV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_LTEQV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_LTEQV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_LTEQV4I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8) }, },
	[HCC_FUNCTION_IDX_LTEQV4I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_LTEQV4I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_LTEQV4I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_LTEQV4U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8) }, },
	[HCC_FUNCTION_IDX_LTEQV4U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16) }, },
	[HCC_FUNCTION_IDX_LTEQV4U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32) }, },
	[HCC_FUNCTION_IDX_LTEQV4U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64) }, },
	[HCC_FUNCTION_IDX_GTV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_GTV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_GTV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_GTV2I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8) }, },
	[HCC_FUNCTION_IDX_GTV2I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_GTV2I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_GTV2I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_GTV2U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8) }, },
	[HCC_FUNCTION_IDX_GTV2U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16) }, },
	[HCC_FUNCTION_IDX_GTV2U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32) }, },
	[HCC_FUNCTION_IDX_GTV2U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64) }, },
	[HCC_FUNCTION_IDX_GTV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_GTV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_GTV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_GTV3I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8) }, },
	[HCC_FUNCTION_IDX_GTV3I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_GTV3I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_GTV3I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_GTV3U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8) }, },
	[HCC_FUNCTION_IDX_GTV3U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16) }, },
	[HCC_FUNCTION_IDX_GTV3U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32) }, },
	[HCC_FUNCTION_IDX_GTV3U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64) }, },
	[HCC_FUNCTION_IDX_GTV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_GTV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_GTV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_GTV4I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8) }, },
	[HCC_FUNCTION_IDX_GTV4I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_GTV4I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_GTV4I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_GTV4U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8) }, },
	[HCC_FUNCTION_IDX_GTV4U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16) }, },
	[HCC_FUNCTION_IDX_GTV4U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32) }, },
	[HCC_FUNCTION_IDX_GTV4U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64) }, },
	[HCC_FUNCTION_IDX_GTEQV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_GTEQV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_GTEQV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_GTEQV2I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8) }, },
	[HCC_FUNCTION_IDX_GTEQV2I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_GTEQV2I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_GTEQV2I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_GTEQV2U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8) }, },
	[HCC_FUNCTION_IDX_GTEQV2U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16) }, },
	[HCC_FUNCTION_IDX_GTEQV2U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32) }, },
	[HCC_FUNCTION_IDX_GTEQV2U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64) }, },
	[HCC_FUNCTION_IDX_GTEQV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_GTEQV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_GTEQV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_GTEQV3I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8) }, },
	[HCC_FUNCTION_IDX_GTEQV3I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_GTEQV3I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_GTEQV3I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_GTEQV3U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8) }, },
	[HCC_FUNCTION_IDX_GTEQV3U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16) }, },
	[HCC_FUNCTION_IDX_GTEQV3U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32) }, },
	[HCC_FUNCTION_IDX_GTEQV3U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64) }, },
	[HCC_FUNCTION_IDX_GTEQV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_GTEQV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_GTEQV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_GTEQV4I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8) }, },
	[HCC_FUNCTION_IDX_GTEQV4I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_GTEQV4I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_GTEQV4I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_GTEQV4U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8) }, },
	[HCC_FUNCTION_IDX_GTEQV4U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16) }, },
	[HCC_FUNCTION_IDX_GTEQV4U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32) }, },
	[HCC_FUNCTION_IDX_GTEQV4U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64) }, },
	[HCC_FUNCTION_IDX_NEGV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_NEGV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_NEGV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_NEGV2I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8) }, },
	[HCC_FUNCTION_IDX_NEGV2I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_NEGV2I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_NEGV2I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_NEGV2U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8) }, },
	[HCC_FUNCTION_IDX_NEGV2U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16) }, },
	[HCC_FUNCTION_IDX_NEGV2U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32) }, },
	[HCC_FUNCTION_IDX_NEGV2U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64) }, },
	[HCC_FUNCTION_IDX_NEGV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_NEGV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_NEGV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_NEGV3I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8) }, },
	[HCC_FUNCTION_IDX_NEGV3I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_NEGV3I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_NEGV3I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_NEGV3U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8) }, },
	[HCC_FUNCTION_IDX_NEGV3U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16) }, },
	[HCC_FUNCTION_IDX_NEGV3U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32) }, },
	[HCC_FUNCTION_IDX_NEGV3U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64) }, },
	[HCC_FUNCTION_IDX_NEGV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_NEGV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_NEGV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_NEGV4I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8) }, },
	[HCC_FUNCTION_IDX_NEGV4I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_NEGV4I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_NEGV4I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_NEGV4U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8) }, },
	[HCC_FUNCTION_IDX_NEGV4U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16) }, },
	[HCC_FUNCTION_IDX_NEGV4U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32) }, },
	[HCC_FUNCTION_IDX_NEGV4U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64) }, },
	[HCC_FUNCTION_IDX_MINV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_MINV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_MINV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_MINV2I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8) }, },
	[HCC_FUNCTION_IDX_MINV2I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_MINV2I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_MINV2I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_MINV2U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8) }, },
	[HCC_FUNCTION_IDX_MINV2U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16) }, },
	[HCC_FUNCTION_IDX_MINV2U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32) }, },
	[HCC_FUNCTION_IDX_MINV2U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64) }, },
	[HCC_FUNCTION_IDX_MINV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_MINV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_MINV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_MINV3I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8) }, },
	[HCC_FUNCTION_IDX_MINV3I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_MINV3I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_MINV3I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_MINV3U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8) }, },
	[HCC_FUNCTION_IDX_MINV3U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16) }, },
	[HCC_FUNCTION_IDX_MINV3U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32) }, },
	[HCC_FUNCTION_IDX_MINV3U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64) }, },
	[HCC_FUNCTION_IDX_MINV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_MINV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_MINV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_MINV4I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8) }, },
	[HCC_FUNCTION_IDX_MINV4I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_MINV4I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_MINV4I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_MINV4U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8) }, },
	[HCC_FUNCTION_IDX_MINV4U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16) }, },
	[HCC_FUNCTION_IDX_MINV4U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32) }, },
	[HCC_FUNCTION_IDX_MINV4U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64) }, },
	[HCC_FUNCTION_IDX_MAXV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_MAXV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_MAXV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_MAXV2I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8) }, },
	[HCC_FUNCTION_IDX_MAXV2I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_MAXV2I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_MAXV2I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_MAXV2U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8) }, },
	[HCC_FUNCTION_IDX_MAXV2U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16) }, },
	[HCC_FUNCTION_IDX_MAXV2U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32) }, },
	[HCC_FUNCTION_IDX_MAXV2U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64) }, },
	[HCC_FUNCTION_IDX_MAXV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_MAXV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_MAXV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_MAXV3I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8) }, },
	[HCC_FUNCTION_IDX_MAXV3I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_MAXV3I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_MAXV3I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_MAXV3U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8) }, },
	[HCC_FUNCTION_IDX_MAXV3U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16) }, },
	[HCC_FUNCTION_IDX_MAXV3U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32) }, },
	[HCC_FUNCTION_IDX_MAXV3U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64) }, },
	[HCC_FUNCTION_IDX_MAXV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_MAXV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_MAXV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_MAXV4I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8) }, },
	[HCC_FUNCTION_IDX_MAXV4I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_MAXV4I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_MAXV4I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_MAXV4U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8) }, },
	[HCC_FUNCTION_IDX_MAXV4U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16) }, },
	[HCC_FUNCTION_IDX_MAXV4U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32) }, },
	[HCC_FUNCTION_IDX_MAXV4U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64) }, },
	[HCC_FUNCTION_IDX_CLAMPV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_CLAMPV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_CLAMPV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_CLAMPV2I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8) }, },
	[HCC_FUNCTION_IDX_CLAMPV2I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_CLAMPV2I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_CLAMPV2I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_CLAMPV2U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8) }, },
	[HCC_FUNCTION_IDX_CLAMPV2U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16) }, },
	[HCC_FUNCTION_IDX_CLAMPV2U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32) }, },
	[HCC_FUNCTION_IDX_CLAMPV2U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64) }, },
	[HCC_FUNCTION_IDX_CLAMPV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_CLAMPV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_CLAMPV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_CLAMPV3I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8) }, },
	[HCC_FUNCTION_IDX_CLAMPV3I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_CLAMPV3I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_CLAMPV3I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_CLAMPV3U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8) }, },
	[HCC_FUNCTION_IDX_CLAMPV3U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16) }, },
	[HCC_FUNCTION_IDX_CLAMPV3U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32) }, },
	[HCC_FUNCTION_IDX_CLAMPV3U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64) }, },
	[HCC_FUNCTION_IDX_CLAMPV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_CLAMPV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_CLAMPV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_CLAMPV4I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8) }, },
	[HCC_FUNCTION_IDX_CLAMPV4I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_CLAMPV4I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_CLAMPV4I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_CLAMPV4U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8) }, },
	[HCC_FUNCTION_IDX_CLAMPV4U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16) }, },
	[HCC_FUNCTION_IDX_CLAMPV4U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32) }, },
	[HCC_FUNCTION_IDX_CLAMPV4U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64) }, },
	[HCC_FUNCTION_IDX_SIGNV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_SIGNV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_SIGNV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_SIGNV2I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8) }, },
	[HCC_FUNCTION_IDX_SIGNV2I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_SIGNV2I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_SIGNV2I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_SIGNV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_SIGNV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_SIGNV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_SIGNV3I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8) }, },
	[HCC_FUNCTION_IDX_SIGNV3I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_SIGNV3I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_SIGNV3I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_SIGNV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_SIGNV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_SIGNV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_SIGNV4I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8) }, },
	[HCC_FUNCTION_IDX_SIGNV4I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_SIGNV4I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_SIGNV4I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_ABSV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_ABSV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_ABSV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_ABSV2I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8) }, },
	[HCC_FUNCTION_IDX_ABSV2I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_ABSV2I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_ABSV2I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_ABSV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_ABSV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_ABSV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_ABSV3I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8) }, },
	[HCC_FUNCTION_IDX_ABSV3I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_ABSV3I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_ABSV3I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_ABSV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_ABSV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_ABSV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_ABSV4I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8) }, },
	[HCC_FUNCTION_IDX_ABSV4I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_ABSV4I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_ABSV4I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_BITANDV2I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8) }, },
	[HCC_FUNCTION_IDX_BITANDV2I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_BITANDV2I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_BITANDV2I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_BITANDV2U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8) }, },
	[HCC_FUNCTION_IDX_BITANDV2U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16) }, },
	[HCC_FUNCTION_IDX_BITANDV2U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32) }, },
	[HCC_FUNCTION_IDX_BITANDV2U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64) }, },
	[HCC_FUNCTION_IDX_BITANDV3I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8) }, },
	[HCC_FUNCTION_IDX_BITANDV3I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_BITANDV3I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_BITANDV3I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_BITANDV3U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8) }, },
	[HCC_FUNCTION_IDX_BITANDV3U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16) }, },
	[HCC_FUNCTION_IDX_BITANDV3U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32) }, },
	[HCC_FUNCTION_IDX_BITANDV3U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64) }, },
	[HCC_FUNCTION_IDX_BITANDV4I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8) }, },
	[HCC_FUNCTION_IDX_BITANDV4I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_BITANDV4I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_BITANDV4I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_BITANDV4U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8) }, },
	[HCC_FUNCTION_IDX_BITANDV4U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16) }, },
	[HCC_FUNCTION_IDX_BITANDV4U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32) }, },
	[HCC_FUNCTION_IDX_BITANDV4U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64) }, },
	[HCC_FUNCTION_IDX_BITORV2I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8) }, },
	[HCC_FUNCTION_IDX_BITORV2I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_BITORV2I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_BITORV2I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_BITORV2U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8) }, },
	[HCC_FUNCTION_IDX_BITORV2U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16) }, },
	[HCC_FUNCTION_IDX_BITORV2U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32) }, },
	[HCC_FUNCTION_IDX_BITORV2U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64) }, },
	[HCC_FUNCTION_IDX_BITORV3I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8) }, },
	[HCC_FUNCTION_IDX_BITORV3I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_BITORV3I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_BITORV3I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_BITORV3U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8) }, },
	[HCC_FUNCTION_IDX_BITORV3U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16) }, },
	[HCC_FUNCTION_IDX_BITORV3U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32) }, },
	[HCC_FUNCTION_IDX_BITORV3U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64) }, },
	[HCC_FUNCTION_IDX_BITORV4I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8) }, },
	[HCC_FUNCTION_IDX_BITORV4I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_BITORV4I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_BITORV4I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_BITORV4U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8) }, },
	[HCC_FUNCTION_IDX_BITORV4U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16) }, },
	[HCC_FUNCTION_IDX_BITORV4U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32) }, },
	[HCC_FUNCTION_IDX_BITORV4U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64) }, },
	[HCC_FUNCTION_IDX_BITXORV2I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8) }, },
	[HCC_FUNCTION_IDX_BITXORV2I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_BITXORV2I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_BITXORV2I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_BITXORV2U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8) }, },
	[HCC_FUNCTION_IDX_BITXORV2U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16) }, },
	[HCC_FUNCTION_IDX_BITXORV2U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32) }, },
	[HCC_FUNCTION_IDX_BITXORV2U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64) }, },
	[HCC_FUNCTION_IDX_BITXORV3I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8) }, },
	[HCC_FUNCTION_IDX_BITXORV3I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_BITXORV3I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_BITXORV3I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_BITXORV3U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8) }, },
	[HCC_FUNCTION_IDX_BITXORV3U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16) }, },
	[HCC_FUNCTION_IDX_BITXORV3U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32) }, },
	[HCC_FUNCTION_IDX_BITXORV3U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64) }, },
	[HCC_FUNCTION_IDX_BITXORV4I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8) }, },
	[HCC_FUNCTION_IDX_BITXORV4I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_BITXORV4I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_BITXORV4I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_BITXORV4U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8) }, },
	[HCC_FUNCTION_IDX_BITXORV4U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16) }, },
	[HCC_FUNCTION_IDX_BITXORV4U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32) }, },
	[HCC_FUNCTION_IDX_BITXORV4U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64) }, },
	[HCC_FUNCTION_IDX_BITSHLV2I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8) }, },
	[HCC_FUNCTION_IDX_BITSHLV2I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_BITSHLV2I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_BITSHLV2I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_BITSHLV2U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8) }, },
	[HCC_FUNCTION_IDX_BITSHLV2U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16) }, },
	[HCC_FUNCTION_IDX_BITSHLV2U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32) }, },
	[HCC_FUNCTION_IDX_BITSHLV2U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64) }, },
	[HCC_FUNCTION_IDX_BITSHLV3I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8) }, },
	[HCC_FUNCTION_IDX_BITSHLV3I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_BITSHLV3I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_BITSHLV3I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_BITSHLV3U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8) }, },
	[HCC_FUNCTION_IDX_BITSHLV3U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16) }, },
	[HCC_FUNCTION_IDX_BITSHLV3U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32) }, },
	[HCC_FUNCTION_IDX_BITSHLV3U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64) }, },
	[HCC_FUNCTION_IDX_BITSHLV4I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8) }, },
	[HCC_FUNCTION_IDX_BITSHLV4I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_BITSHLV4I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_BITSHLV4I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_BITSHLV4U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8) }, },
	[HCC_FUNCTION_IDX_BITSHLV4U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16) }, },
	[HCC_FUNCTION_IDX_BITSHLV4U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32) }, },
	[HCC_FUNCTION_IDX_BITSHLV4U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64) }, },
	[HCC_FUNCTION_IDX_BITSHRV2I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8) }, },
	[HCC_FUNCTION_IDX_BITSHRV2I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_BITSHRV2I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_BITSHRV2I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_BITSHRV2U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8) }, },
	[HCC_FUNCTION_IDX_BITSHRV2U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16) }, },
	[HCC_FUNCTION_IDX_BITSHRV2U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32) }, },
	[HCC_FUNCTION_IDX_BITSHRV2U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64) }, },
	[HCC_FUNCTION_IDX_BITSHRV3I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8) }, },
	[HCC_FUNCTION_IDX_BITSHRV3I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_BITSHRV3I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_BITSHRV3I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_BITSHRV3U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8) }, },
	[HCC_FUNCTION_IDX_BITSHRV3U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16) }, },
	[HCC_FUNCTION_IDX_BITSHRV3U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32) }, },
	[HCC_FUNCTION_IDX_BITSHRV3U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64) }, },
	[HCC_FUNCTION_IDX_BITSHRV4I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8) }, },
	[HCC_FUNCTION_IDX_BITSHRV4I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_BITSHRV4I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_BITSHRV4I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_BITSHRV4U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8) }, },
	[HCC_FUNCTION_IDX_BITSHRV4U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16) }, },
	[HCC_FUNCTION_IDX_BITSHRV4U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32) }, },
	[HCC_FUNCTION_IDX_BITSHRV4U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64) }, },
	[HCC_FUNCTION_IDX_BITNOTV2I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I8) }, },
	[HCC_FUNCTION_IDX_BITNOTV2I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_BITNOTV2I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_BITNOTV2I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_BITNOTV2U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U8) }, },
	[HCC_FUNCTION_IDX_BITNOTV2U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U16) }, },
	[HCC_FUNCTION_IDX_BITNOTV2U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U32) }, },
	[HCC_FUNCTION_IDX_BITNOTV2U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2U64) }, },
	[HCC_FUNCTION_IDX_BITNOTV3I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I8) }, },
	[HCC_FUNCTION_IDX_BITNOTV3I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_BITNOTV3I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_BITNOTV3I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_BITNOTV3U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U8) }, },
	[HCC_FUNCTION_IDX_BITNOTV3U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U16) }, },
	[HCC_FUNCTION_IDX_BITNOTV3U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U32) }, },
	[HCC_FUNCTION_IDX_BITNOTV3U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3U64) }, },
	[HCC_FUNCTION_IDX_BITNOTV4I8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I8) }, },
	[HCC_FUNCTION_IDX_BITNOTV4I16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_BITNOTV4I32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_BITNOTV4I64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_BITNOTV4U8] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U8) }, },
	[HCC_FUNCTION_IDX_BITNOTV4U16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U16) }, },
	[HCC_FUNCTION_IDX_BITNOTV4U32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U32) }, },
	[HCC_FUNCTION_IDX_BITNOTV4U64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4U64) }, },
	[HCC_FUNCTION_IDX_FMAV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_FMAV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_FMAV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_FMAV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_FMAV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_FMAV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_FMAV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_FMAV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_FMAV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_FLOORV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_FLOORV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_FLOORV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_FLOORV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_FLOORV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_FLOORV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_FLOORV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_FLOORV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_FLOORV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_CEILV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_CEILV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_CEILV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_CEILV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_CEILV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_CEILV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_CEILV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_CEILV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_CEILV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_ROUNDV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_ROUNDV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_ROUNDV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_ROUNDV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_ROUNDV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_ROUNDV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_ROUNDV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_ROUNDV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_ROUNDV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_TRUNCV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_TRUNCV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_TRUNCV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_TRUNCV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_TRUNCV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_TRUNCV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_TRUNCV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_TRUNCV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_TRUNCV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_FRACTV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_FRACTV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_FRACTV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_FRACTV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_FRACTV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_FRACTV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_FRACTV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_FRACTV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_FRACTV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_RADIANSV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_RADIANSV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_RADIANSV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_RADIANSV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_RADIANSV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_RADIANSV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_RADIANSV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_RADIANSV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_RADIANSV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_DEGREESV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_DEGREESV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_DEGREESV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_DEGREESV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_DEGREESV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_DEGREESV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_DEGREESV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_DEGREESV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_DEGREESV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_STEPV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_STEPV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_STEPV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_STEPV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_STEPV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_STEPV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_STEPV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_STEPV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_STEPV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_SMOOTHSTEPV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_SMOOTHSTEPV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_SMOOTHSTEPV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_SMOOTHSTEPV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_SMOOTHSTEPV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_SMOOTHSTEPV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_SMOOTHSTEPV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_SMOOTHSTEPV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_SMOOTHSTEPV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_BITSTOV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16) }, },
	[HCC_FUNCTION_IDX_BITSTOV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32) }, },
	[HCC_FUNCTION_IDX_BITSTOV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64) }, },
	[HCC_FUNCTION_IDX_BITSTOV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16) }, },
	[HCC_FUNCTION_IDX_BITSTOV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32) }, },
	[HCC_FUNCTION_IDX_BITSTOV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64) }, },
	[HCC_FUNCTION_IDX_BITSTOV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16) }, },
	[HCC_FUNCTION_IDX_BITSTOV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32) }, },
	[HCC_FUNCTION_IDX_BITSTOV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64) }, },
	[HCC_FUNCTION_IDX_BITSFROMV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_BITSFROMV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_BITSFROMV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2I64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_BITSFROMV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_BITSFROMV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_BITSFROMV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3I64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_BITSFROMV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_BITSFROMV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_BITSFROMV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4I64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_SINV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_SINV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_SINV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_SINV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_SINV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_SINV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_SINV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_SINV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_SINV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_COSV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_COSV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_COSV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_COSV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_COSV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_COSV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_COSV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_COSV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_COSV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_TANV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_TANV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_TANV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_TANV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_TANV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_TANV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_TANV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_TANV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_TANV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_ASINV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_ASINV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_ASINV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_ASINV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_ASINV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_ASINV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_ASINV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_ASINV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_ASINV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_ACOSV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_ACOSV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_ACOSV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_ACOSV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_ACOSV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_ACOSV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_ACOSV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_ACOSV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_ACOSV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_ATANV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_ATANV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_ATANV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_ATANV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_ATANV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_ATANV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_ATANV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_ATANV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_ATANV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_SINHV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_SINHV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_SINHV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_SINHV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_SINHV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_SINHV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_SINHV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_SINHV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_SINHV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_COSHV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_COSHV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_COSHV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_COSHV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_COSHV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_COSHV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_COSHV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_COSHV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_COSHV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_TANHV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_TANHV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_TANHV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_TANHV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_TANHV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_TANHV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_TANHV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_TANHV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_TANHV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_ASINHV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_ASINHV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_ASINHV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_ASINHV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_ASINHV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_ASINHV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_ASINHV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_ASINHV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_ASINHV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_ACOSHV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_ACOSHV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_ACOSHV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_ACOSHV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_ACOSHV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_ACOSHV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_ACOSHV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_ACOSHV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_ACOSHV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_ATANHV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_ATANHV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_ATANHV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_ATANHV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_ATANHV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_ATANHV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_ATANHV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_ATANHV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_ATANHV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_ATAN2V2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_ATAN2V2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_ATAN2V2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_ATAN2V3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_ATAN2V3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_ATAN2V3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_ATAN2V4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_ATAN2V4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_ATAN2V4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_POWV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_POWV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_POWV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_POWV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_POWV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_POWV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_POWV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_POWV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_POWV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_EXPV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_EXPV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_EXPV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_EXPV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_EXPV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_EXPV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_EXPV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_EXPV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_EXPV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_LOGV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_LOGV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_LOGV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_LOGV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_LOGV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_LOGV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_LOGV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_LOGV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_LOGV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_EXP2V2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_EXP2V2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_EXP2V2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_EXP2V3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_EXP2V3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_EXP2V3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_EXP2V4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_EXP2V4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_EXP2V4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_LOG2V2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_LOG2V2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_LOG2V2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_LOG2V3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_LOG2V3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_LOG2V3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_LOG2V4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_LOG2V4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_LOG2V4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_SQRTV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_SQRTV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_SQRTV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_SQRTV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_SQRTV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_SQRTV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_SQRTV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_SQRTV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_SQRTV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_RSQRTV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_RSQRTV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_RSQRTV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_RSQRTV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_RSQRTV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_RSQRTV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_RSQRTV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_RSQRTV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_RSQRTV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_ISINFV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_ISINFV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_ISINFV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_ISINFV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_ISINFV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_ISINFV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_ISINFV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_ISINFV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_ISINFV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_ISNANV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_ISNANV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_ISNANV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_ISNANV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_ISNANV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_ISNANV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_ISNANV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_ISNANV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_ISNANV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4BOOL), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_LERPV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_LERPV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_LERPV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_LERPV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_LERPV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_LERPV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_LERPV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_LERPV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_LERPV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_DOTV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_DOTV2F32] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_DOTV2F64] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_DOTV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_DOTV3F32] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_DOTV3F64] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_DOTV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_DOTV4F32] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_DOTV4F64] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_LENV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_LENV2F32] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_LENV2F64] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_LENV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_LENV3F32] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_LENV3F64] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_LENV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_HALF, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_LENV4F32] = { .return_data_type = HCC_DATA_TYPE_FLOAT, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_LENV4F64] = { .return_data_type = HCC_DATA_TYPE_DOUBLE, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_NORMV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_NORMV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_NORMV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_NORMV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_NORMV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_NORMV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_NORMV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_NORMV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_NORMV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_REFLECTV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16) }, },
	[HCC_FUNCTION_IDX_REFLECTV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_REFLECTV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_REFLECTV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16) }, },
	[HCC_FUNCTION_IDX_REFLECTV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_REFLECTV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_REFLECTV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16) }, },
	[HCC_FUNCTION_IDX_REFLECTV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_REFLECTV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_REFRACTV2F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F16), HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_REFRACTV2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_REFRACTV2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_REFRACTV3F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F16), HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_REFRACTV3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_REFRACTV3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_REFRACTV4F16] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F16), HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_REFRACTV4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_REFRACTV4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 3, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_PACKF16X2V2F32] = { .return_data_type = HCC_DATA_TYPE_UINT32, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_UNPACKF16X2V2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_UINT32 }, },
	[HCC_FUNCTION_IDX_PACKU16X2V2F32] = { .return_data_type = HCC_DATA_TYPE_UINT32, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_UNPACKU16X2V2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_UINT32 }, },
	[HCC_FUNCTION_IDX_PACKS16X2V2F32] = { .return_data_type = HCC_DATA_TYPE_UINT32, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_UNPACKS16X2V2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_UINT32 }, },
	[HCC_FUNCTION_IDX_PACKU8X4V4F32] = { .return_data_type = HCC_DATA_TYPE_UINT32, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_UNPACKU8X4V4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_UINT32 }, },
	[HCC_FUNCTION_IDX_PACKS8X4V4F32] = { .return_data_type = HCC_DATA_TYPE_UINT32, .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_UNPACKS8X4V4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_UINT32 }, },

	//
	// libhccstd/math.h - matrix
	//
	[HCC_FUNCTION_IDX_MULM22M22F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT22F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT22F32), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT22F32) }, },
	[HCC_FUNCTION_IDX_MULM22M22F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT22F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT22F64), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT22F64) }, },
	[HCC_FUNCTION_IDX_MULM23M32F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT23F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT23F32), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT32F32) }, },
	[HCC_FUNCTION_IDX_MULM23M32F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT23F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT23F64), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT32F64) }, },
	[HCC_FUNCTION_IDX_MULM24M42F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT24F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT24F32), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT42F32) }, },
	[HCC_FUNCTION_IDX_MULM24M42F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT24F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT24F64), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT42F64) }, },
	[HCC_FUNCTION_IDX_MULM32M23F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT32F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT32F32), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT23F32) }, },
	[HCC_FUNCTION_IDX_MULM32M23F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT32F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT32F64), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT23F64) }, },
	[HCC_FUNCTION_IDX_MULM33M33F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT33F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT33F32), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT33F32) }, },
	[HCC_FUNCTION_IDX_MULM33M33F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT33F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT33F64), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT33F64) }, },
	[HCC_FUNCTION_IDX_MULM34M43F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT34F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT34F32), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT43F32) }, },
	[HCC_FUNCTION_IDX_MULM34M43F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT34F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT34F64), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT43F64) }, },
	[HCC_FUNCTION_IDX_MULM42M24F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT42F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT42F32), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT24F32) }, },
	[HCC_FUNCTION_IDX_MULM42M24F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT42F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT42F64), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT24F64) }, },
	[HCC_FUNCTION_IDX_MULM43M34F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT43F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT43F32), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT34F32) }, },
	[HCC_FUNCTION_IDX_MULM43M34F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT43F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT43F64), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT34F64) }, },
	[HCC_FUNCTION_IDX_MULM44M44F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT44F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT44F32), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT44F32) }, },
	[HCC_FUNCTION_IDX_MULM44M44F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT44F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT44F64), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT44F64) }, },
	[HCC_FUNCTION_IDX_MULSM22F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT22F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT22F32), HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_MULSM22F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT22F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT22F64), HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_MULSM23F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT23F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT23F32), HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_MULSM23F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT23F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT23F64), HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_MULSM24F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT24F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT24F32), HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_MULSM24F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT24F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT24F64), HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_MULSM32F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT32F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT32F32), HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_MULSM32F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT32F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT32F64), HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_MULSM33F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT33F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT33F32), HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_MULSM33F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT33F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT33F64), HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_MULSM34F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT34F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT34F32), HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_MULSM34F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT34F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT34F64), HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_MULSM42F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT42F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT42F32), HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_MULSM42F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT42F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT42F64), HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_MULSM43F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT43F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT43F32), HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_MULSM43F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT43F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT43F64), HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_MULSM44F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT44F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT44F32), HCC_DATA_TYPE_FLOAT }, },
	[HCC_FUNCTION_IDX_MULSM44F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT44F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT44F64), HCC_DATA_TYPE_DOUBLE }, },
	[HCC_FUNCTION_IDX_MULM22V2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT22F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_MULM22V2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT22F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_MULM23V2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT23F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_MULM23V2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT23F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_MULM24V2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT24F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_MULM24V2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT24F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_MULM32V3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT32F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_MULM32V3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT32F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_MULM33V3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT33F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_MULM33V3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT33F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_MULM34V3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT34F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_MULM34V3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT34F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_MULM42V4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT42F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_MULM42V4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT42F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_MULM43V4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT43F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_MULM43V4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT43F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_MULM44V4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT44F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_MULM44V4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT44F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_MULV2F32M22] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT22F32) }, },
	[HCC_FUNCTION_IDX_MULV2F64M22] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT22F64) }, },
	[HCC_FUNCTION_IDX_MULV3F32M23] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT23F32) }, },
	[HCC_FUNCTION_IDX_MULV3F64M23] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT23F64) }, },
	[HCC_FUNCTION_IDX_MULV4F32M24] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT24F32) }, },
	[HCC_FUNCTION_IDX_MULV4F64M24] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT24F64) }, },
	[HCC_FUNCTION_IDX_MULV2F32M32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT32F32) }, },
	[HCC_FUNCTION_IDX_MULV2F64M32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT32F64) }, },
	[HCC_FUNCTION_IDX_MULV3F32M33] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT33F32) }, },
	[HCC_FUNCTION_IDX_MULV3F64M33] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT33F64) }, },
	[HCC_FUNCTION_IDX_MULV4F32M34] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT34F32) }, },
	[HCC_FUNCTION_IDX_MULV4F64M34] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT34F64) }, },
	[HCC_FUNCTION_IDX_MULV2F32M42] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT42F32) }, },
	[HCC_FUNCTION_IDX_MULV2F64M42] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT42F64) }, },
	[HCC_FUNCTION_IDX_MULV3F32M43] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT43F32) }, },
	[HCC_FUNCTION_IDX_MULV3F64M43] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT43F64) }, },
	[HCC_FUNCTION_IDX_MULV4F32M44] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT44F32) }, },
	[HCC_FUNCTION_IDX_MULV4F64M44] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT44F64) }, },
	[HCC_FUNCTION_IDX_TRANSPOSEM22F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT22F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT22F32) }, },
	[HCC_FUNCTION_IDX_TRANSPOSEM22F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT22F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT22F64) }, },
	[HCC_FUNCTION_IDX_TRANSPOSEM23F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT32F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT23F32) }, },
	[HCC_FUNCTION_IDX_TRANSPOSEM23F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT32F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT23F64) }, },
	[HCC_FUNCTION_IDX_TRANSPOSEM24F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT42F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT24F32) }, },
	[HCC_FUNCTION_IDX_TRANSPOSEM24F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT42F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT24F64) }, },
	[HCC_FUNCTION_IDX_TRANSPOSEM32F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT23F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT32F32) }, },
	[HCC_FUNCTION_IDX_TRANSPOSEM32F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT23F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT32F64) }, },
	[HCC_FUNCTION_IDX_TRANSPOSEM33F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT33F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT33F32) }, },
	[HCC_FUNCTION_IDX_TRANSPOSEM33F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT33F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT33F64) }, },
	[HCC_FUNCTION_IDX_TRANSPOSEM34F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT43F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT34F32) }, },
	[HCC_FUNCTION_IDX_TRANSPOSEM34F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT43F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT34F64) }, },
	[HCC_FUNCTION_IDX_TRANSPOSEM42F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT24F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT42F32) }, },
	[HCC_FUNCTION_IDX_TRANSPOSEM42F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT24F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT42F64) }, },
	[HCC_FUNCTION_IDX_TRANSPOSEM43F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT34F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT43F32) }, },
	[HCC_FUNCTION_IDX_TRANSPOSEM43F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT34F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT43F64) }, },
	[HCC_FUNCTION_IDX_TRANSPOSEM44F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT44F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT44F32) }, },
	[HCC_FUNCTION_IDX_TRANSPOSEM44F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT44F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT44F64) }, },
	[HCC_FUNCTION_IDX_OUTERPRODUCTV2V2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT22F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_OUTERPRODUCTV2V2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT22F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_OUTERPRODUCTV2V3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT23F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_OUTERPRODUCTV2V3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT23F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_OUTERPRODUCTV2V4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT24F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_OUTERPRODUCTV2V4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT24F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_OUTERPRODUCTV3V2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT32F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_OUTERPRODUCTV3V2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT32F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_OUTERPRODUCTV3V3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT33F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_OUTERPRODUCTV3V3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT33F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_OUTERPRODUCTV3V4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT34F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_OUTERPRODUCTV3V4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT34F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_OUTERPRODUCTV4V2F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT42F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F32) }, },
	[HCC_FUNCTION_IDX_OUTERPRODUCTV4V2F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT42F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC2F64) }, },
	[HCC_FUNCTION_IDX_OUTERPRODUCTV4V3F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT43F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F32) }, },
	[HCC_FUNCTION_IDX_OUTERPRODUCTV4V3F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT43F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC3F64) }, },
	[HCC_FUNCTION_IDX_OUTERPRODUCTV4V4F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT44F32), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F32) }, },
	[HCC_FUNCTION_IDX_OUTERPRODUCTV4V4F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT44F64), .params_count = 2, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64), HCC_DATA_TYPE_TYPEDEF_VECTOR(HCC_VEC4F64) }, },
	[HCC_FUNCTION_IDX_DETERMINANTM22F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT22F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT22F32) }, },
	[HCC_FUNCTION_IDX_DETERMINANTM22F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT22F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT22F64) }, },
	[HCC_FUNCTION_IDX_DETERMINANTM33F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT33F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT33F32) }, },
	[HCC_FUNCTION_IDX_DETERMINANTM33F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT33F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT33F64) }, },
	[HCC_FUNCTION_IDX_DETERMINANTM44F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT44F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT44F32) }, },
	[HCC_FUNCTION_IDX_DETERMINANTM44F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT44F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT44F64) }, },
	[HCC_FUNCTION_IDX_INVERSEM22F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT22F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT22F32) }, },
	[HCC_FUNCTION_IDX_INVERSEM22F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT22F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT22F64) }, },
	[HCC_FUNCTION_IDX_INVERSEM33F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT33F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT33F32) }, },
	[HCC_FUNCTION_IDX_INVERSEM33F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT33F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT33F64) }, },
	[HCC_FUNCTION_IDX_INVERSEM44F32] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT44F32), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT44F32) }, },
	[HCC_FUNCTION_IDX_INVERSEM44F64] = { .return_data_type = HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT44F64), .params_count = 1, .param_data_types = { HCC_DATA_TYPE_TYPEDEF_MATRIX(HCC_MAT44F64) }, },
};

U8 hcc_data_type_basic_type_ranks[HCC_DATA_TYPE_BASIC_COUNT] = {
	[HCC_DATA_TYPE_BOOL] = 1,
	[HCC_DATA_TYPE_CHAR] = 2,
	[HCC_DATA_TYPE_SCHAR] = 2,
	[HCC_DATA_TYPE_UCHAR] = 2,
	[HCC_DATA_TYPE_SSHORT] = 3,
	[HCC_DATA_TYPE_USHORT] = 3,
	[HCC_DATA_TYPE_SINT] = 4,
	[HCC_DATA_TYPE_UINT] = 4,
	[HCC_DATA_TYPE_SLONG] = 5,
	[HCC_DATA_TYPE_ULONG] = 5,
	[HCC_DATA_TYPE_SLONGLONG] = 6,
	[HCC_DATA_TYPE_ULONGLONG] = 6,
	[HCC_DATA_TYPE_FLOAT] = 7,
	[HCC_DATA_TYPE_DOUBLE] = 8,
};

const char* hcc_data_type_basic_type_strings[HCC_DATA_TYPE_BASIC_COUNT] = {
	[HCC_DATA_TYPE_VOID] = "void",
	[HCC_DATA_TYPE_BOOL] = "bool",
	[HCC_DATA_TYPE_CHAR] = "char",
	[HCC_DATA_TYPE_SCHAR] = "signed char",
	[HCC_DATA_TYPE_UCHAR] = "unsigned char",
	[HCC_DATA_TYPE_SSHORT] = "signed short",
	[HCC_DATA_TYPE_USHORT] = "unsigned short",
	[HCC_DATA_TYPE_SINT] = "signed int",
	[HCC_DATA_TYPE_UINT] = "unsigned int",
	[HCC_DATA_TYPE_SLONG] = "signed long",
	[HCC_DATA_TYPE_ULONG] = "unsigned long",
	[HCC_DATA_TYPE_SLONGLONG] = "signed long long",
	[HCC_DATA_TYPE_ULONGLONG] = "unsigned long long",
	[HCC_DATA_TYPE_FLOAT] = "float",
	[HCC_DATA_TYPE_DOUBLE] = "double",
};

HccString hcc_data_type_string(HccCompiler* c, HccDataType data_type) {
	HccStringId string_id;
	U32 mask = data_type & HCC_DATA_TYPE_CONST_AND_VOLATILE_MASK;
	data_type = HCC_DATA_TYPE_STRIP_CONST_AND_VOLATILE(data_type);
	HccString string;
	char buf[1024];
	char buf2[1024];
	if (HCC_DATA_TYPE_IS_BASIC(data_type)) {
		string = hcc_string_c((char*)hcc_data_type_basic_type_strings[data_type]);
	} else {
		switch (data_type & 0xff) {
			case HCC_DATA_TYPE_TYPEDEF: {
				HccTypedef* typedef_ = hcc_typedef_get(c, data_type);
				string = hcc_string_table_get(&c->string_table, typedef_->identifier_string_id);
				break;
			};
			case HCC_DATA_TYPE_ARRAY: {
				HccArrayDataType* d = hcc_array_data_type_get(c, data_type);
				HccString element_string = hcc_data_type_string(c, d->element_data_type);
				HccConstant constant = hcc_constant_table_get(c, d->size_constant_id);
				U64 size;
				HCC_DEBUG_ASSERT(hcc_constant_as_uint(c, constant, &size), "internal error: array size is not an unsigned integer");
				U32 string_size = snprintf(buf, sizeof(buf), "%.*s[%zu]", (int)element_string.size, element_string.data, size);
				string = hcc_string(buf, string_size);
				break;
			};
			case HCC_DATA_TYPE_STRUCT:
			case HCC_DATA_TYPE_UNION:
			{
				char* compound_name = HCC_DATA_TYPE_IS_STRUCT(data_type) ? "struct" : "union";
				HccCompoundDataType* d = hcc_compound_data_type_get(c, data_type);
				HccString identifier = hcc_string_lit("<anonymous>");
				if (d->identifier_string_id.idx_plus_one) {
					identifier = hcc_string_table_get(&c->string_table, d->identifier_string_id);
				}
				U32 string_size = snprintf(buf, sizeof(buf), "%s(#%u) %.*s", compound_name, HCC_DATA_TYPE_IDX(data_type), (int)identifier.size, identifier.data);
				string = hcc_string(buf, string_size);
				break;
			};
			case HCC_DATA_TYPE_ENUM:
			{
				HccEnumDataType* d = hcc_enum_data_type_get(c, data_type);
				HccString identifier = hcc_string_lit("<anonymous>");
				if (d->identifier_string_id.idx_plus_one) {
					identifier = hcc_string_table_get(&c->string_table, d->identifier_string_id);
				}
				U32 string_size = snprintf(buf, sizeof(buf), "enum(#%u) %.*s", HCC_DATA_TYPE_IDX(data_type), (int)identifier.size, identifier.data);
				string = hcc_string(buf, string_size);
				break;
			};
			case HCC_DATA_TYPE_GENERIC_FLOAT:
				string = hcc_string_lit("__hcc_generic_float");
			default:
				HCC_ABORT("unhandled data type '%u'", data_type);
		}
	}

	if (mask) {
		const char* const_string = mask & HCC_DATA_TYPE_CONST_MASK ? "const " : "";
		const char* volatile_string = mask & HCC_DATA_TYPE_VOLATILE_MASK ? "volatile " : "";
		U32 string_size = snprintf(buf2, sizeof(buf2), "%s %s %.*s", const_string, volatile_string, (int)string.size, string.data);
		string = hcc_string(buf2, string_size);
	}

	string_id = hcc_string_table_deduplicate(&c->string_table, string.data, string.size);
	return hcc_string_table_get(&c->string_table, string_id);
}

void hcc_data_type_size_align(HccCompiler* c, HccDataType data_type, U64* size_out, U64* align_out) {
	data_type = hcc_typedef_resolve_and_strip_const_volatile(c, data_type);

	if (HCC_DATA_TYPE_IS_BASIC(data_type)) {
		*size_out = c->basic_type_size_and_aligns[data_type];
		*align_out = c->basic_type_size_and_aligns[data_type];
	} else {
		switch (data_type & 0xff) {
			case HCC_DATA_TYPE_STRUCT:
			case HCC_DATA_TYPE_UNION: {
				HccCompoundDataType* d = hcc_compound_data_type_get(c, data_type);
				*size_out = d->size;
				*align_out = d->align;
				break;
			};
			case HCC_DATA_TYPE_ARRAY: {
				HccArrayDataType* d = hcc_array_data_type_get(c, data_type);
				HccConstant constant = hcc_constant_table_get(c, d->size_constant_id);
				U64 count;
				hcc_constant_as_uint(c, constant, &count);

				U64 size;
				U64 align;
				hcc_data_type_size_align(c, d->element_data_type, &size, &align);

				*size_out = size * count;
				*align_out = align;
				break;
			};
			default:
				HCC_ABORT("unhandled data type '%u'", data_type);
		}
	}
}

void hcc_data_type_print_basic(HccCompiler* c, HccDataType data_type, void* data, FILE* f) {
	HCC_DEBUG_ASSERT(data_type < HCC_DATA_TYPE_BASIC_END, "internal error: expected a basic data type but got '%s'", hcc_data_type_string(c, data_type));

	U64 uint;
	S64 sint;
	F64 float_;
	switch (data_type) {
		case HCC_DATA_TYPE_VOID:
			fprintf(f, "void");
			break;
		case HCC_DATA_TYPE_BOOL:
			fprintf(f, *(U8*)data ? "true" : "false");
			break;
		case HCC_DATA_TYPE_CHAR:
		case HCC_DATA_TYPE_SCHAR:
		case HCC_DATA_TYPE_SSHORT:
		case HCC_DATA_TYPE_SINT:
		case HCC_DATA_TYPE_SLONG:
		case HCC_DATA_TYPE_SLONGLONG:
			switch (c->basic_type_size_and_aligns[data_type]) {
				case sizeof(int8_t): uint = *(int8_t*)data; break;
				case sizeof(int16_t): uint = *(int16_t*)data; break;
				case sizeof(int32_t): uint = *(int32_t*)data; break;
				case sizeof(int64_t): uint = *(int64_t*)data; break;
			}
			fprintf(f, "%zd", uint);
			break;
		case HCC_DATA_TYPE_UCHAR:
		case HCC_DATA_TYPE_USHORT:
		case HCC_DATA_TYPE_UINT:
		case HCC_DATA_TYPE_ULONG:
		case HCC_DATA_TYPE_ULONGLONG:
			switch (c->basic_type_size_and_aligns[data_type]) {
				case sizeof(uint8_t): uint = *(uint8_t*)data; break;
				case sizeof(uint16_t): uint = *(uint16_t*)data; break;
				case sizeof(uint32_t): uint = *(uint32_t*)data; break;
				case sizeof(uint64_t): uint = *(uint64_t*)data; break;
			}
			fprintf(f, "%zu", uint);
			break;
		case HCC_DATA_TYPE_FLOAT: float_ = *(float*)data; goto FLOAT;
		case HCC_DATA_TYPE_DOUBLE: float_ = *(double*)data; goto FLOAT;
FLOAT:
			fprintf(f, "%f", float_);
			break;
	}
}

HccDataType hcc_data_type_unsigned_to_signed(HccCompiler* c, HccDataType data_type) {
	if (HCC_DATA_TYPE_IS_BASIC(data_type)) {
		HCC_DEBUG_ASSERT(HCC_DATA_TYPE_IS_UINT(c, data_type), "data_type must be a unsigned integer");
		return data_type + 5;
	} else if (HCC_DATA_TYPE_IS_VECTOR(data_type)) {
		HccDataType comp_data_type = hcc_vector_data_type_scalar(c, data_type);
		HCC_DEBUG_ASSERT(HCC_DATA_TYPE_IS_UINT(c, data_type), "component data type must be a unsigned integer");
		return data_type + HCC_DATA_TYPE_INIT(0, 5);
	} else {
		HCC_ABORT("data_type must be a basic or vector type");
	}
}

HccDataType hcc_data_type_signed_to_unsigned(HccCompiler* c, HccDataType data_type) {
	if (HCC_DATA_TYPE_IS_BASIC(data_type)) {
		HCC_DEBUG_ASSERT(HCC_DATA_TYPE_IS_SINT(c, data_type), "data_type must be a signed integer");
		return data_type - 5;
	} else if (HCC_DATA_TYPE_IS_VECTOR(data_type)) {
		HccDataType comp_data_type = hcc_vector_data_type_scalar(c, data_type);
		HCC_DEBUG_ASSERT(HCC_DATA_TYPE_IS_SINT(c, data_type), "component data type must be a signed integer");
		return data_type - HCC_DATA_TYPE_INIT(0, 5);
	} else {
		HCC_ABORT("data_type must be a basic or vector type");
	}
}

bool hcc_data_type_is_condition(HccCompiler* c, HccDataType data_type) {
	HCC_UNUSED(c); // unused param for now, we will have to get pointers working later with this
	data_type = HCC_DATA_TYPE_STRIP_CONST(data_type);
	return HCC_DATA_TYPE_BOOL <= data_type && data_type < HCC_DATA_TYPE_BASIC_END;
}

U32 hcc_data_type_composite_fields_count(HccCompiler* c, HccDataType data_type) {
	HCC_DEBUG_ASSERT(!HCC_DATA_TYPE_IS_BASIC(data_type), "internal error: expected a composite type but got '%s'", hcc_data_type_string(c, data_type));

	switch (data_type & 0xff) {
		case HCC_DATA_TYPE_ARRAY: {
			HccArrayDataType* d = hcc_array_data_type_get(c, data_type);
			HccConstant constant = hcc_constant_table_get(c, d->size_constant_id);
			U64 count;
			hcc_constant_as_uint(c, constant, &count);
			return count;
		};
		case HCC_DATA_TYPE_STRUCT:
		case HCC_DATA_TYPE_UNION: {
			HccCompoundDataType* d = hcc_compound_data_type_get(c, data_type);
			return d->fields_count;
		};
		default:
			HCC_ABORT("unhandled data type '%u'", data_type);
	}
}

bool hcc_data_type_is_rasterizer_state(HccCompiler* c, HccDataType data_type) {
	data_type = hcc_typedef_resolve_and_strip_const_volatile(c, data_type);
	return HCC_DATA_TYPE_IS_STRUCT(data_type) && (hcc_compound_data_type_get(c, data_type)->kind == HCC_COMPOUND_DATA_TYPE_KIND_RASTERIZER_STATE);
}

bool hcc_data_type_is_fragment_state(HccCompiler* c, HccDataType data_type) {
	data_type = hcc_typedef_resolve_and_strip_const_volatile(c, data_type);
	return HCC_DATA_TYPE_IS_STRUCT(data_type) && (hcc_compound_data_type_get(c, data_type)->kind == HCC_COMPOUND_DATA_TYPE_KIND_FRAGMENT_STATE);
}

HccDataType hcc_data_type_from_intrinsic_type(HccCompiler* c, HccIntrinsicType intrinsic_type) {
	if (HCC_INTRINSIC_TYPE_VECTOR_START <= intrinsic_type && intrinsic_type < HCC_INTRINSIC_TYPE_VECTOR_END) {
		HccVec vec = intrinsic_type - HCC_INTRINSIC_TYPE_VECTOR_START;
		return HCC_DATA_TYPE_VECTOR(vec);
	} else if (HCC_INTRINSIC_TYPE_MATRIX_START <= intrinsic_type && intrinsic_type < HCC_INTRINSIC_TYPE_MATRIX_END) {
		HccMat mat = intrinsic_type - HCC_INTRINSIC_TYPE_MATRIX_START;
		return HCC_DATA_TYPE_MATRIX(mat);
	}

	U8 size;
	switch (intrinsic_type) {
		case HCC_INTRINSIC_TYPE_VOID: return HCC_DATA_TYPE_VOID;
		case HCC_INTRINSIC_TYPE_BOOL: return HCC_DATA_TYPE_BOOL;
		case HCC_INTRINSIC_TYPE_S8: size = sizeof(U8); goto FIND_SIGNED;
		case HCC_INTRINSIC_TYPE_S16: size = sizeof(U16); goto FIND_SIGNED;
		case HCC_INTRINSIC_TYPE_S32: size = sizeof(U32); goto FIND_SIGNED;
		case HCC_INTRINSIC_TYPE_S64: size = sizeof(U64); goto FIND_SIGNED;
FIND_SIGNED:
			for (HccDataType dt = HCC_DATA_TYPE_SCHAR; dt <= HCC_DATA_TYPE_SLONGLONG; dt += 1) {
				if (c->basic_type_size_and_aligns[dt] == size) {
					return dt;
				}
			}
			break;
		case HCC_INTRINSIC_TYPE_U8: size = sizeof(U8); goto FIND_UNSIGNED;
		case HCC_INTRINSIC_TYPE_U16: size = sizeof(U16); goto FIND_UNSIGNED;
		case HCC_INTRINSIC_TYPE_U32: size = sizeof(U32); goto FIND_UNSIGNED;
		case HCC_INTRINSIC_TYPE_U64: size = sizeof(U64); goto FIND_UNSIGNED;
FIND_UNSIGNED:
			for (HccDataType dt = HCC_DATA_TYPE_UCHAR; dt <= HCC_DATA_TYPE_ULONGLONG; dt += 1) {
				if (c->basic_type_size_and_aligns[dt] == size) {
					return dt;
				}
			}
			break;
		case HCC_INTRINSIC_TYPE_F16: return HCC_DATA_TYPE_STRUCT(HCC_STRUCT_IDX_HALF);
		case HCC_INTRINSIC_TYPE_F32: return HCC_DATA_TYPE_FLOAT;
		case HCC_INTRINSIC_TYPE_F64: return HCC_DATA_TYPE_DOUBLE;
	}

	HCC_ABORT("unhandled intrinsic type '%u'", intrinsic_type);
}

HccIntrinsicBasicTypeMask hcc_data_type_has_intrinsic_basic_types(HccCompiler* c, HccDataType data_type) {
	HccIntrinsicBasicTypeMask mask = 0;
	if (HCC_DATA_TYPE_IS_INTRINSIC_BASIC(data_type)) {
		HCC_INTRINSIC_BASIC_TYPE_MASK_SET(&mask, hcc_intrinsic_type_from_data_type(c, data_type));
		return mask;
	}

	switch (data_type & 0xff) {
		case HCC_DATA_TYPE_ENUM:
			HCC_INTRINSIC_BASIC_TYPE_MASK_SET(&mask, hcc_intrinsic_type_from_data_type(c, HCC_DATA_TYPE_SINT));
			return mask;

		case HCC_DATA_TYPE_STRUCT:
		case HCC_DATA_TYPE_UNION: {
			HccCompoundDataType* compound_data_type = hcc_compound_data_type_get(c, data_type);
			return compound_data_type->has_intrinsic_basic_types;
		};

		case HCC_DATA_TYPE_ARRAY: {
			HccArrayDataType* array_data_type = hcc_array_data_type_get(c, data_type);
			return hcc_data_type_has_intrinsic_basic_types(c, array_data_type->element_data_type);
		};

		case HCC_DATA_TYPE_TYPEDEF: {
			HccTypedef* typedef_ = hcc_typedef_get(c, data_type);
			return hcc_data_type_has_intrinsic_basic_types(c, typedef_->aliased_data_type);
		};

		default:
			return 0;
	}
}

bool hcc_data_type_is_same_underlaying_type(HccCompiler* c, HccDataType a, HccDataType b) {
	a = hcc_typedef_resolve_and_strip_const_volatile(c, a);
	b = hcc_typedef_resolve_and_strip_const_volatile(c, b);
	if (a == b) {
		return true;
	}

	if (HCC_DATA_TYPE_IS_INTRINSIC_BASIC(a) && HCC_DATA_TYPE_IS_INTRINSIC_BASIC(b)) {
		HccIntrinsicType ia = hcc_intrinsic_type_from_data_type(c, a);
		HccIntrinsicType ib = hcc_intrinsic_type_from_data_type(c, b);
		return ia == ib;
	}

	return false;
}

bool hcc_data_type_is_same_bitwidth_int(HccCompiler* c, HccDataType a, HccDataType b) {
	a = hcc_typedef_resolve_and_strip_const_volatile(c, a);
	b = hcc_typedef_resolve_and_strip_const_volatile(c, b);
	if (HCC_DATA_TYPE_IS_INTRINSIC_BASIC(a) && HCC_DATA_TYPE_IS_INTRINSIC_BASIC(b)) {
		HccIntrinsicType ia = hcc_intrinsic_type_from_data_type(c, a);
		HccIntrinsicType ib = hcc_intrinsic_type_from_data_type(c, b);
		return ia == ib || ia + 4 == ib || ia == ib + 4;
	}

	return false;
}

HccCompoundDataType* hcc_data_type_get_resource_table(HccCompiler* c, HccDataType data_type) {
	HccDataType resolved_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, data_type);
	if (!HCC_DATA_TYPE_IS_POINTER(resolved_data_type)) {
		return NULL;
	}
	resolved_data_type = hcc_data_type_strip_pointer(c, resolved_data_type);
	resolved_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, resolved_data_type);
	if (HCC_DATA_TYPE_IS_COMPOUND_TYPE(resolved_data_type)) {
		HccCompoundDataType* d = hcc_compound_data_type_get(c, resolved_data_type);
		switch (d->kind) {
			case HCC_COMPOUND_DATA_TYPE_KIND_RESOURCE_TABLE:
				return d;
		}
	}
	return NULL;
}

HccCompoundDataType* hcc_data_type_get_resource_set(HccCompiler* c, HccDataType data_type) {
	HccDataType resolved_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, data_type);
	if (!HCC_DATA_TYPE_IS_POINTER(resolved_data_type)) {
		return NULL;
	}
	resolved_data_type = hcc_data_type_strip_pointer(c, resolved_data_type);
	resolved_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, resolved_data_type);
	if (HCC_DATA_TYPE_IS_COMPOUND_TYPE(resolved_data_type)) {
		HccCompoundDataType* d = hcc_compound_data_type_get(c, resolved_data_type);
		switch (d->kind) {
			case HCC_COMPOUND_DATA_TYPE_KIND_RESOURCE_SET:
				return d;
		}
	}
	return NULL;
}

bool hcc_data_type_is_resource_table_pointer(HccCompiler* c, HccDataType data_type) {
	return hcc_data_type_get_resource_table(c, data_type) != NULL;
}

bool hcc_data_type_is_resource_set_pointer(HccCompiler* c, HccDataType data_type) {
	return hcc_data_type_get_resource_set(c, data_type) != NULL;
}

bool hcc_data_type_has_resources(HccCompiler* c, HccDataType data_type) {
	HccDataType resolved_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, data_type);
	if (HCC_DATA_TYPE_IS_RESOURCE(resolved_data_type)) {
		return true;
	}

	if (HCC_DATA_TYPE_IS_COMPOUND_TYPE(resolved_data_type)) {
		HccCompoundDataType* d = hcc_compound_data_type_get(c, resolved_data_type);
		return d->flags & HCC_COMPOUND_DATA_TYPE_FLAGS_HAS_RESOURCE;
	}

	if (HCC_DATA_TYPE_IS_ARRAY(resolved_data_type)) {
		HccArrayDataType* d = hcc_array_data_type_get(c, resolved_data_type);
		return d->has_resource;
	}

	if (hcc_data_type_is_resource_set_or_table_pointer(c, resolved_data_type)) {
		return true;
	}

	return false;
}

bool hcc_data_type_has_logically_address_elements(HccCompiler* c, HccDataType data_type) {
	HccDataType resolved_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, data_type);
	if (HCC_DATA_TYPE_IS_RESOURCE(resolved_data_type)) {
		return true;
	}

	if (HCC_DATA_TYPE_IS_POINTER(resolved_data_type)) {
		return true;
	}

	if (HCC_DATA_TYPE_IS_ARRAY(resolved_data_type)) {
		HccArrayDataType* d = hcc_stack_get(c->astgen.array_data_types, HCC_DATA_TYPE_IDX(data_type));
		return d->has_resource | d->has_pointer;
	}

	if (HCC_DATA_TYPE_IS_COMPOUND_TYPE(resolved_data_type)) {
		HccCompoundDataType* d = hcc_compound_data_type_get(c, resolved_data_type);
		switch (d->kind) {
			case HCC_COMPOUND_DATA_TYPE_KIND_RESOURCES:
				return true;
		}

		return d->flags & (HCC_COMPOUND_DATA_TYPE_FLAGS_HAS_RESOURCE | HCC_COMPOUND_DATA_TYPE_FLAGS_HAS_POINTER);
	}

	return false;
}

U32 hcc_data_type_logically_address_elements_count(HccCompiler* c, HccDataType data_type) {
	HccDataType resolved_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, data_type);
	if (HCC_DATA_TYPE_IS_RESOURCE(data_type)) {
		return 1;
	}

	switch (data_type & 0xff) {
		case HCC_DATA_TYPE_POINTER:
			return 1;

		case HCC_DATA_TYPE_STRUCT:
		case HCC_DATA_TYPE_UNION: {
			HccCompoundDataType* d = hcc_compound_data_type_get(c, data_type);
			return d->logically_addressable_elements_count;
		};

		case HCC_DATA_TYPE_ARRAY: {
			HccArrayDataType* d = hcc_array_data_type_get(c, data_type);
			return d->logically_addressable_elements_count;
		};
	}

	return 0;
}

bool hcc_data_type_is_resource_set_or_table_pointer(HccCompiler* c, HccDataType data_type) {
	HccDataType resolved_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, data_type);
	if (!HCC_DATA_TYPE_IS_POINTER(resolved_data_type)) {
		return false;
	}
	resolved_data_type = hcc_data_type_strip_pointer(c, resolved_data_type);
	resolved_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, resolved_data_type);
	if (HCC_DATA_TYPE_IS_COMPOUND_TYPE(resolved_data_type)) {
		HccCompoundDataType* d = hcc_compound_data_type_get(c, resolved_data_type);
		switch (d->kind) {
			case HCC_COMPOUND_DATA_TYPE_KIND_RESOURCE_TABLE:
			case HCC_COMPOUND_DATA_TYPE_KIND_RESOURCE_SET:
				return true;
		}
	}
	return false;
}

void hcc_data_type_ensure_compound_type_default_kind(HccCompiler* c, HccDataType data_type, HccErrorCode error_code) {
	HccDataType resolved_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, data_type);
	if (HCC_DATA_TYPE_IS_COMPOUND_TYPE(resolved_data_type)) {
		HccCompoundDataType* d = hcc_compound_data_type_get(c, resolved_data_type);
		if (d->kind != HCC_COMPOUND_DATA_TYPE_KIND_DEFAULT) {
			HccString data_type_name = hcc_data_type_string(c, data_type);
			hcc_astgen_bail_error_1(c, error_code, (int)data_type_name.size, data_type_name.data);
		}
	}
}

void hcc_data_type_ensure_valid_variable(HccCompiler* c, HccDataType data_type, HccErrorCode error_code) {
	HccDataType resolved_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, data_type);
	if (HCC_DATA_TYPE_IS_COMPOUND_TYPE(resolved_data_type)) {
		HccCompoundDataType* d = hcc_compound_data_type_get(c, resolved_data_type);
		if (d->kind != HCC_COMPOUND_DATA_TYPE_KIND_DEFAULT) {
			HccErrorCode error_code;
			switch (d->kind) {
				case HCC_COMPOUND_DATA_TYPE_KIND_RASTERIZER_STATE:
				case HCC_COMPOUND_DATA_TYPE_KIND_FRAGMENT_STATE:
				case HCC_COMPOUND_DATA_TYPE_KIND_BUFFER_ELEMENT:
				case HCC_COMPOUND_DATA_TYPE_KIND_RESOURCE_SET:
					goto ERROR;
				case HCC_COMPOUND_DATA_TYPE_KIND_RESOURCE_TABLE:
				case HCC_COMPOUND_DATA_TYPE_KIND_RESOURCES:
					break;
			}
		}
	}

	return;
ERROR: {}
	HccString data_type_name = hcc_data_type_string(c, data_type);
	hcc_astgen_bail_error_1(c, error_code, (int)data_type_name.size, data_type_name.data);
}

void hcc_data_type_ensure_compound_type_has_no_resources(HccCompiler* c, HccDataType data_type, HccErrorCode error_code) {
	HccDataType resolved_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, data_type);
	if (HCC_DATA_TYPE_IS_COMPOUND_TYPE(resolved_data_type)) {
		HccCompoundDataType* d = hcc_compound_data_type_get(c, resolved_data_type);
		if (d->flags & HCC_COMPOUND_DATA_TYPE_FLAGS_HAS_RESOURCE) {
			HccString data_type_name = hcc_data_type_string(c, data_type);
			hcc_astgen_bail_error_1(c, error_code, (int)data_type_name.size, data_type_name.data);
		}
	}
}

void hcc_data_type_ensure_has_no_pointers(HccCompiler* c, HccDataType data_type, HccErrorCode error_code) {
	HccDataType resolved_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, data_type);
	if (HCC_DATA_TYPE_IS_COMPOUND_TYPE(resolved_data_type)) {
		HccCompoundDataType* d = hcc_compound_data_type_get(c, resolved_data_type);
		if (d->flags & HCC_COMPOUND_DATA_TYPE_FLAGS_HAS_POINTER) {
			goto ERROR;
		}
	}

	if (HCC_DATA_TYPE_IS_POINTER(resolved_data_type)) {
		goto ERROR;
	}

	return;
ERROR: {}
	HccString data_type_name = hcc_data_type_string(c, data_type);
	hcc_astgen_bail_error_1(c, error_code, (int)data_type_name.size, data_type_name.data);
}

void hcc_data_type_ensure_has_no_resources(HccCompiler* c, HccDataType data_type, HccErrorCode error_code) {
	if (hcc_data_type_has_resources(c, data_type)) {
		HccString data_type_name = hcc_data_type_string(c, data_type);
		hcc_astgen_bail_error_1(c, error_code, (int)data_type_name.size, data_type_name.data);
	}
}

HccDataType hcc_data_type_strip_pointer(HccCompiler* c, HccDataType data_type) {
	while (HCC_DATA_TYPE_IS_POINTER(data_type)) {
		HccPointerDataType* d = hcc_pointer_data_type_get(c, data_type);
		data_type = d->element_data_type;
	}
	return data_type;
}

HccDataType hcc_data_type_strip_all_pointers(HccCompiler* c, HccDataType data_type) {
	while (HCC_DATA_TYPE_IS_POINTER(data_type)) {
		HccPointerDataType* d = hcc_pointer_data_type_get(c, data_type);
		data_type = d->element_data_type;
	}
	return data_type;
}

U32 hcc_data_type_token_idx(HccCompiler* c, HccDataType data_type) {
	switch (data_type & 0xff) {
		case HCC_DATA_TYPE_TYPEDEF:
			return hcc_typedef_get(c, data_type)->identifier_token_idx;
		default:
			return -1;
	}
}

HccIntrinsicType hcc_intrinsic_type_from_data_type(HccCompiler* c, HccDataType data_type) {
	if (HCC_DATA_TYPE_IS_UINT(c, data_type)) {
		switch (c->basic_type_size_and_aligns[data_type]) {
			case sizeof(U8): return HCC_INTRINSIC_TYPE_U8;
			case sizeof(U16): return HCC_INTRINSIC_TYPE_U16;
			case sizeof(U32): return HCC_INTRINSIC_TYPE_U32;
			case sizeof(U64): return HCC_INTRINSIC_TYPE_U64;
		}
	} else if (HCC_DATA_TYPE_IS_SINT(c, data_type)) {
		switch (c->basic_type_size_and_aligns[data_type]) {
			case sizeof(U8): return HCC_INTRINSIC_TYPE_S8;
			case sizeof(U16): return HCC_INTRINSIC_TYPE_S16;
			case sizeof(U32): return HCC_INTRINSIC_TYPE_S32;
			case sizeof(U64): return HCC_INTRINSIC_TYPE_S64;
		}
	} else if (HCC_DATA_TYPE_IS_VECTOR(data_type)) {
		HccVec vec = HCC_DATA_TYPE_VECTOR_VEC(data_type);
		return HCC_INTRINSIC_TYPE_VECTOR_START + vec;
	} else if (HCC_DATA_TYPE_IS_MATRIX(data_type)) {
		HccMat mat = HCC_DATA_TYPE_MATRIX_MAT(data_type);
		return HCC_INTRINSIC_TYPE_MATRIX_START + mat;
	} else {
		switch (data_type) {
			case HCC_DATA_TYPE_VOID: return HCC_INTRINSIC_TYPE_VOID;
			case HCC_DATA_TYPE_BOOL: return HCC_INTRINSIC_TYPE_BOOL;
			case HCC_DATA_TYPE_HALF: return HCC_INTRINSIC_TYPE_F16;
			case HCC_DATA_TYPE_FLOAT: return HCC_INTRINSIC_TYPE_F32;
			case HCC_DATA_TYPE_DOUBLE: return HCC_INTRINSIC_TYPE_F64;
		}
	}

	HCC_ABORT("unhandled data type '%u'", data_type);
}

HccDataType hcc_vector_data_type_to_vector_bool(HccDataType data_type) {
	HccVec vec = HCC_DATA_TYPE_VECTOR_VEC(data_type);
	vec -= vec % 12;
	return HCC_DATA_TYPE_VECTOR(vec);
}

U32 hcc_vector_data_type_components_count(HccDataType data_type) {
	HccVec vec = HCC_DATA_TYPE_VECTOR_VEC(data_type);
	return vec / 12 + 2;
}

HccDataType hcc_vector_data_type_scalar(HccCompiler* c, HccDataType data_type) {
	HccVec vec = HCC_DATA_TYPE_VECTOR_VEC(data_type);
	HccIntrinsicType scalar_intrinsic_type = HCC_INTRINSIC_TYPE_FROM_VEC(vec);
	return hcc_data_type_from_intrinsic_type(c, scalar_intrinsic_type);
}

HccDataType hcc_matrix_data_type_scalar(HccCompiler* c, HccDataType data_type) {
	HccMat mat = HCC_DATA_TYPE_MATRIX_MAT(data_type);
	HccIntrinsicType scalar_intrinsic_type = HCC_INTRINSIC_TYPE_FROM_MAT(mat);
	return hcc_data_type_from_intrinsic_type(c, scalar_intrinsic_type);
}

HccDataType hcc_matrix_data_type_column_vector(HccDataType data_type) {
	HccMat mat = HCC_DATA_TYPE_MATRIX_MAT(data_type);
	U32 columns_count_minus_two = mat % 6;
	HccVec vec = (columns_count_minus_two * 12) + (mat % 2);
	return HCC_DATA_TYPE_VECTOR(vec);
}

HccString hcc_intrinsic_basic_type_mask_string(HccIntrinsicBasicTypeMask mask) {
	static char buf[512];
	U32 size = 0;
	while (mask) {
		HccIntrinsicType intrinsic_type = hcc_leastsetbitidx32(mask);
		const char* str;
		switch (intrinsic_type) {
			case HCC_INTRINSIC_TYPE_VOID: str = "void"; break;
			case HCC_INTRINSIC_TYPE_BOOL: str = "bool"; break;
			case HCC_INTRINSIC_TYPE_S8: str = "int8_t"; break;
			case HCC_INTRINSIC_TYPE_S16: str = "int16_t"; break;
			case HCC_INTRINSIC_TYPE_S32: str = "int32_t"; break;
			case HCC_INTRINSIC_TYPE_S64: str = "int64_t"; break;
			case HCC_INTRINSIC_TYPE_U8: str = "uint8_t"; break;
			case HCC_INTRINSIC_TYPE_U16: str = "uint16_t"; break;
			case HCC_INTRINSIC_TYPE_U32: str = "uint32_t"; break;
			case HCC_INTRINSIC_TYPE_U64: str = "uint64_t"; break;
			case HCC_INTRINSIC_TYPE_F16: str = "half"; break;
			case HCC_INTRINSIC_TYPE_F32: str = "float"; break;
			case HCC_INTRINSIC_TYPE_F64: str = "double"; break;
		}

		size += snprintf(buf + size, sizeof(buf) - size, size ? " %s" : "%s", str);
		mask &= ~(1 << intrinsic_type);
	}

	return hcc_string(buf, size);
}

HccBasicTypeClass hcc_basic_type_class(HccCompiler* c, HccDataType data_type) {
	switch (data_type) {
		case HCC_DATA_TYPE_BOOL: return HCC_BASIC_TYPE_CLASS_BOOL;
		case HCC_DATA_TYPE_CHAR:
		case HCC_DATA_TYPE_SCHAR:
		case HCC_DATA_TYPE_SSHORT:
		case HCC_DATA_TYPE_SINT:
		case HCC_DATA_TYPE_SLONG:
		case HCC_DATA_TYPE_SLONGLONG: return HCC_BASIC_TYPE_CLASS_SINT;
		case HCC_DATA_TYPE_UCHAR:
		case HCC_DATA_TYPE_USHORT:
		case HCC_DATA_TYPE_UINT:
		case HCC_DATA_TYPE_ULONG:
		case HCC_DATA_TYPE_ULONGLONG: return HCC_BASIC_TYPE_CLASS_UINT;
		case HCC_DATA_TYPE_FLOAT:
		case HCC_DATA_TYPE_DOUBLE: return HCC_BASIC_TYPE_CLASS_FLOAT;
		default: {
			HccString data_type_name = hcc_data_type_string(c, data_type);
			HCC_UNREACHABLE("internal error: expected a basic type but got '%.*s'", (int)data_type_name.size, data_type_name.data);
		};
	}
}

HccBasic hcc_basic_from_sint(HccCompiler* c, HccDataType data_type, S64 value) {
	HCC_DEBUG_ASSERT(HCC_DATA_TYPE_IS_BASIC(data_type), "data type must be a basic type");

	HccBasic basic;
	switch (data_type) {
	case HCC_DATA_TYPE_CHAR:
	case HCC_DATA_TYPE_SCHAR:
	case HCC_DATA_TYPE_SSHORT:
	case HCC_DATA_TYPE_SINT:
	case HCC_DATA_TYPE_SLONG:
	case HCC_DATA_TYPE_SLONGLONG:
		switch (c->basic_type_size_and_aligns[data_type]) {
		case sizeof(int8_t): basic.s8 = value; break;
		case sizeof(int16_t): basic.s16 = value; break;
		case sizeof(int32_t): basic.s32 = value; break;
		case sizeof(int64_t): basic.s64 = value; break;
		}
		break;
	case HCC_DATA_TYPE_BOOL:
	case HCC_DATA_TYPE_UCHAR:
	case HCC_DATA_TYPE_USHORT:
	case HCC_DATA_TYPE_UINT:
	case HCC_DATA_TYPE_ULONG:
	case HCC_DATA_TYPE_ULONGLONG:
		switch (c->basic_type_size_and_aligns[data_type]) {
		case sizeof(uint8_t): basic.u8 = value; break;
		case sizeof(uint16_t): basic.u16 = value; break;
		case sizeof(uint32_t): basic.u32 = value; break;
		case sizeof(uint64_t): basic.u64 = value; break;
		}
		break;
	case HCC_DATA_TYPE_FLOAT: basic.f = value; break;
	case HCC_DATA_TYPE_DOUBLE: basic.d = value; break;
	}

	return basic;
}

HccBasic hcc_basic_from_uint(HccCompiler* c, HccDataType data_type, U64 value) {
	HCC_DEBUG_ASSERT(HCC_DATA_TYPE_IS_BASIC(data_type), "data type must be a basic type");

	HccBasic basic;
	switch (data_type) {
	case HCC_DATA_TYPE_BOOL:
	case HCC_DATA_TYPE_CHAR:
	case HCC_DATA_TYPE_SCHAR:
	case HCC_DATA_TYPE_SSHORT:
	case HCC_DATA_TYPE_SINT:
	case HCC_DATA_TYPE_SLONG:
	case HCC_DATA_TYPE_SLONGLONG:
	case HCC_DATA_TYPE_UCHAR:
	case HCC_DATA_TYPE_USHORT:
	case HCC_DATA_TYPE_UINT:
	case HCC_DATA_TYPE_ULONG:
	case HCC_DATA_TYPE_ULONGLONG:
		switch (c->basic_type_size_and_aligns[data_type]) {
		case sizeof(uint8_t): basic.u8 = value; break;
		case sizeof(uint16_t): basic.u16 = value; break;
		case sizeof(uint32_t): basic.u32 = value; break;
		case sizeof(uint64_t): basic.u64 = value; break;
		}
		break;
	case HCC_DATA_TYPE_FLOAT: basic.f = value; break;
	case HCC_DATA_TYPE_DOUBLE: basic.d = value; break;
	}

	return basic;
}

HccBasic hcc_basic_from_float(HccCompiler* c, HccDataType data_type, double value) {
	HCC_DEBUG_ASSERT(HCC_DATA_TYPE_IS_BASIC(data_type), "data type must be a basic type");

	HccBasic basic;
	switch (data_type) {
	case HCC_DATA_TYPE_CHAR:
	case HCC_DATA_TYPE_SCHAR:
	case HCC_DATA_TYPE_SSHORT:
	case HCC_DATA_TYPE_SINT:
	case HCC_DATA_TYPE_SLONG:
	case HCC_DATA_TYPE_SLONGLONG:
		switch (c->basic_type_size_and_aligns[data_type]) {
		case sizeof(int8_t): basic.s8 = (S8)value; break;
		case sizeof(int16_t): basic.s16 = (S16)value; break;
		case sizeof(int32_t): basic.s32 = (S32)value; break;
		case sizeof(int64_t): basic.s64 = (S64)value; break;
		}
		break;
	case HCC_DATA_TYPE_BOOL:
	case HCC_DATA_TYPE_UCHAR:
	case HCC_DATA_TYPE_USHORT:
	case HCC_DATA_TYPE_UINT:
	case HCC_DATA_TYPE_ULONG:
	case HCC_DATA_TYPE_ULONGLONG:
		switch (c->basic_type_size_and_aligns[data_type]) {
		case sizeof(uint8_t): basic.u8 = (U8)value; break;
		case sizeof(uint16_t): basic.u16 = (U16)value; break;
		case sizeof(uint32_t): basic.u32 = (U32)value; break;
		case sizeof(uint64_t): basic.u64 = (U64)value; break;
		}
		break;
	case HCC_DATA_TYPE_FLOAT: basic.f = value; break;
	case HCC_DATA_TYPE_DOUBLE: basic.d = value; break;
	}

	return basic;
}

HccArrayDataType* hcc_array_data_type_get(HccCompiler* c, HccDataType data_type) {
	data_type = hcc_typedef_resolve_and_strip_const_volatile(c, data_type);
	HCC_DEBUG_ASSERT(HCC_DATA_TYPE_IS_ARRAY(data_type), "internal error: expected array data type");
	return hcc_stack_get(c->astgen.array_data_types, HCC_DATA_TYPE_IDX(data_type));
}

HccEnumDataType* hcc_enum_data_type_get(HccCompiler* c, HccDataType data_type) {
	HCC_DEBUG_ASSERT(HCC_DATA_TYPE_IS_ENUM_TYPE(data_type), "internal error: expected enum data type");
	return hcc_stack_get(c->astgen.enum_data_types, HCC_DATA_TYPE_IDX(data_type));
}

HccCompoundDataType* hcc_compound_data_type_get(HccCompiler* c, HccDataType data_type) {
	data_type = hcc_typedef_resolve_and_strip_const_volatile(c, data_type);
	HCC_DEBUG_ASSERT(HCC_DATA_TYPE_IS_COMPOUND_TYPE(data_type), "internal error: expected compound data type");
	return hcc_stack_get(c->astgen.compound_data_types, HCC_DATA_TYPE_IDX(data_type));
}

HccSimpleBufferDataType* hcc_simple_buffer_data_type_get(HccCompiler* c, HccDataType data_type) {
	data_type = hcc_typedef_resolve_and_strip_const_volatile(c, data_type);
	HCC_DEBUG_ASSERT(HCC_DATA_TYPE_IS_SIMPLE_BUFFER(data_type), "internal error: expected simple buffer data type");
	return hcc_stack_get(c->astgen.simple_buffer_data_types, HCC_DATA_TYPE_IDX(data_type));
}

HccPointerDataType* hcc_pointer_data_type_get(HccCompiler* c, HccDataType data_type) {
	data_type = hcc_typedef_resolve_and_strip_const_volatile(c, data_type);
	HCC_DEBUG_ASSERT(HCC_DATA_TYPE_IS_POINTER(data_type), "internal error: expected pointer data type");
	return hcc_stack_get(c->astgen.pointer_data_types, HCC_DATA_TYPE_IDX(data_type));
}

HccTypedef* hcc_typedef_get(HccCompiler* c, HccDataType data_type) {
	HCC_DEBUG_ASSERT(HCC_DATA_TYPE_IS_TYPEDEF(data_type), "internal error: expected typedef");
	return hcc_stack_get(c->astgen.typedefs, HCC_DATA_TYPE_IDX(data_type));
}

HccDataType hcc_typedef_resolve_and_keep_const_volatile(HccCompiler* c, HccDataType data_type) {
	U32 mask = data_type & HCC_DATA_TYPE_CONST_AND_VOLATILE_MASK;
	data_type = hcc_typedef_resolve_and_strip_const_volatile(c, data_type);
	return data_type | mask;
}

HccDataType hcc_typedef_resolve_and_strip_const_volatile(HccCompiler* c, HccDataType data_type) {
	data_type = HCC_DATA_TYPE_STRIP_CONST_AND_VOLATILE(data_type);
	while (1) {
		switch (data_type & 0xff) {
			case HCC_DATA_TYPE_ENUM:
				return HCC_DATA_TYPE_SINT;
			case HCC_DATA_TYPE_TYPEDEF: {
				HccTypedef* typedef_ = hcc_typedef_get(c, data_type);
				data_type = typedef_->aliased_data_type;
				break;
			};
			default:
				return data_type;
		}
	}
}

U32 hcc_decl_token_idx(HccCompiler* c, HccDecl decl) {
	switch (decl & 0xff) {
		case HCC_DECL_FUNCTION:
			return hcc_function_get(c, decl)->identifier_token_idx;
		case HCC_DECL_ENUM_VALUE:
			return hcc_enum_value_get(c, decl)->identifier_token_idx;
		default:
			if (HCC_DECL_IS_DATA_TYPE(decl)) {
				return hcc_data_type_token_idx(c, (HccDataType)decl);
			}
			return -1;
	}
}

HccFunction* hcc_function_get(HccCompiler* c, HccDecl decl) {
	HCC_DEBUG_ASSERT(HCC_DECL_IS_FUNCTION(decl), "internal error: expected a function declaration");
	return hcc_stack_get(c->astgen.functions, HCC_DECL_IDX(decl));
}

HccEnumValue* hcc_enum_value_get(HccCompiler* c, HccDecl decl) {
	HCC_DEBUG_ASSERT(HCC_DECL_IS_ENUM_VALUE(decl), "internal error: expected a enum value");
	return hcc_stack_get(c->astgen.enum_values, HCC_DECL_IDX(decl));
}

HccVariable* hcc_global_variable_get(HccCompiler* c, HccDecl decl) {
	HCC_DEBUG_ASSERT(HCC_DECL_IS_GLOBAL_VARIABLE(decl), "internal error: expected a global variable");
	return hcc_stack_get(c->astgen.global_variables, HCC_DECL_IDX(decl));
}

U32 hcc_variable_to_string(HccCompiler* c, HccVariable* variable, char* buf, U32 buf_size, bool color) {
	char* fmt;
	if (color) {
		fmt = "\x1b[1;95m%s\x1b[1;94m%.*s \x1b[97m%.*s\x1b[0m";
	} else {
		fmt = "%s%.*s %.*s";
	}

	char* specifiers;
	if (variable->is_static) {
		specifiers = "static ";
	} else {
		// no need to handle const since hcc_data_type_string does this at a type level
		specifiers = "";
	}
	HccString type_name = hcc_data_type_string(c, variable->data_type);
	HccString variable_name = hcc_string_table_get(&c->string_table, variable->identifier_string_id);
	return snprintf(buf, buf_size, fmt, specifiers, (int)type_name.size, type_name.data, (int)variable_name.size, variable_name.data);
}

U32 hcc_function_to_string(HccCompiler* c, HccFunction* function, char* buf, U32 buf_size, bool color) {
	char* function_fmt;
	if (color) {
		function_fmt = "\x1b[1;94m%.*s \x1b[97m%.*s\x1b[0m";
	} else {
		function_fmt = "%.*s %.*s";
	}

	HccString return_type_name = hcc_data_type_string(c, function->return_data_type);
	HccString name = hcc_string_table_get(&c->string_table, function->identifier_string_id);
	U32 cursor = 0;
	cursor += snprintf(buf + cursor, buf_size - cursor, function_fmt, (int)return_type_name.size, return_type_name.data, (int)name.size, name.data);
	cursor += snprintf(buf + cursor, buf_size - cursor, "(");
	for (U32 param_idx = 0; param_idx < function->params_count; param_idx += 1) {
		HccVariable* param = hcc_stack_get(c->astgen.function_params_and_variables, function->params_start_idx + param_idx);
		cursor += hcc_variable_to_string(c, param, buf + cursor, buf_size - cursor, color);
		if (param_idx + 1 < function->params_count) {
			cursor += snprintf(buf + cursor, buf_size - cursor, ", ");
		}
	}
	cursor += snprintf(buf + cursor, buf_size - cursor, ")");
	return cursor;
}

// ===========================================
//
//
// Token Generator
//
//
// ===========================================

void hcc_tokengen_init(HccCompiler* c, HccCompilerSetup* setup) {
	c->tokengen.token_bag.tokens = hcc_stack_init(HccToken, setup->tokengen.tokens_cap, HCC_ALLOC_TAG_TOKENGEN_TOKENS);
	c->tokengen.token_bag.token_location_indices = hcc_stack_init(U32, setup->tokengen.tokens_cap, HCC_ALLOC_TAG_TOKENGEN_TOKEN_LOCATION_INDICES);
	c->tokengen.token_bag.token_values = hcc_stack_init(HccTokenValue, setup->tokengen.token_values_cap, HCC_ALLOC_TAG_TOKENGEN_TOKEN_VALUES);
	c->tokengen.token_locations = hcc_stack_init(HccLocation, setup->tokengen.token_locations_cap, HCC_ALLOC_TAG_TOKENGEN_TOKEN_LOCATION_INDICES);
	c->tokengen.paused_file_stack = hcc_stack_init(HccPausedFile, setup->tokengen.paused_file_stack_cap, HCC_ALLOC_TAG_TOKENGEN_PAUSED_FILE_STACK);
	c->tokengen.open_bracket_stack = hcc_stack_init(HccOpenBracket, setup->tokengen.open_bracket_stack_cap, HCC_ALLOC_TAG_TOKENGEN_OPEN_BRACKET_STACK);
}

void hcc_tokengen_advance_column(HccCompiler* c, U32 by) {
	c->tokengen.location.column_end += by;
	c->tokengen.location.code_end_idx += by;
}

void hcc_tokengen_advance_newline(HccCompiler* c) {
	c->tokengen.location.line_end += 1;
	c->tokengen.location.column_start = 1;
	c->tokengen.location.column_end = 1;
	c->tokengen.location.code_end_idx += 1;

	U32* dst = hcc_stack_push(c->tokengen.location.code_file->line_code_start_indices);
	*dst = c->tokengen.location.code_end_idx;
}

U32 hcc_tokengen_display_line(HccCompiler* c) {
	U32 line_num = c->tokengen.location.line_start;
	return c->tokengen.custom_line_dst ? c->tokengen.custom_line_dst + (line_num - c->tokengen.custom_line_src) : line_num;
}

U32 hcc_tokengen_token_add(HccCompiler* c, HccToken token) {
	U32 token_idx = hcc_stack_count(c->tokengen.dst_token_bag->tokens);
	*hcc_stack_push(c->tokengen.dst_token_bag->tokens) = token;

	*hcc_stack_push(c->tokengen.dst_token_bag->token_location_indices) = hcc_stack_count(c->tokengen.token_locations);
	HccLocation* dst_location = hcc_stack_push(c->tokengen.token_locations);
	*dst_location = c->tokengen.location;
	dst_location->display_line = hcc_tokengen_display_line(c);

	return token_idx;
}

U32 hcc_tokengen_token_value_add(HccCompiler* c, HccTokenValue value) {
	U32 token_value_idx = hcc_stack_count(c->tokengen.dst_token_bag->token_values);
	*hcc_stack_push(c->tokengen.dst_token_bag->token_values) = value;

	return token_value_idx;
}

void hcc_tokengen_count_extra_newlines(HccCompiler* c) {
	HccLocation* location = &c->tokengen.location;
	HccString code = location->code_file->code;
	U32 idx = hcc_stack_count(c->tokengen.paused_file_stack);
	while (1) {
		U32 lines_count = 3;
		while (location->code_end_idx < code.size) {
			char byte = code.data[location->code_end_idx];
			location->code_end_idx += 1;
			if (byte == '\n') {
				U32* dst = hcc_stack_push(location->code_file->line_code_start_indices);
				*dst = location->code_end_idx;

				lines_count -= 1;
				if (lines_count == 0) {
					break;
				}
			}
		}

		if (idx == 0) {
			break;
		}

		idx -= 1;
		location = &hcc_stack_get(c->tokengen.paused_file_stack, idx)->location;
		code = location->code_file->code;
	}
}

noreturn void hcc_tokengen_bail_error_1(HccCompiler* c, HccErrorCode error_code, ...) {
	hcc_tokengen_count_extra_newlines(c);

	va_list va_args;
	va_start(va_args, error_code);
	c->tokengen.location.display_line = hcc_tokengen_display_line(c);
	hcc_error_pushv(c, error_code, &c->tokengen.location, NULL, va_args);
	va_end(va_args);

	//
	// TODO see if you can recover from an error at the tokengen stage.
	// I don't think it is worth it as i don't want to pump out any incorrect errors.
	hcc_compiler_bail(c);
}

noreturn void hcc_tokengen_bail_error_2_idx(HccCompiler* c, HccErrorCode error_code, U32 other_token_idx, ...) {
	hcc_tokengen_count_extra_newlines(c);

	HccLocation* other_token_location = other_token_idx == U32_MAX ? NULL : hcc_token_bag_location_get(c, &c->tokengen.token_bag, other_token_idx);

	va_list va_args;
	va_start(va_args, other_token_idx);
	c->tokengen.location.display_line = hcc_tokengen_display_line(c);
	hcc_error_pushv(c, error_code, &c->tokengen.location, other_token_location, va_args);
	va_end(va_args);

	//
	// TODO see if you can recover from an error at the tokengen stage.
	// I don't think it is worth it as i don't want to pump out any incorrect errors.
	hcc_compiler_bail(c);
}

noreturn void hcc_tokengen_bail_error_2_ptr(HccCompiler* c, HccErrorCode error_code, HccLocation* token_location, HccLocation* other_token_location, ...) {
	hcc_tokengen_count_extra_newlines(c);

	va_list va_args;
	va_start(va_args, other_token_location);
	c->tokengen.location.display_line = hcc_tokengen_display_line(c);
	hcc_error_pushv(c, error_code, token_location, other_token_location, va_args);
	va_end(va_args);

	//
	// TODO see if you can recover from an error at the tokengen stage.
	// I don't think it is worth it as i don't want to pump out any incorrect errors.
	hcc_compiler_bail(c);
}

void hcc_tokengen_location_push(HccCompiler* c) {
	HccPausedFile* paused_file = hcc_stack_push(c->tokengen.paused_file_stack);
	paused_file->location = c->tokengen.location;
	paused_file->if_span_stack_count = hcc_stack_count(c->pp.if_span_stack);
}

void hcc_tokengen_location_pop(HccCompiler* c) {
	c->tokengen.location.code_file->flags |= HCC_CODE_FILE_FLAGS_PARSED_ONCE_OR_MORE;
	HccPausedFile* paused_file = hcc_stack_get_last(c->tokengen.paused_file_stack);
	if (paused_file->if_span_stack_count != hcc_stack_count(c->pp.if_span_stack)) {
		HccPPIfSpan* if_span = *hcc_stack_get_last(c->pp.if_span_stack);
		c->tokengen.location = if_span->location;
		hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_PP_IF_UNTERMINATED, hcc_pp_directive_strings[if_span->directive]);
	}

	hcc_change_working_directory_to_same_as_this_file(paused_file->location.code_file->path_string.data);
	c->tokengen.location = paused_file->location;
	c->tokengen.code = paused_file->location.code_file->code.data;
	c->tokengen.code_size = paused_file->location.code_file->code.size;
	hcc_stack_pop(c->tokengen.paused_file_stack);
}

void hcc_tokengen_location_setup_new_file(HccCompiler* c, HccCodeFile* code_file, bool change_dir) {
	HccLocation* location = &c->tokengen.location;
	location->code_file = code_file;
	location->parent_location = NULL;
	location->macro = NULL;
	location->code_start_idx = 0;
	location->code_end_idx = 0;
	location->line_start = 1;
	location->line_end = 2;
	location->column_start = 1;
	location->column_end = 1;

	c->tokengen.code = code_file->code.data;
	c->tokengen.code_size = code_file->code.size;
	code_file->pp_if_span_id = 0;

	if (change_dir) {
		hcc_change_working_directory_to_same_as_this_file(code_file->path_string.data);
	}
}

bool hcc_tokengen_consume_backslash(HccCompiler* c) {
	hcc_tokengen_advance_column(c, 1);
	U8 byte = c->tokengen.code[c->tokengen.location.code_end_idx];
	bool found_newline = false;
	if (byte == '\r') {
		hcc_tokengen_advance_column(c, 1);
		found_newline = true;
	}
	if (byte == '\n'){
		hcc_tokengen_advance_column(c, 1);
		found_newline = true;
	}
	if (found_newline) {
		c->tokengen.location.line_end += 1;
		c->tokengen.location.column_start = 1;
		c->tokengen.location.column_end = 1;
		U32* dst = hcc_stack_push(c->tokengen.location.code_file->line_code_start_indices);
		*dst = c->tokengen.location.code_end_idx;
	}
	return found_newline;
}

void hcc_tokengen_consume_whitespace(HccCompiler* c) {
	while (c->tokengen.location.code_end_idx < c->tokengen.code_size) {
		U8 byte = c->tokengen.code[c->tokengen.location.code_end_idx];
		if (byte != ' ' && byte != '\t') {
			U8 next_byte = c->tokengen.code[c->tokengen.location.code_end_idx + 1];
			if (byte != '\\' || !hcc_tokengen_consume_backslash(c)) {
				break;
			}
		} else {
			hcc_tokengen_advance_column(c, 1);
		}
	}
}

void hcc_tokengen_consume_whitespace_and_newlines(HccCompiler* c) {
	while (c->tokengen.location.code_end_idx < c->tokengen.code_size) {
		U8 byte = c->tokengen.code[c->tokengen.location.code_end_idx];
		if (byte != ' ' && byte != '\t' && byte != '\r' && byte != '\n' && byte != '\\') {
			break;
		} else {
			if (byte == '\n') {
				hcc_tokengen_advance_newline(c);
			} else {
				hcc_tokengen_advance_column(c, 1);
			}
		}
	}
}


void hcc_tokengen_consume_until_any_byte(HccCompiler* c, char* terminator_bytes) {
	while (c->tokengen.location.code_end_idx < c->tokengen.code_size) {
		U8 byte = c->tokengen.code[c->tokengen.location.code_end_idx];
		if (byte == '\\') {
			hcc_tokengen_consume_backslash(c);
			continue;
		}

		if (strchr(terminator_bytes, byte)) {
			break;
		}

		if (byte == '\r' || byte == '\n') {
			hcc_tokengen_advance_newline(c);
		} else {
			hcc_tokengen_advance_column(c, 1);
		}
	}
}

HccString hcc_tokengen_parse_ident_from_string(HccCompiler* c, HccString string, HccErrorCode error_code) {
	U8 byte = string.data[0];
	if (
		(byte < 'a' || 'z' < byte) &&
		(byte < 'A' || 'Z' < byte) &&
		byte != '_'
	) {
		HCC_DEBUG_ASSERT(error_code != HCC_ERROR_CODE_NONE, "internal error: expected no error to happen when parsing this identifier");
		c->tokengen.location.column_end += 1;
		hcc_tokengen_bail_error_1(c, error_code, byte);
	}

	HccString ident_string = hcc_string(string.data, 0);
	while (ident_string.size < string.size) {
		U8 ident_byte = ident_string.data[ident_string.size];
		if (
			(ident_byte < 'a' || 'z' < ident_byte) &&
			(ident_byte < 'A' || 'Z' < ident_byte) &&
			(ident_byte < '0' || '9' < ident_byte) &&
			(ident_byte != '_')
		) {
			break;
		}
		ident_string.size += 1;
	}

	return ident_string;
}

HccString hcc_tokengen_parse_ident(HccCompiler* c, HccErrorCode error_code) {
	HccString code = hcc_string((char*)&c->tokengen.code[c->tokengen.location.code_end_idx], c->tokengen.code_size - c->tokengen.location.code_end_idx);
	return hcc_tokengen_parse_ident_from_string(c, code, error_code);
}

U32 hcc_tokengen_parse_num_literals(HccCompiler* c, char* num_string, U32 token_size, U32 remaining_size, HccToken* token_mut) {
	HccToken token = *token_mut;
	token_size -= 1; // move back onto the character
	while (token_size < remaining_size) {
		char ch = num_string[token_size];
		token_size += 1;
		switch (ch) {
			case 'u':
			case 'U':
				switch (token) {
					case HCC_TOKEN_LIT_SINT: token = HCC_TOKEN_LIT_UINT; break;
					case HCC_TOKEN_LIT_SLONG: token = HCC_TOKEN_LIT_ULONG; break;
					case HCC_TOKEN_LIT_SLONGLONG: token = HCC_TOKEN_LIT_ULONGLONG; break;
					case HCC_TOKEN_LIT_UINT:
					case HCC_TOKEN_LIT_ULONG:
					case HCC_TOKEN_LIT_ULONGLONG:
						hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_U_SUFFIX_ALREADY_USED);
						break;
					case HCC_TOKEN_LIT_FLOAT:
					case HCC_TOKEN_LIT_DOUBLE:
						hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_U_SUFFIX_ON_FLOAT);
						break;
				}
				break;
			case 'l':
			case 'L':
				switch (token) {
					case HCC_TOKEN_LIT_FLOAT:
						hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_L_SUFFIX_ON_FLOAT);
					case HCC_TOKEN_LIT_DOUBLE:
						hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_LONG_DOUBLE_IS_UNSUPPORTED);
					case HCC_TOKEN_LIT_SINT:
						token = HCC_TOKEN_LIT_SLONG;
						break;
					case HCC_TOKEN_LIT_SLONG:
						token = HCC_TOKEN_LIT_SLONGLONG;
						break;
					case HCC_TOKEN_LIT_UINT:
						token = HCC_TOKEN_LIT_ULONG;
						break;
					case HCC_TOKEN_LIT_ULONG:
						token = HCC_TOKEN_LIT_ULONGLONG;
						break;
				}
				break;
			case 'f':
			case 'F':
				if (token != HCC_TOKEN_LIT_DOUBLE) {
					hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_FLOAT_SUFFIX_MUST_FOLLOW_DECIMAL_PLACE);
				}
				token = HCC_TOKEN_LIT_FLOAT;
				break;
			default:
				token_size -= 1;
				goto END;
		}
	}

END:
	*token_mut = token;
	return token_size;
}

U32 hcc_tokengen_parse_num(HccCompiler* c, HccToken* token_out) {
	char* num_string = (char*)&c->tokengen.code[c->tokengen.location.code_end_idx];
	U32 remaining_size = c->tokengen.code_size - c->tokengen.location.code_end_idx;
	U32 token_size = 0;

	bool is_negative = num_string[0] == '-';
	if (is_negative) {
		token_size += 1; // skip the '-'
	}

	//
	// parse the radix prefix if there is a 0x or 0
	HccToken token = HCC_TOKEN_LIT_SINT;
	uint8_t radix = 10;
	if (num_string[0] == '0') {
		switch (num_string[1]) {
			case 'x':
			case 'X':
				radix = 16;
				token_size += 2;
				break;
			case '0': case '1': case '2': case '3': case '4':
			case '5': case '6': case '7': case '8': case '9':
				radix = 8;
				token_size += 2;
				break;
		}
	}

	U64 u64 = 0;
	S64 s64 = 0;
	F64 f64 = 0.0;
	F64 pow_10 = 10.0;
	while (token_size < remaining_size) {
		U8 digit = num_string[token_size];
		token_size += 1;

		switch (digit) {
			case '0': case '1': case '2': case '3': case '4':
			case '5': case '6': case '7': case '8': case '9':
			{
				if (radix == 8 && digit > 7) {
					hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_INVALID_OCTAL_DIGIT);
				}
				U32 int_digit = digit - '0';
				switch (token) {
					case HCC_TOKEN_LIT_SINT:
					case HCC_TOKEN_LIT_SLONG:
					case HCC_TOKEN_LIT_SLONGLONG:
					case HCC_TOKEN_LIT_UINT:
					case HCC_TOKEN_LIT_ULONG:
					case HCC_TOKEN_LIT_ULONGLONG:
						if (
							!hcc_i64_checked_mul(u64, radix, &u64)        ||
							!hcc_u64_checked_add(u64, int_digit, &u64)
						) {
							hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_MAX_UINT_OVERFLOW);
						}
						break;
					case HCC_TOKEN_LIT_FLOAT:
					case HCC_TOKEN_LIT_DOUBLE:
						f64 += (F64)(int_digit) / pow_10;
						if (isinf(f64)) {
							hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_MAX_FLOAT_OVERFLOW);
						}
						pow_10 *= 10.0;
						break;
				}
				break;
			};
			case 'u':
			case 'U':
			case 'l':
			case 'L':
				token_size = hcc_tokengen_parse_num_literals(c, num_string, token_size, remaining_size, &token);
				break;

			case '.':
				if (token == HCC_TOKEN_LIT_DOUBLE) {
					hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_FLOAT_HAS_DOUBLE_FULL_STOP);
				}
				if (radix != 10) {
					hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_FLOAT_MUST_BE_DECIMAL);
				}

				token = HCC_TOKEN_LIT_DOUBLE;
				f64 = (F64)u64;
				if ((U64)f64 != u64) {
					hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_MAX_FLOAT_OVERFLOW);
				}
				break;

			default: {
				if (radix == 16 && ((digit >= 'a' && digit <= 'f') || (digit >= 'A' && digit <= 'F'))) {
					U32 int_digit = 10 + (digit >= 'A' ? (digit - 'A') : (digit - 'a'));
					HCC_DEBUG_ASSERT(token != HCC_TOKEN_LIT_FLOAT && token != HCC_TOKEN_LIT_DOUBLE, "internal error: expected to be dealing with integer literals here");
					if (
						!hcc_i64_checked_mul(u64, radix, &u64)        ||
						!hcc_u64_checked_add(u64, int_digit, &u64)
					) {
						hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_MAX_UINT_OVERFLOW);
					}
					break;
				} else if (digit == 'f' || digit == 'F') {
					token_size = hcc_tokengen_parse_num_literals(c, num_string, token_size, remaining_size, &token);
				} else if ((digit >= 'a' && digit <= 'z') || (digit >= 'A' && digit <= 'Z')) {
					switch (token) {
						case HCC_TOKEN_LIT_SINT:
						case HCC_TOKEN_LIT_SLONG:
						case HCC_TOKEN_LIT_SLONGLONG:
						case HCC_TOKEN_LIT_UINT:
						case HCC_TOKEN_LIT_ULONG:
						case HCC_TOKEN_LIT_ULONGLONG:
							hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_INVALID_INTEGER_LITERALS);
						case HCC_TOKEN_LIT_FLOAT:
						case HCC_TOKEN_LIT_DOUBLE:
							hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_INVALID_FLOAT_LITERALS);
					}
				} else {
					token_size -= 1;
					goto NUM_END;
				}
				break;
			};
		}
	}
NUM_END:

	//
	// apply the negate if it is negative and a signed type
	if (is_negative) {
		switch (token) {
			case HCC_TOKEN_LIT_SINT:
			case HCC_TOKEN_LIT_SLONG:
			case HCC_TOKEN_LIT_SLONGLONG:
			{
				if (u64 > (U64)S64_MAX + 1) {
					hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_MAX_SINT_OVERFLOW);
				}
				s64 = -u64;
				break;
			};
			case HCC_TOKEN_LIT_FLOAT:
			case HCC_TOKEN_LIT_DOUBLE:
				f64 = -f64;
				break;
		}
	}

	//
	// perform literal type upgrades if they exceed their current type
	switch (token) {
		case HCC_TOKEN_LIT_UINT:
			if (u64 <= c->basic_type_int_maxes[HCC_DATA_TYPE_UINT]) {
				break;
			}
			token = HCC_TOKEN_LIT_ULONG;
			// fallthrough
		case HCC_TOKEN_LIT_ULONG:
			if (u64 <= c->basic_type_int_maxes[HCC_DATA_TYPE_ULONG]) {
				break;
			}
			token = HCC_TOKEN_LIT_ULONGLONG;
			break;
		case HCC_TOKEN_LIT_SINT:
			if (is_negative) {
				if (s64 > (S64)c->basic_type_int_maxes[HCC_DATA_TYPE_SLONG] || s64 < (S64)c->basic_type_int_mins[HCC_DATA_TYPE_SLONG]) {
					token = HCC_TOKEN_LIT_SLONGLONG;
				} else if (s64 > (S64)c->basic_type_int_maxes[HCC_DATA_TYPE_SINT] || s64 < (S64)c->basic_type_int_mins[HCC_DATA_TYPE_SINT]) {
					token = HCC_TOKEN_LIT_SLONG;
				}
			} else {
				if (u64 > c->basic_type_int_maxes[HCC_DATA_TYPE_SINT]) {
					if (radix != 10 && u64 <= c->basic_type_int_maxes[HCC_DATA_TYPE_UINT]) {
						token = HCC_TOKEN_LIT_UINT;
					} else if (u64 <= c->basic_type_int_maxes[HCC_DATA_TYPE_ULONG]) {
						token = HCC_TOKEN_LIT_SLONG;
					} else if (radix != 10 && u64 <= c->basic_type_int_maxes[HCC_DATA_TYPE_ULONG]) {
						token = HCC_TOKEN_LIT_ULONG;
					} else if (u64 <= c->basic_type_int_maxes[HCC_DATA_TYPE_SLONGLONG]) {
						token = HCC_TOKEN_LIT_SLONGLONG;
					} else if (radix != 10 && u64 <= c->basic_type_int_maxes[HCC_DATA_TYPE_ULONGLONG]) {
						token = HCC_TOKEN_LIT_ULONGLONG;
					} else {
						hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_MAX_SINT_OVERFLOW_DECIMAL);
					}
				}
				s64 = u64;
			}
			break;
		case HCC_TOKEN_LIT_SLONG:
			if (is_negative) {
				if (s64 > (S64)c->basic_type_int_maxes[HCC_DATA_TYPE_ULONG] || s64 < (S64)c->basic_type_int_mins[HCC_DATA_TYPE_ULONG]) {
					token = HCC_TOKEN_LIT_SLONGLONG;
				}
			} else {
				if (u64 > c->basic_type_int_maxes[HCC_DATA_TYPE_ULONG]) {
					if (radix != 10 && u64 <= c->basic_type_int_maxes[HCC_DATA_TYPE_ULONG]) {
						token = HCC_TOKEN_LIT_ULONG;
					} else if (u64 <= c->basic_type_int_maxes[HCC_DATA_TYPE_SLONGLONG]) {
						token = HCC_TOKEN_LIT_SLONGLONG;
					} else if (radix != 10 && u64 <= c->basic_type_int_maxes[HCC_DATA_TYPE_ULONGLONG]) {
						token = HCC_TOKEN_LIT_ULONGLONG;
					} else {
						hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_MAX_SINT_OVERFLOW_DECIMAL);
					}
				}
				s64 = u64;
			}
			break;
	}

	//
	// apply the negate for if it is an unsigned literal
	if (is_negative) {
		switch (token) {
			case HCC_TOKEN_LIT_UINT:
			case HCC_TOKEN_LIT_ULONG:
			case HCC_TOKEN_LIT_ULONGLONG:
			{
				u64 = -u64;
				break;
			};
		}
	}

	if (token_out == NULL) {
		return token_size;
	}

	HccDataType data_type;
	switch (token) {
		case HCC_TOKEN_LIT_SINT: data_type = HCC_DATA_TYPE_SINT; break;
		case HCC_TOKEN_LIT_SLONG: data_type = HCC_DATA_TYPE_SLONG; break;
		case HCC_TOKEN_LIT_SLONGLONG: data_type = HCC_DATA_TYPE_SLONGLONG; break;
		case HCC_TOKEN_LIT_UINT: data_type = HCC_DATA_TYPE_UINT; break;
		case HCC_TOKEN_LIT_ULONG: data_type = HCC_DATA_TYPE_ULONG; break;
		case HCC_TOKEN_LIT_ULONGLONG: data_type = HCC_DATA_TYPE_ULONGLONG; break;
		case HCC_TOKEN_LIT_FLOAT: data_type = HCC_DATA_TYPE_FLOAT; break;
		case HCC_TOKEN_LIT_DOUBLE: data_type = HCC_DATA_TYPE_DOUBLE; break;
	}

	HccBasic basic;
	switch (token) {
		case HCC_TOKEN_LIT_SINT:
		case HCC_TOKEN_LIT_SLONG:
		case HCC_TOKEN_LIT_SLONGLONG: basic = hcc_basic_from_sint(c, data_type, s64); break;
		case HCC_TOKEN_LIT_UINT:
		case HCC_TOKEN_LIT_ULONG:
		case HCC_TOKEN_LIT_ULONGLONG: basic = hcc_basic_from_uint(c, data_type, u64); break;
		case HCC_TOKEN_LIT_FLOAT:
		case HCC_TOKEN_LIT_DOUBLE: basic = hcc_basic_from_float(c, data_type, f64); break;
	}

	HccTokenValue token_value;
	token_value.constant_id = hcc_constant_table_deduplicate_basic(c, data_type, &basic);
	hcc_tokengen_token_value_add(c, token_value);

	//
	// push on an addition string id of the literial so we can get the exact string representation.
	// this is needed for macro argument stringify and macro concatination.
	// TODO: we should probably just append these to the end of an array so it'll be faster but consume more RAM
	token_value.string_id = hcc_string_table_deduplicate(&c->string_table, num_string, token_size);
	hcc_tokengen_token_value_add(c, token_value);

	*token_out = token;
	return token_size;
}

void hcc_tokengen_parse_string(HccCompiler* c, char terminator_byte, bool ignore_escape_sequences_except_double_quotes) {
	c->tokengen.location.code_end_idx += 1;
	c->tokengen.location.column_end += 1;

	U32 stringify_buffer_start_idx = hcc_stack_count(c->string_buffer);
	if (c->tokengen.run_mode == HCC_TOKENGEN_RUN_MODE_PP_INCLUDE_OPERAND || ignore_escape_sequences_except_double_quotes) {
		bool ended_with_terminator = false;
		while (c->tokengen.location.code_end_idx < c->tokengen.code_size) {
			char byte = c->tokengen.code[c->tokengen.location.code_end_idx];
			c->tokengen.location.column_end += 1;
			c->tokengen.location.code_end_idx += 1;

			if (byte == '\\') {
				byte = c->tokengen.code[c->tokengen.location.code_end_idx];
				switch (byte) {
					case '\r':
						c->tokengen.location.column_end += 2;
						c->tokengen.location.code_end_idx += 2;
						break;
					case '\n':
						c->tokengen.location.column_end += 1;
						c->tokengen.location.code_end_idx += 1;
						break;
					case '\"':
						if (ignore_escape_sequences_except_double_quotes) {
							hcc_stack_push_char(c->string_buffer, '\\');
						}
						c->tokengen.location.column_end += 1;
						c->tokengen.location.code_end_idx += 1;
						hcc_stack_push_char(c->string_buffer, '"');
						break;
					default:
						if (ignore_escape_sequences_except_double_quotes) {
							hcc_stack_push_char(c->string_buffer, '\\');
						} else {
							hcc_stack_push_char(c->string_buffer, '/'); // convert \ to / for windows paths
						}
						break;
				}
			} else if (byte == '\r' || byte == '\n') {
				break;
			} else if (byte == terminator_byte) {
				ended_with_terminator = true;
				break;
			} else {
				hcc_stack_push_char(c->string_buffer, byte);
			}
		}

		if (!ended_with_terminator) {
			c->tokengen.location.column_end += 1;
			c->tokengen.location.code_end_idx -= 1;
			hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_UNCLOSED_STRING_LITERAL, terminator_byte);
		}

		if (ignore_escape_sequences_except_double_quotes) {
			return;
		}
	} else {
		bool ended_with_terminator = false;
		while (c->tokengen.location.code_end_idx < c->tokengen.code_size) {
			char byte = c->tokengen.code[c->tokengen.location.code_end_idx];
			c->tokengen.location.column_end += 1;
			c->tokengen.location.code_end_idx += 1;

			if (byte == '\\') {
				byte = c->tokengen.code[c->tokengen.location.code_end_idx];
				switch (byte) {
					case '\\':
					case '\r':
					case '\n':
					case '\"':
					case '\'':
						hcc_stack_push_char(c->string_buffer, byte);
						c->tokengen.location.column_end += 2;
						c->tokengen.location.code_end_idx += 2;
						break;
					default:
						break;
				}
			} else if (byte == '\r' || byte == '\n') {
				break;
			} else if (byte == terminator_byte) {
				ended_with_terminator = true;
				break;
			} else {
				hcc_stack_push_char(c->string_buffer, byte);
			}
		}

		if (!ended_with_terminator) {
			c->tokengen.location.column_end += 1;
			c->tokengen.location.code_end_idx -= 1;
			hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_UNCLOSED_STRING_LITERAL, terminator_byte);
		}
	}

	hcc_stack_push_char(c->string_buffer, '\0');

	HccTokenValue token_value;
	U32 string_size = hcc_stack_count(c->string_buffer) - stringify_buffer_start_idx;
	token_value.string_id = hcc_string_table_deduplicate(&c->string_table, hcc_stack_get(c->string_buffer, stringify_buffer_start_idx), string_size);
	hcc_stack_resize(c->string_buffer, stringify_buffer_start_idx);

	hcc_tokengen_token_add(c, terminator_byte == '>' ? HCC_TOKEN_INCLUDE_PATH_SYSTEM : HCC_TOKEN_STRING);
	hcc_tokengen_token_value_add(c, token_value);
}

U32 hcc_tokengen_find_macro_param(HccCompiler* c, HccStringId ident_string_id) {
	U32 param_idx;
	for (param_idx = 0; param_idx < c->tokengen.macro_params_count; param_idx += 1) {
		if (c->tokengen.macro_param_string_ids[param_idx].idx_plus_one == ident_string_id.idx_plus_one) {
			break;
		}
	}

	return param_idx;
}

void hcc_tokengen_consume_hash_for_define_replacement_list(HccCompiler* c) {
	if (c->tokengen.code[c->tokengen.location.code_end_idx + 1] == '#') {
		if (c->tokengen.macro_tokens_start_idx == hcc_stack_count(c->pp.macro_token_bag.tokens)) {
			hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_MACRO_STARTS_WITH_CONCAT);
		}

		HccToken temp_token = *hcc_stack_get_last(c->pp.macro_token_bag.tokens);
		U32 temp_token_location_idx = *hcc_stack_get_last(c->pp.macro_token_bag.token_location_indices);
		bool has_left_whitespace = false;
		if (temp_token == HCC_TOKEN_MACRO_WHITESPACE) {
			hcc_stack_pop(c->pp.macro_token_bag.tokens);
			hcc_stack_pop(c->pp.macro_token_bag.token_location_indices);
			temp_token = *hcc_stack_get_last(c->pp.macro_token_bag.tokens);
			temp_token_location_idx = *hcc_stack_get_last(c->pp.macro_token_bag.token_location_indices);
			has_left_whitespace = true;
		}

		hcc_stack_pop(c->pp.macro_token_bag.tokens);
		hcc_stack_pop(c->pp.macro_token_bag.token_location_indices);

		hcc_tokengen_advance_column(c, 2); // skip the '##'
		hcc_tokengen_token_add(c, has_left_whitespace ? HCC_TOKEN_MACRO_CONCAT_WHITESPACE : HCC_TOKEN_MACRO_CONCAT);

		*hcc_stack_push(c->pp.macro_token_bag.tokens) = temp_token;
		*hcc_stack_push(c->pp.macro_token_bag.token_location_indices) = temp_token_location_idx;
	} else {
		if (c->tokengen.macro_is_function) {
			hcc_tokengen_advance_column(c, 1); // skip the '#'

			U32 before_ident_start_idx = c->tokengen.location.code_end_idx;
			hcc_tokengen_consume_whitespace(c);
			bool whitespace_after_hash = before_ident_start_idx != c->tokengen.location.code_end_idx;
			HccString ident_string = hcc_tokengen_parse_ident(c, HCC_ERROR_CODE_STRINGIFY_MUST_BE_MACRO_PARAM);
			HccStringId ident_string_id = hcc_string_table_deduplicate(&c->string_table, (char*)ident_string.data, ident_string.size);

			U32 param_idx;
			if (ident_string_id.idx_plus_one == HCC_STRING_ID___VA_ARGS__) {
				if (!c->tokengen.macro_has_va_arg) {
					c->tokengen.location.column_end += ident_string.size;
					hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_INVALID_USE_OF_VA_ARGS);
				}
				param_idx = c->tokengen.macro_params_count - 1;
			} else {
				param_idx = hcc_tokengen_find_macro_param(c, ident_string_id);
				if (param_idx == c->tokengen.macro_params_count) {
					c->tokengen.location.column_end += ident_string.size;
					hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_STRINGIFY_MUST_BE_MACRO_PARAM);
				}
			}

			hcc_tokengen_advance_column(c, ident_string.size);
			hcc_tokengen_token_add(c, whitespace_after_hash ? HCC_TOKEN_MACRO_STRINGIFY_WHITESPACE : HCC_TOKEN_MACRO_STRINGIFY);
			hcc_tokengen_token_value_add(c, ((HccTokenValue) { .macro_param_idx = param_idx }));
		} else {
			hcc_tokengen_advance_column(c, 1); // skip the '#'
			hcc_tokengen_token_add(c, HCC_TOKEN_HASH);
		}
	}
}

bool hcc_tokengen_is_first_non_whitespace_on_line(HccCompiler* c) {
	for (U32 idx = c->tokengen.location.code_end_idx; idx-- > 0; ) {
		switch (c->tokengen.code[idx]) {
			case '\r':
			case '\n':
				return true;
			case ' ':
			case '\t':
				break;
			default:
				return false;
		}
	}

	return true;
}


void hcc_tokengen_bracket_open(HccCompiler* c, HccToken token, HccLocation* location) {
	HccOpenBracket* ob = hcc_stack_push(c->tokengen.open_bracket_stack);
	HccToken close_token = token + 1; // the close token is defined right away after the open in the HccToken enum
	ob->close_token = close_token;
	ob->open_token_location = location;
}

void hcc_tokengen_bracket_close(HccCompiler* c, HccToken token, HccLocation* location) {
	if (hcc_stack_count(c->tokengen.open_bracket_stack) == 0) {
		hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_NO_BRACKETS_OPEN, hcc_token_strings[token]);
	}

	HccOpenBracket* ob = hcc_stack_get_last(c->tokengen.open_bracket_stack);
	hcc_stack_pop(c->tokengen.open_bracket_stack);
	if (ob->close_token != token) {
		hcc_tokengen_advance_column(c, 1);
		hcc_tokengen_bail_error_2_ptr(c, HCC_ERROR_CODE_INVALID_CLOSE_BRACKET_PAIR, location, ob->open_token_location, hcc_token_strings[ob->close_token], hcc_token_strings[token]);
	}
}

void hcc_tokengen_run(HccCompiler* c, HccTokenBag* dst_token_bag, HccTokenGenRunMode run_mode) {
	HccTokenGenRunMode old_run_mode = c->tokengen.run_mode;
	HccTokenBag* old_dst_token_bag = c->tokengen.dst_token_bag;
	c->tokengen.run_mode = run_mode;
	c->tokengen.dst_token_bag = dst_token_bag;

	U32 macro_args_nested_parenthesis_count = 0;
	while (1) {
		//
		// if we have reached the end of this file, then return
		// to the parent file or end the token generation.
		if (c->tokengen.location.code_end_idx >= c->tokengen.code_size) {
			if (hcc_stack_count(c->tokengen.paused_file_stack) == 0) {
				goto RETURN;
			}

			hcc_tokengen_location_pop(c);
			if (run_mode == HCC_TOKENGEN_RUN_MODE_PP_CONCAT) {
				goto RETURN;
			}
			continue;
		}

		U8 byte = c->tokengen.code[c->tokengen.location.code_end_idx];

		c->tokengen.location.code_start_idx = c->tokengen.location.code_end_idx;
		c->tokengen.location.line_start += c->tokengen.location.line_end - c->tokengen.location.line_start - 1;
		c->tokengen.location.column_start = c->tokengen.location.column_end;

		HccToken token = HCC_TOKEN_COUNT;
		HccToken close_token;
		U32 token_size = 1;
		switch (byte) {
			case ' ':
			case '\t':
				hcc_tokengen_consume_whitespace(c);
				switch (run_mode) {
					case HCC_TOKENGEN_RUN_MODE_PP_DEFINE_REPLACEMENT_LIST:
					case HCC_TOKENGEN_RUN_MODE_PP_MACRO_ARGS:
					case HCC_TOKENGEN_RUN_MODE_PP_CONCAT:
						if (*hcc_stack_get_last(dst_token_bag->tokens) != HCC_TOKEN_MACRO_WHITESPACE) {
							hcc_tokengen_token_add(c, HCC_TOKEN_MACRO_WHITESPACE);
						}
						break;
				}
				continue;
			case '\r':
				c->tokengen.location.code_start_idx += 1;
				c->tokengen.location.code_end_idx += 1;
				continue;
			case '\n':
				switch (run_mode) {
					case HCC_TOKENGEN_RUN_MODE_PP_INCLUDE_OPERAND:
					case HCC_TOKENGEN_RUN_MODE_PP_IF_OPERAND:
					case HCC_TOKENGEN_RUN_MODE_PP_OPERAND:
					case HCC_TOKENGEN_RUN_MODE_PP_DEFINE_REPLACEMENT_LIST:
						goto RETURN;
					case HCC_TOKENGEN_RUN_MODE_PP_MACRO_ARGS:
					case HCC_TOKENGEN_RUN_MODE_PP_CONCAT:
						if (*hcc_stack_get_last(dst_token_bag->tokens) != HCC_TOKEN_MACRO_WHITESPACE) {
							hcc_tokengen_token_add(c, HCC_TOKEN_MACRO_WHITESPACE);
						}
						break;
				}

				hcc_tokengen_advance_newline(c);
				continue;
			case '.': token = HCC_TOKEN_FULL_STOP; break;
			case ',': token = HCC_TOKEN_COMMA; break;
			case ';': token = HCC_TOKEN_SEMICOLON; break;
			case ':': token = HCC_TOKEN_COLON; break;
			case '~': token = HCC_TOKEN_TILDE; break;
			case '?': token = HCC_TOKEN_QUESTION_MARK; break;
			case '+': {
				U8 next_byte = c->tokengen.code[c->tokengen.location.code_end_idx + 1];
				if (next_byte == '=') {
					token_size = 2;
					token = HCC_TOKEN_ADD_ASSIGN;
				} else if (next_byte == '+') {
					token_size = 2;
					token = HCC_TOKEN_INCREMENT;
				} else {
					token = HCC_TOKEN_PLUS;
				}
				break;
			};
			case '-': {
				U8 next_byte = c->tokengen.code[c->tokengen.location.code_end_idx + 1];
				if (isdigit(next_byte)) {
					token_size = hcc_tokengen_parse_num(c, &token);
				} else if (next_byte == '=') {
					token_size = 2;
					token = HCC_TOKEN_SUBTRACT_ASSIGN;
				} else if (next_byte == '-') {
					token_size = 2;
					token = HCC_TOKEN_DECREMENT;
				} else {
					token = HCC_TOKEN_MINUS;
				}
				break;
			};
			case '/': {
				U8 next_byte = c->tokengen.code[c->tokengen.location.code_end_idx + 1];
				if (next_byte == '/') {
					c->tokengen.location.code_end_idx += 2;
					while (c->tokengen.location.code_end_idx < c->tokengen.code_size) {
						U8 b = c->tokengen.code[c->tokengen.location.code_end_idx];
						if (b == '\n') {
							break;
						}
						c->tokengen.location.code_end_idx += 1;
					}

					token_size = c->tokengen.location.code_end_idx - c->tokengen.location.code_start_idx;
					c->tokengen.location.column_start += token_size;
					c->tokengen.location.column_end += token_size;
					continue;
				} else if (next_byte == '*') {
					hcc_tokengen_advance_column(c, 2);
					while (c->tokengen.location.code_end_idx < c->tokengen.code_size) {
						U8 b = c->tokengen.code[c->tokengen.location.code_end_idx];
						if (byte == '\n') {
							hcc_tokengen_advance_newline(c);
						} else {
							hcc_tokengen_advance_column(c, 1);
							if (b == '*') {
								b = c->tokengen.code[c->tokengen.location.code_end_idx];
								if (b == '/') { // no need to check in bounds see _HCC_TOKENIZER_LOOK_HEAD_SIZE
									hcc_tokengen_advance_column(c, 1);
									break;
								}
							}
						}
					}

					c->tokengen.location.column_start = c->tokengen.location.column_end;
					continue;
				} else if (next_byte == '=') {
					token_size = 2;
					token = HCC_TOKEN_DIVIDE_ASSIGN;
				} else {
					token = HCC_TOKEN_FORWARD_SLASH;
				}
				break;
			};
			case '*':
				if (c->tokengen.code[c->tokengen.location.code_end_idx + 1] == '=') {
					token_size = 2;
					token = HCC_TOKEN_MULTIPLY_ASSIGN;
				} else {
					token = HCC_TOKEN_ASTERISK;
				}
				break;
			case '%':
				if (c->tokengen.code[c->tokengen.location.code_end_idx + 1] == '=') {
					token_size = 2;
					token = HCC_TOKEN_MODULO_ASSIGN;
				} else {
					token = HCC_TOKEN_PERCENT;
				}
				break;
			case '&': {
				U8 next_byte = c->tokengen.code[c->tokengen.location.code_end_idx + 1];
				if (next_byte == '&') {
					token_size = 2;
					token = HCC_TOKEN_LOGICAL_AND;
				} else if (next_byte == '=') {
					token_size = 2;
					token = HCC_TOKEN_BIT_AND_ASSIGN;
				} else {
					token = HCC_TOKEN_AMPERSAND;
				}
				break;
			};
			case '|': {
				U8 next_byte = c->tokengen.code[c->tokengen.location.code_end_idx + 1];
				if (next_byte == '|') {
					token_size = 2;
					token = HCC_TOKEN_LOGICAL_OR;
				} else if (next_byte == '=') {
					token_size = 2;
					token = HCC_TOKEN_BIT_OR_ASSIGN;
				} else {
					token = HCC_TOKEN_PIPE;
				}
				break;
			};
			case '^':
				if (c->tokengen.code[c->tokengen.location.code_end_idx + 1] == '=') {
					token_size = 2;
					token = HCC_TOKEN_BIT_XOR_ASSIGN;
				} else {
					token = HCC_TOKEN_CARET;
				}
				break;
			case '!':
				if (c->tokengen.code[c->tokengen.location.code_end_idx + 1] == '=') {
					token_size = 2;
					token = HCC_TOKEN_LOGICAL_NOT_EQUAL;
				} else {
					token = HCC_TOKEN_EXCLAMATION_MARK;
				}
				break;
			case '=':
				if (c->tokengen.code[c->tokengen.location.code_end_idx + 1] == '=') {
					token_size = 2;
					token = HCC_TOKEN_LOGICAL_EQUAL;
				} else {
					token = HCC_TOKEN_EQUAL;
				}
				break;
			case '<': {
				if (run_mode == HCC_TOKENGEN_RUN_MODE_PP_INCLUDE_OPERAND) {
					hcc_tokengen_parse_string(c, '>', false);
					continue;
				}
				U8 next_byte = c->tokengen.code[c->tokengen.location.code_end_idx + 1];
				if (next_byte == '=') {
					token_size = 2;
					token = HCC_TOKEN_LESS_THAN_OR_EQUAL;
				} else if (next_byte == '<') {
					if (c->tokengen.code[c->tokengen.location.code_end_idx + 2] == '=') {
						token_size = 3;
						token = HCC_TOKEN_BIT_SHIFT_LEFT_ASSIGN;
					} else {
						token_size = 2;
						token = HCC_TOKEN_BIT_SHIFT_LEFT;
					}
				} else {
					token = HCC_TOKEN_LESS_THAN;
				}
				break;
			};
			case '>': {
				U8 next_byte = c->tokengen.code[c->tokengen.location.code_end_idx + 1];
				if (next_byte == '=') {
					token_size = 2;
					token = HCC_TOKEN_GREATER_THAN_OR_EQUAL;
				} else if (next_byte == '>') {
					if (c->tokengen.code[c->tokengen.location.code_end_idx + 2] == '=') {
						token_size = 3;
						token = HCC_TOKEN_BIT_SHIFT_RIGHT_ASSIGN;
					} else {
						token_size = 2;
						token = HCC_TOKEN_BIT_SHIFT_RIGHT;
					}
				} else {
					token = HCC_TOKEN_GREATER_THAN;
				}
				break;
			};
			case '(':
				macro_args_nested_parenthesis_count += 1;
				token = HCC_TOKEN_PARENTHESIS_OPEN;
				goto OPEN_BRACKET;
			case '{': token = HCC_TOKEN_CURLY_OPEN; goto OPEN_BRACKET;
			case '[': token = HCC_TOKEN_SQUARE_OPEN; goto OPEN_BRACKET;
OPEN_BRACKET: {}
				if (run_mode == HCC_TOKENGEN_RUN_MODE_CODE) {
					HccLocation* location = hcc_stack_get_next_push(c->tokengen.token_locations);
					hcc_tokengen_bracket_open(c, token, location);
				}
				break;

			case ')':
				macro_args_nested_parenthesis_count -= 1;
				token = HCC_TOKEN_PARENTHESIS_CLOSE;
				if (run_mode == HCC_TOKENGEN_RUN_MODE_PP_MACRO_ARGS && macro_args_nested_parenthesis_count == 0) {
					hcc_tokengen_advance_column(c, 1);
					hcc_tokengen_token_add(c, token);
					goto RETURN;
				}
				goto CLOSE_BRACKET;
			case '}': token = HCC_TOKEN_CURLY_CLOSE; goto CLOSE_BRACKET;
			case ']': token = HCC_TOKEN_SQUARE_CLOSE; goto CLOSE_BRACKET;
CLOSE_BRACKET:
				if (run_mode == HCC_TOKENGEN_RUN_MODE_CODE) {
					hcc_tokengen_bracket_close(c, token, &c->tokengen.location);
				}
				break;

			case '"':
				hcc_tokengen_parse_string(c, '"', false);
				continue;

			case '\\':
				if (!hcc_tokengen_consume_backslash(c)) {
					hcc_tokengen_token_add(c, HCC_TOKEN_BACK_SLASH);
				}
				continue;

			case '#':
				switch (run_mode) {
					case HCC_TOKENGEN_RUN_MODE_PP_INCLUDE_OPERAND:
					case HCC_TOKENGEN_RUN_MODE_PP_IF_OPERAND:
					case HCC_TOKENGEN_RUN_MODE_PP_OPERAND:
						hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_INVALID_TOKEN_HASH_IN_PP_OPERAND);
					case HCC_TOKENGEN_RUN_MODE_PP_DEFINE_REPLACEMENT_LIST:
						hcc_tokengen_consume_hash_for_define_replacement_list(c);
						continue;
					case HCC_TOKENGEN_RUN_MODE_PP_CONCAT:
						if (c->tokengen.code[c->tokengen.location.code_end_idx + 1] == '#') {
							hcc_tokengen_advance_column(c, 2); // skip the '##'
							hcc_tokengen_token_add(c, HCC_TOKEN_DOUBLE_HASH);
							continue;
						} else {
							hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_INVALID_TOKEN, '#');
						}
						break;
					case HCC_TOKENGEN_RUN_MODE_PP_MACRO_ARGS:
						hcc_tokengen_advance_column(c, 1);
						hcc_tokengen_token_add(c, HCC_TOKEN_HASH);
						continue;
					case HCC_TOKENGEN_RUN_MODE_CODE:
						if (hcc_tokengen_is_first_non_whitespace_on_line(c)) {
							hcc_pp_parse_directive(c);
							continue;
						} else {
							hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_PP_DIRECTIVE_NOT_FIRST_ON_LINE);
						}
						break;
				}
				break;

			default: {
				if ('0' <= byte && byte <= '9') {
					token_size = hcc_tokengen_parse_num(c, &token);
					break;
				}

				HccString ident_string = hcc_tokengen_parse_ident(c, HCC_ERROR_CODE_INVALID_TOKEN);
				hcc_tokengen_advance_column(c, ident_string.size);

				HccStringId ident_string_id = hcc_string_table_deduplicate(&c->string_table, (char*)ident_string.data, ident_string.size);
				if (run_mode == HCC_TOKENGEN_RUN_MODE_PP_IF_OPERAND && ident_string_id.idx_plus_one == HCC_STRING_ID_DEFINED) {
					hcc_pp_parse_defined(c);
					continue;
				}

				if (ident_string_id.idx_plus_one == HCC_STRING_ID___VA_ARGS__) {
					if (run_mode != HCC_TOKENGEN_RUN_MODE_PP_DEFINE_REPLACEMENT_LIST || !c->tokengen.macro_has_va_arg) {
						c->tokengen.location.column_end += ident_string.size;
						hcc_tokengen_bail_error_1(c, HCC_ERROR_CODE_INVALID_USE_OF_VA_ARGS);
					}

					hcc_tokengen_token_add(c, HCC_TOKEN_MACRO_PARAM);
					hcc_tokengen_token_value_add(c, ((HccTokenValue){ .macro_param_idx = c->tokengen.macro_params_count - 1 }));
					continue;
				}

				if (run_mode == HCC_TOKENGEN_RUN_MODE_PP_DEFINE_REPLACEMENT_LIST) {
					U32 param_idx = hcc_tokengen_find_macro_param(c, ident_string_id);
					if (param_idx < c->tokengen.macro_params_count) {
						hcc_tokengen_token_add(c, HCC_TOKEN_MACRO_PARAM);
						hcc_tokengen_token_value_add(c, ((HccTokenValue){ .macro_param_idx = param_idx }));
						continue;
					}
				}

				if (run_mode == HCC_TOKENGEN_RUN_MODE_CODE) {
					U32 macro_idx;
					if (hcc_hash_table_find(&c->pp.macro_declarations, ident_string_id.idx_plus_one, &macro_idx)) {
						if (HCC_STRING_ID_PREDEFINED_MACROS_START <= ident_string_id.idx_plus_one && ident_string_id.idx_plus_one < HCC_STRING_ID_PREDEFINED_MACROS_END) {
							HccPPPredefinedMacro m = ident_string_id.idx_plus_one - HCC_STRING_ID_PREDEFINED_MACROS_START;
							hcc_pp_copy_expand_predefined_macro(c, m);
							continue;
						} else {
							HccPPMacro* macro = hcc_pp_macro_get(c, macro_idx);
							bool can_expand = true;

							HccLocation macro_callsite_location = c->tokengen.location;
							if (macro->is_function) {
								HccLocation backup_location = c->tokengen.location;
								U32 backup_lines_count = hcc_stack_count(c->tokengen.location.code_file->line_code_start_indices);

								hcc_tokengen_consume_whitespace_and_newlines(c);
								if (c->tokengen.code[c->tokengen.location.code_end_idx] != '(') {
									//
									// the identifier is a macro function but we don't actually call it.
									// so return back and just process this as a regular identifier.
									c->tokengen.location = backup_location;
									hcc_stack_resize(c->tokengen.location.code_file->line_code_start_indices, backup_lines_count);
									can_expand = false;
								}
							}

							if (can_expand) {
								hcc_pp_copy_expand_macro_begin(c, macro, &macro_callsite_location);
								continue;
							}
						}
					}
				}

				if (HCC_STRING_ID_KEYWORDS_START <= ident_string_id.idx_plus_one && ident_string_id.idx_plus_one < HCC_STRING_ID_KEYWORDS_END) {
					token = HCC_TOKEN_KEYWORDS_START + (ident_string_id.idx_plus_one - HCC_STRING_ID_KEYWORDS_START);
				} else {
					token = HCC_TOKEN_IDENT;
					HccTokenValue token_value;
					token_value.string_id = ident_string_id;
					hcc_tokengen_token_value_add(c, token_value);
				}

				hcc_tokengen_token_add(c, token);
				continue;
			};
		}

		hcc_tokengen_advance_column(c, token_size);
		hcc_tokengen_token_add(c, token);
	}

RETURN: {}
	if (run_mode == HCC_TOKENGEN_RUN_MODE_CODE && hcc_stack_count(c->tokengen.paused_file_stack) == 0) {
		hcc_tokengen_token_add(c, HCC_TOKEN_EOF);
	}
	c->tokengen.run_mode = old_run_mode;
	c->tokengen.dst_token_bag = old_dst_token_bag;
}

void hcc_tokengen_print(HccCompiler* c, FILE* f) {
	uint32_t token_value_idx = 0;
	for (uint32_t i = 0; i < hcc_stack_count(c->tokengen.token_bag.tokens); i += 1) {
		HccToken token = *hcc_stack_get(c->tokengen.token_bag.tokens, i);
		HccTokenValue value;
		HccString string;
		switch (token) {
			case HCC_TOKEN_IDENT:
				value = *hcc_stack_get(c->tokengen.token_bag.token_values, token_value_idx);
				token_value_idx += 1;
				string = hcc_string_table_get(&c->string_table, value.string_id);
				fprintf(f, "%s -> %.*s\n", hcc_token_strings[token], (int)string.size, string.data);
				break;
			case HCC_TOKEN_STRING:
				value = *hcc_stack_get(c->tokengen.token_bag.token_values, token_value_idx);
				token_value_idx += 1;
				string = hcc_string_table_get(&c->string_table, value.string_id);
				fprintf(f, "%s -> \"%.*s\"\n", hcc_token_strings[token], (int)string.size, string.data);
				break;
			case HCC_TOKEN_LIT_SINT:
			case HCC_TOKEN_LIT_SLONG:
			case HCC_TOKEN_LIT_SLONGLONG:
			case HCC_TOKEN_LIT_UINT:
			case HCC_TOKEN_LIT_ULONG:
			case HCC_TOKEN_LIT_ULONGLONG:
			case HCC_TOKEN_LIT_FLOAT:
			case HCC_TOKEN_LIT_DOUBLE:
				value = *hcc_stack_get(c->tokengen.token_bag.token_values, token_value_idx);
				fprintf(f, "%s -> ", hcc_token_strings[token]);
				hcc_constant_print(c, value.constant_id, stdout);
				fprintf(f, "\n");
				token_value_idx += hcc_token_num_values(token);
				break;
			default:
				fprintf(f, "%s\n", hcc_token_strings[token]);
				token_value_idx += hcc_token_num_values(token);
				break;
		}
	}

	for (U32 macros_idx = 0; macros_idx < hcc_stack_count(c->pp.macros); macros_idx += 1) {
		HccPPMacro* macro = hcc_stack_get(c->pp.macros, macros_idx);
		HccString name = hcc_string_table_get(&c->string_table, macro->identifier_string_id);
		HccTokenCursor cursor = macro->token_cursor;
		hcc_stack_clear(c->pp.stringify_buffer);
		HccStringId string_id = hcc_token_bag_stringify_range(c, &c->pp.macro_token_bag, &cursor, macro);
		HccString string = hcc_string_table_get(&c->string_table, string_id);
		fprintf(f, "#define %.*s", (int)name.size, name.data);
		char macro_param_names[1024];
		if (macro->is_function) {
			fprintf(f, "(");
			for (U32 idx = 0; idx < macro->params_count; idx += 1) {
				HccStringId param_string_id = *hcc_stack_get(c->pp.macro_params, macro->params_start_idx + idx);
				HccString param_string = hcc_string_table_get(&c->string_table, param_string_id);
				fprintf(f, "%.*s", (int)param_string.size, param_string.data);
				if (idx + 1 < macro->params_count) {
					fprintf(f, ", ");
				}
			}
			fprintf(f, ")");
		}
		fprintf(f, " %.*s\n", (int)string.size, string.data);
	}
}

// ===========================================
//
//
// Syntax Generator
//
//
// ===========================================

HccToken hcc_specifier_tokens[HCC_SPECIFIER_COUNT] = {
	[HCC_SPECIFIER_STATIC] =           HCC_TOKEN_KEYWORD_STATIC,
	[HCC_SPECIFIER_INLINE] =           HCC_TOKEN_KEYWORD_INLINE,
	[HCC_SPECIFIER_NO_RETURN] =        HCC_TOKEN_KEYWORD_NO_RETURN,
	[HCC_SPECIFIER_INTRINSIC] =        HCC_TOKEN_KEYWORD_INTRINSIC,
	[HCC_SPECIFIER_RASTERIZER_STATE] = HCC_TOKEN_KEYWORD_RASTERIZER_STATE,
	[HCC_SPECIFIER_FRAGMENT_STATE] =   HCC_TOKEN_KEYWORD_FRAGMENT_STATE,
	[HCC_SPECIFIER_BUFFER_ELEMENT] =   HCC_TOKEN_KEYWORD_BUFFER_ELEMENT,
	[HCC_SPECIFIER_RESOURCE_SET] =     HCC_TOKEN_KEYWORD_RESOURCE_SET,
	[HCC_SPECIFIER_RESOURCE_TABLE] =   HCC_TOKEN_KEYWORD_RESOURCE_TABLE,
	[HCC_SPECIFIER_RESOURCES] =        HCC_TOKEN_KEYWORD_RESOURCES,
	[HCC_SPECIFIER_POSITION] =         HCC_TOKEN_KEYWORD_POSITION,
	[HCC_SPECIFIER_NOINTERP] =         HCC_TOKEN_KEYWORD_NOINTERP,
	[HCC_SPECIFIER_VERTEX] =           HCC_TOKEN_KEYWORD_VERTEX,
	[HCC_SPECIFIER_FRAGMENT] =         HCC_TOKEN_KEYWORD_FRAGMENT,
};

U8 hcc_unary_op_precedence[HCC_UNARY_OP_COUNT] = {
	[HCC_UNARY_OP_BIT_NOT] = 2,
	[HCC_UNARY_OP_LOGICAL_NOT] = 2,
	[HCC_UNARY_OP_PLUS] = 2,
	[HCC_UNARY_OP_NEGATE] = 2,
	[HCC_UNARY_OP_PRE_INCREMENT] = 2,
	[HCC_UNARY_OP_PRE_DECREMENT] = 2,
	[HCC_UNARY_OP_POST_INCREMENT] = 1,
	[HCC_UNARY_OP_POST_DECREMENT] = 1,
	[HCC_UNARY_OP_DEREF] = 2,
	[HCC_UNARY_OP_ADDRESS_OF] = 2,
};

void hcc_astgen_init(HccCompiler* c, HccCompilerSetup* setup) {
	HccAstGen* astgen = &c->astgen;
	U32 compound_data_types_cap = setup->astgen.struct_data_types_cap + setup->astgen.union_data_types_cap;
	U32 global_declarations_cap = setup->astgen.typedefs_cap + setup->astgen.functions_cap + setup->astgen.enum_values_cap + setup->astgen.global_variables_cap;
	astgen->token_bag = c->tokengen.token_bag;

	astgen->function_params_and_variables = hcc_stack_init(HccVariable, setup->astgen.function_params_and_variables_cap, HCC_ALLOC_TAG_ASTGEN_FUNCTION_PARAMS_AND_VARIABLES);
	astgen->functions = hcc_stack_init(HccFunction, setup->astgen.functions_cap, HCC_ALLOC_TAG_ASTGEN_FUNCTIONS);
	astgen->exprs = hcc_stack_init(HccExpr, setup->astgen.exprs_cap, HCC_ALLOC_TAG_ASTGEN_EXPRS);
	astgen->expr_locations = hcc_stack_init(HccLocation, setup->astgen.expr_locations_cap, HCC_ALLOC_TAG_ASTGEN_EXPR_LOCATIONS);
	astgen->global_variables = hcc_stack_init(HccVariable, setup->astgen.global_variables_cap, HCC_ALLOC_TAG_ASTGEN_GLOBAL_VARIABLES);
	astgen->function_used_function_indices = hcc_stack_init(U32, setup->astgen.function_used_function_indices_cap, HCC_ALLOC_TAG_ASTGEN_FUNCTION_USED_FUNCTION_INDICES);
	astgen->function_used_static_variables = hcc_stack_init(HccDecl, setup->astgen.function_used_static_variables_cap, HCC_ALLOC_TAG_ASTGEN_FUNCTION_USED_STATIC_VARIABLES);
	astgen->entry_point_function_indices = hcc_stack_init(U32, setup->astgen.entry_point_function_indices_cap, HCC_ALLOC_TAG_ASTGEN_ENTRY_POINT_FUNCTION_INDICES);
	astgen->used_function_indices = hcc_stack_init(U32, setup->astgen.used_function_indices_cap, HCC_ALLOC_TAG_ASTGEN_USED_FUNCTION_INDICES);
	astgen->recursive_function_indices_stack = hcc_stack_init(U32, setup->astgen.recursive_function_indices_stack_cap, HCC_ALLOC_TAG_ASTGEN_RECURSIVE_FUNCTION_INDICES_STACK);
	astgen->array_data_types = hcc_stack_init(HccArrayDataType, setup->astgen.array_data_types_cap, HCC_ALLOC_TAG_ASTGEN_ARRAY_DATA_TYPES);
	astgen->compound_data_types = hcc_stack_init(HccCompoundDataType, compound_data_types_cap, HCC_ALLOC_TAG_ASTGEN_COMPOUND_DATA_TYPES);
	astgen->compound_fields = hcc_stack_init(HccCompoundField, setup->astgen.compound_fields_cap, HCC_ALLOC_TAG_ASTGEN_COMPOUND_FIELDS);
	astgen->typedefs = hcc_stack_init(HccTypedef, setup->astgen.typedefs_cap, HCC_ALLOC_TAG_ASTGEN_TYPEDEFS);
	astgen->enum_data_types = hcc_stack_init(HccEnumDataType, setup->astgen.enum_data_types_cap, HCC_ALLOC_TAG_ASTGEN_ENUM_DATA_TYPES);
	astgen->enum_values = hcc_stack_init(HccEnumValue, setup->astgen.enum_values_cap, HCC_ALLOC_TAG_ASTGEN_ENUM_VALUES);
	astgen->ordered_data_types = hcc_stack_init(HccDataType, setup->astgen.ordered_data_types_cap, HCC_ALLOC_TAG_ASTGEN_ORDERED_DATA_TYPES);
	astgen->compound_type_find_fields = hcc_stack_init(HccFieldAccess, setup->astgen.compound_type_find_fields_cap, HCC_ALLOC_TAG_ASTGEN_COMPOUND_TYPE_FIND_FIELDS);

	hcc_hash_table_init(&astgen->global_declarations, global_declarations_cap, HCC_ALLOC_TAG_ASTGEN_GLOBAL_DECLARATIONS);
	hcc_hash_table_init(&astgen->struct_declarations, setup->astgen.struct_data_types_cap, HCC_ALLOC_TAG_ASTGEN_STRUCT_DECLARATIONS);
	hcc_hash_table_init(&astgen->union_declarations, setup->astgen.union_data_types_cap, HCC_ALLOC_TAG_ASTGEN_UNION_DECLARATIONS);
	hcc_hash_table_init(&astgen->enum_declarations, setup->astgen.enum_data_types_cap, HCC_ALLOC_TAG_ASTGEN_ENUM_DECLARATIONS);

	astgen->curly_initializer.nested = hcc_stack_init(HccAstGenCurlyInitializerNested, setup->astgen.curly_initializer_nested_cap, HCC_ALLOC_TAG_ASTGEN_CURLY_INITIALIZER_NESTED_CURLYS);
	astgen->curly_initializer.nested_curlys = hcc_stack_init(HccAstGenCurlyInitializerCurly, setup->astgen.curly_initializer_nested_curlys_cap, HCC_ALLOC_TAG_ASTGEN_CURLY_INITIALIZER_NESTED_CURLYS);
	astgen->curly_initializer.nested_elmts = hcc_stack_init(HccAstGenCurlyInitializerElmt, setup->astgen.curly_initializer_nested_elmts_cap, HCC_ALLOC_TAG_ASTGEN_CURLY_INITIALIZER_NESTED_ELMTS);
	astgen->curly_initializer.designated_initializers = hcc_stack_init(HccAstGenDesignatorInitializer, setup->astgen.curly_initializer_designator_initializers_cap, HCC_ALLOC_TAG_ASTGEN_CURLY_INITIALIZER_DESIGNATOR_INITIALIZERS);
	astgen->curly_initializer.designated_initializer_elmt_indices = hcc_stack_init(U64, setup->astgen.curly_initializer_designator_initializer_elmt_indices_cap, HCC_ALLOC_TAG_ASTGEN_CURLY_INITIALIZER_DESIGNATOR_INITIALIZER_ELMT_INDICES);

	astgen->variable_stack_strings = hcc_stack_init(HccStringId, setup->astgen.variable_stack_cap, HCC_ALLOC_TAG_ASTGEN_VARIABLE_STACK_STRINGS);
	astgen->variable_stack_var_indices = hcc_stack_init(U32, setup->astgen.variable_stack_cap, HCC_ALLOC_TAG_ASTGEN_VARIABLE_STACK_VAR_INDICES);

	hcc_stack_resize(c->astgen.typedefs, HCC_TYPEDEF_IDX_USER_START);
	hcc_stack_resize(c->astgen.compound_data_types, HCC_COMPOUND_DATA_TYPE_IDX_USER_START);
	hcc_stack_resize(c->astgen.functions, HCC_FUNCTION_IDX_USER_START);

	hcc_hash_table_init(&astgen->field_name_to_token_idx, setup->astgen.compound_type_fields_cap, HCC_ALLOC_TAG_ASTGEN_FIELD_NAME_TO_TOKEN_IDX);
}

void hcc_astgen_error_1(HccCompiler* c, HccErrorCode error_code, ...) {
	va_list va_args;
	va_start(va_args, error_code);
	U32 token_idx = HCC_MIN(c->astgen.token_read_idx, hcc_stack_count(c->astgen.token_bag.tokens) - 1);
	HccLocation* location = hcc_token_bag_location_get(c, &c->astgen.token_bag, token_idx);
	hcc_error_pushv(c, error_code, location, NULL, va_args);
	va_end(va_args);
}

void hcc_astgen_error_2_idx(HccCompiler* c, HccErrorCode error_code, U32 other_token_idx, ...) {
	va_list va_args;
	va_start(va_args, other_token_idx);
	U32 token_idx = HCC_MIN(c->astgen.token_read_idx, hcc_stack_count(c->astgen.token_bag.tokens) - 1);
	HccLocation* location = hcc_token_bag_location_get(c, &c->astgen.token_bag, token_idx);
	HccLocation* other_location = other_token_idx == U32_MAX ? NULL : hcc_token_bag_location_get(c, &c->astgen.token_bag, other_token_idx);
	hcc_error_pushv(c, error_code, location, other_location, va_args);
	va_end(va_args);
}

void hcc_astgen_error_2_ptr(HccCompiler* c, HccErrorCode error_code, HccLocation* other_location, ...) {
	va_list va_args;
	va_start(va_args, other_location);
	U32 token_idx = HCC_MIN(c->astgen.token_read_idx, hcc_stack_count(c->astgen.token_bag.tokens) - 1);
	HccLocation* location = hcc_token_bag_location_get(c, &c->astgen.token_bag, token_idx);
	hcc_error_pushv(c, error_code, location, other_location, va_args);
	va_end(va_args);
}

void hcc_astgen_warn_1(HccCompiler* c, HccWarnCode warn_code, ...) {
	va_list va_args;
	va_start(va_args, warn_code);
	U32 token_idx = HCC_MIN(c->astgen.token_read_idx, hcc_stack_count(c->astgen.token_bag.tokens) - 1);
	HccLocation* location = hcc_token_bag_location_get(c, &c->astgen.token_bag, token_idx);
	hcc_warn_pushv(c, warn_code, location, NULL, va_args);
	va_end(va_args);
}

void hcc_astgen_warn_2_idx(HccCompiler* c, HccWarnCode warn_code, U32 other_token_idx, ...) {
	va_list va_args;
	va_start(va_args, other_token_idx);
	U32 token_idx = HCC_MIN(c->astgen.token_read_idx, hcc_stack_count(c->astgen.token_bag.tokens) - 1);
	HccLocation* location = hcc_token_bag_location_get(c, &c->astgen.token_bag, token_idx);
	HccLocation* other_location = other_token_idx == U32_MAX ? NULL : hcc_token_bag_location_get(c, &c->astgen.token_bag, other_token_idx);
	hcc_warn_pushv(c, warn_code, location, other_location, va_args);
	va_end(va_args);
}

void hcc_astgen_warn_2_ptr(HccCompiler* c, HccWarnCode warn_code, HccLocation* other_location, ...) {
	va_list va_args;
	va_start(va_args, other_location);
	U32 token_idx = HCC_MIN(c->astgen.token_read_idx, hcc_stack_count(c->astgen.token_bag.tokens) - 1);
	HccLocation* location = hcc_token_bag_location_get(c, &c->astgen.token_bag, token_idx);
	hcc_warn_pushv(c, warn_code, location, other_location, va_args);
	va_end(va_args);
}

noreturn void hcc_astgen_bail_error_1(HccCompiler* c, HccErrorCode error_code, ...) {
	va_list va_args;
	va_start(va_args, error_code);
	U32 token_idx = HCC_MIN(c->astgen.token_read_idx, hcc_stack_count(c->astgen.token_bag.tokens) - 1);
	HccLocation* location = hcc_token_bag_location_get(c, &c->astgen.token_bag, token_idx);
	hcc_error_pushv(c, error_code, location, NULL, va_args);
	va_end(va_args);

	hcc_compiler_bail(c);
}

noreturn void hcc_astgen_bail_error_1_merge_apply(HccCompiler* c, HccErrorCode error_code, HccLocation* location, ...) {
	va_list va_args;
	va_start(va_args, location);
	U32 token_idx = HCC_MIN(c->astgen.token_read_idx, hcc_stack_count(c->astgen.token_bag.tokens) - 1);
	hcc_location_merge_apply(location, hcc_token_bag_location_get(c, &c->astgen.token_bag, token_idx));
	hcc_error_pushv(c, error_code, location, NULL, va_args);
	va_end(va_args);

	hcc_compiler_bail(c);
}

noreturn void hcc_astgen_bail_error_2_idx(HccCompiler* c, HccErrorCode error_code, U32 other_token_idx, ...) {
	va_list va_args;
	va_start(va_args, other_token_idx);
	U32 token_idx = HCC_MIN(c->astgen.token_read_idx, hcc_stack_count(c->astgen.token_bag.tokens) - 1);
	HccLocation* location = hcc_token_bag_location_get(c, &c->astgen.token_bag, token_idx);
	HccLocation* other_location = other_token_idx == U32_MAX ? NULL : hcc_token_bag_location_get(c, &c->astgen.token_bag, other_token_idx);
	hcc_error_pushv(c, error_code, location, other_location, va_args);
	va_end(va_args);

	hcc_compiler_bail(c);
}

noreturn void hcc_astgen_bail_error_2_ptr(HccCompiler* c, HccErrorCode error_code, HccLocation* other_location, ...) {
	va_list va_args;
	va_start(va_args, other_location);
	U32 token_idx = HCC_MIN(c->astgen.token_read_idx, hcc_stack_count(c->astgen.token_bag.tokens) - 1);
	HccLocation* location = hcc_token_bag_location_get(c, &c->astgen.token_bag, token_idx);
	hcc_error_pushv(c, error_code, location, other_location, va_args);
	va_end(va_args);

	hcc_compiler_bail(c);
}

HccToken hcc_astgen_token_peek(HccCompiler* c) {
	return c->astgen.token_bag.tokens[HCC_MIN(c->astgen.token_read_idx, hcc_stack_count(c->astgen.token_bag.tokens) - 1)];
}

HccToken hcc_astgen_token_peek_ahead(HccCompiler* c, U32 by) {
	return c->astgen.token_bag.tokens[HCC_MIN(c->astgen.token_read_idx + by, hcc_stack_count(c->astgen.token_bag.tokens) - 1)];
}

void hcc_astgen_token_consume(HccCompiler* c, U32 amount) {
	c->astgen.token_read_idx += amount;
}

HccToken hcc_astgen_token_next(HccCompiler* c) {
	c->astgen.token_read_idx += 1;
	return c->astgen.token_bag.tokens[HCC_MIN(c->astgen.token_read_idx, hcc_stack_count(c->astgen.token_bag.tokens) - 1)];
}

void hcc_astgen_token_value_consume(HccCompiler* c, U32 amount) {
	c->astgen.token_value_read_idx += amount;
}

HccTokenValue hcc_astgen_token_value_peek(HccCompiler* c) {
	HccTokenValue value = c->astgen.token_bag.token_values[HCC_MIN(c->astgen.token_value_read_idx, hcc_stack_count(c->astgen.token_bag.token_values) - 1)];
	return value;
}

HccTokenValue hcc_astgen_token_value_next(HccCompiler* c) {
	HccTokenValue value = c->astgen.token_bag.token_values[HCC_MIN(c->astgen.token_value_read_idx, hcc_stack_count(c->astgen.token_bag.token_values) - 1)];
	c->astgen.token_value_read_idx += 1;
	return value;
}

void hcc_astgen_data_type_found(HccCompiler* c, HccDataType data_type) {
	*hcc_stack_push(c->astgen.ordered_data_types) = data_type;
}

HccCompoundField* hcc_astgen_compound_data_type_find_field_by_name(HccCompiler* c, HccCompoundDataType* compound_data_type, HccStringId identifier_string_id) {
	hcc_stack_clear(c->astgen.compound_type_find_fields);
	return hcc_astgen_compound_data_type_find_field_by_name_recursive(c, compound_data_type, identifier_string_id);
}

HccCompoundField* hcc_astgen_compound_data_type_find_field_by_name_checked(HccCompiler* c, HccDataType data_type, HccCompoundDataType* compound_data_type, HccStringId identifier_string_id) {
	HccCompoundField* field = hcc_astgen_compound_data_type_find_field_by_name(c, compound_data_type, identifier_string_id);
	if (field == NULL) {
		HccString data_type_name = hcc_data_type_string(c, data_type);
		HccString identifier_string = hcc_string_table_get(&c->string_table, identifier_string_id);
		hcc_astgen_bail_error_2_idx(c, HCC_ERROR_CODE_CANNOT_FIND_FIELD, compound_data_type->identifier_token_idx, (int)identifier_string.size, identifier_string.data, (int)data_type_name.size, data_type_name.data);
	}
	return field;
}

HccCompoundField* hcc_astgen_compound_data_type_find_field_by_name_recursive(HccCompiler* c, HccCompoundDataType* compound_data_type, HccStringId identifier_string_id) {
	HccFieldAccess* access = hcc_stack_push(c->astgen.compound_type_find_fields);
	for (U32 field_idx = 0; field_idx < compound_data_type->fields_count; field_idx += 1) {
		HccCompoundField* field = &c->astgen.compound_fields[compound_data_type->fields_start_idx + field_idx];
		access->data_type = field->data_type;
		access->idx = field_idx;

		if (field->identifier_string_id.idx_plus_one == 0) {
			//
			// we have an anonymous compound data type as a field.
			// so nest down and search for the identifier in there too
			HccCompoundDataType* field_compound_data_type = hcc_compound_data_type_get(c, field->data_type);
			HccCompoundField* nested_field = hcc_astgen_compound_data_type_find_field_by_name_recursive(c, field_compound_data_type, identifier_string_id);
			if (nested_field) {
				return nested_field;
			}
		}

		if (field->identifier_string_id.idx_plus_one == identifier_string_id.idx_plus_one) {
			// found a field so return success
			return field;
		}
	}

	//
	// no luck finding the field, so remove this result and return failure
	hcc_stack_pop(c->astgen.compound_type_find_fields);
	return NULL;
}

void hcc_astgen_static_variable_usage_found(HccCompiler* c, HccDecl decl) {
	bool found = false;
	U32 end_idx = hcc_stack_count(c->astgen.function_used_static_variables);
	for (U32 idx = c->astgen.function->used_static_variables_start_idx; idx < end_idx; idx += 1) {
		if (c->astgen.function_used_static_variables[idx] == decl) {
			found = true;
			break;
		}
	}
	if (!found) {
		*hcc_stack_push(c->astgen.function_used_static_variables) = decl;
	}
}

void hcc_astgen_insert_global_declaration(HccCompiler* c, HccStringId identifier_string_id, HccDecl decl) {
	HccDecl* decl_ptr;
	if (hcc_hash_table_find_or_insert(&c->astgen.global_declarations, identifier_string_id.idx_plus_one, &decl_ptr)) {
		U32 other_token_idx = hcc_decl_token_idx(c, *decl_ptr);
		HccString string = hcc_string_table_get(&c->string_table, identifier_string_id);
		hcc_astgen_bail_error_2_idx(c, HCC_ERROR_CODE_REDEFINITION_IDENTIFIER_GLOBAL, other_token_idx, (int)string.size, string.data);
	}
	*decl_ptr = decl;
}

void hcc_astgen_eval_cast(HccCompiler* c, HccExpr* expr, HccDataType dst_data_type) {
	HCC_DEBUG_ASSERT(expr->type == HCC_EXPR_TYPE_CONSTANT, "internal error: expected to be evaluating a constant");
	HccConstantId constant_id = { .idx_plus_one = expr->constant.id };
	HccConstant constant = hcc_constant_table_get(c, constant_id);

	HccBasic basic;
	if (HCC_DATA_TYPE_IS_UINT(c, expr->data_type)) {
		U64 uint;
		hcc_constant_as_uint(c, constant, &uint);
		basic = hcc_basic_from_uint(c, dst_data_type, uint);
	} else if (HCC_DATA_TYPE_IS_SINT(c, expr->data_type)) {
		S64 sint;
		hcc_constant_as_sint(c, constant, &sint);
		basic = hcc_basic_from_sint(c, dst_data_type, sint);
	} else if (HCC_DATA_TYPE_IS_FLOAT(expr->data_type)) {
		F64 float_;
		hcc_constant_as_float(c, constant, &float_);
		basic = hcc_basic_from_float(c, dst_data_type, float_);
	} else {
		HCC_ABORT("unhandled data type '%u'", expr->data_type);
	}

	constant_id = hcc_constant_table_deduplicate_basic(c, dst_data_type, &basic);
	expr->constant.id = constant_id.idx_plus_one;
	expr->data_type = dst_data_type;
}

bool hcc_stmt_has_return(HccExpr* stmt) {
	if (stmt->type == HCC_EXPR_TYPE_STMT_RETURN) {
		return true;
	} else if (stmt->type == HCC_EXPR_TYPE_STMT_BLOCK && stmt->stmt_block.has_return_stmt) {
		return true;
	} else if (stmt->type == HCC_EXPR_TYPE_STMT_IF && stmt[stmt->if_.true_stmt_rel_idx].if_aux.true_and_false_stmts_have_return_stmt) {
		return true;
	}
	return false;
}

HccExpr* hcc_astgen_alloc_expr(HccCompiler* c, HccExprType type) {
	HccExpr* expr = hcc_stack_push(c->astgen.exprs);
	expr->type = type;
	expr->is_stmt_block_entry = false;
	return expr;
}

HccExpr* hcc_astgen_alloc_expr_many(HccCompiler* c, U32 amount) {
	return hcc_stack_push_many(c->astgen.exprs, amount);
}

const char* hcc_type_specifier_string(HccTypeSpecfier specifier) {
	switch (specifier) {
		case HCC_TYPE_SPECIFIER_VOID: return "void";
		case HCC_TYPE_SPECIFIER_BOOL: return "_Bool";
		case HCC_TYPE_SPECIFIER_CHAR: return "char";
		case HCC_TYPE_SPECIFIER_SHORT: return "short";
		case HCC_TYPE_SPECIFIER_INT: return "int";
		case HCC_TYPE_SPECIFIER_LONG: return "long";
		case HCC_TYPE_SPECIFIER_LONGLONG: return "long long";
		case HCC_TYPE_SPECIFIER_FLOAT: return "float";
		case HCC_TYPE_SPECIFIER_DOUBLE: return "double";
		case HCC_TYPE_SPECIFIER_GENERIC_FLOAT: return "__hcc_generic_float";
		case HCC_TYPE_SPECIFIER_UNSIGNED: return "unsigned";
		case HCC_TYPE_SPECIFIER_SIGNED: return "signed";
		case HCC_TYPE_SPECIFIER_COMPLEX: return "_Complex";
		case HCC_TYPE_SPECIFIER_ATOMIC: return "_Atomic";
		default: return NULL;
	}
}

void hcc_astgen_data_type_ensure_is_condition(HccCompiler* c, HccDataType data_type) {
	data_type = hcc_typedef_resolve_and_strip_const_volatile(c, data_type);
	if (!hcc_data_type_is_condition(c, data_type)) {
		HccString data_type_name = hcc_data_type_string(c, data_type);
		hcc_astgen_error_1(c, HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_CONDITION, (int)data_type_name.size, data_type_name.data);
	}
}

void hcc_astgen_compound_data_type_validate_field_names(HccCompiler* c, HccDataType outer_data_type, HccCompoundDataType* compound_data_type) {
	for (U32 field_idx = 0; field_idx < compound_data_type->fields_count; field_idx += 1) {
		HccCompoundField* field = &c->astgen.compound_fields[compound_data_type->fields_start_idx + field_idx];
		if (field->identifier_string_id.idx_plus_one == 0) {
			HccCompoundDataType* field_compound_data_type = hcc_compound_data_type_get(c, field->data_type);
			hcc_astgen_compound_data_type_validate_field_names(c, outer_data_type, field_compound_data_type);
		} else {
			U32* dst_token_idx;
			bool result = hcc_hash_table_find_or_insert(&c->astgen.field_name_to_token_idx, field->identifier_string_id.idx_plus_one, &dst_token_idx);
			if (result) {
				c->astgen.token_read_idx = field->identifier_token_idx;
				HccString field_identifier_string = hcc_string_table_get(&c->string_table, field->identifier_string_id);
				HccString data_type_name = hcc_data_type_string(c, outer_data_type);
				hcc_astgen_bail_error_2_idx(c, HCC_ERROR_CODE_DUPLICATE_FIELD_IDENTIFIER, *dst_token_idx, (int)field_identifier_string.size, field_identifier_string.data, (int)data_type_name.size, data_type_name.data);
			}
			*dst_token_idx = field->identifier_token_idx;
		}
	}
}

void hcc_astgen_validate_specifiers(HccCompiler* c, HccSpecifierFlags non_specifiers, HccErrorCode invalid_specifier_error_code) {
	while (c->astgen.specifier_flags & non_specifiers) {
		HccSpecifier specifier = HCC_LEAST_SET_BIT_IDX_U32(c->astgen.specifier_flags & non_specifiers);
		HccToken token = hcc_specifier_tokens[specifier];
		hcc_astgen_error_1(c, invalid_specifier_error_code, hcc_token_strings[token]);
		c->astgen.specifier_flags = HCC_LEAST_SET_BIT_REMOVE(c->astgen.specifier_flags);
	}
}

void hcc_astgen_ensure_semicolon(HccCompiler* c) {
	HccToken token = hcc_astgen_token_peek(c);
	if (token != HCC_TOKEN_SEMICOLON) {
		hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_MISSING_SEMICOLON);
	}
	hcc_astgen_token_next(c);
}

void hcc_astgen_ensure_not_unsupported_basic_type(HccCompiler* c, HccLocation* location, HccDataType data_type) {
	data_type = HCC_DATA_TYPE_STRIP_CONST(data_type);
	HccIntrinsicBasicTypeMask mask = hcc_data_type_has_intrinsic_basic_types(c, data_type); // & ~c->spirvgen.available_basic_types;
	if (mask) {
		U32 other_token_idx = hcc_data_type_token_idx(c, data_type);
		HccString data_type_string = hcc_data_type_string(c, data_type);
		HccString mask_string = hcc_intrinsic_basic_type_mask_string(mask);

		HccLocation* other_location = other_token_idx == U32_MAX ? NULL : hcc_token_bag_location_get(c, &c->astgen.token_bag, other_token_idx);
		c->message_sys.next_is_deferred = true;
		hcc_error_push(c, HCC_ERROR_CODE_UNSUPPORTED_INTRINSIC_TYPE_USED, location, other_location, (int)data_type_string.size, data_type_string.data, (int)mask_string.size, mask_string.data);
	}
}

bool hcc_data_type_check_compatible_assignment(HccCompiler* c, HccDataType target_data_type, HccExpr** source_expr_mut) {
	HccExpr* source_expr = *source_expr_mut;
	HccDataType source_data_type = source_expr->data_type;
	if (HCC_DATA_TYPE_IS_CONST(target_data_type)) {
		return false;
	}

	target_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, target_data_type);
	source_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, source_data_type);
	if (target_data_type == source_data_type) {
		return true;
	}

	if (target_data_type == HCC_DATA_TYPE_GENERIC_FLOAT && (source_data_type == HCC_DATA_TYPE_FLOAT || source_data_type == HCC_DATA_TYPE_DOUBLE)) {
		return true;
	}

	if (HCC_DATA_TYPE_IS_BASIC(target_data_type) && HCC_DATA_TYPE_IS_BASIC(source_data_type)) {
		hcc_astgen_generate_implicit_cast(c, target_data_type, source_expr_mut);
		return true;
	}

	return false;
}

void hcc_data_type_ensure_compatible_assignment(HccCompiler* c, U32 other_token_idx, HccDataType target_data_type, HccExpr** source_expr_mut) {
	if (!hcc_data_type_check_compatible_assignment(c, target_data_type, source_expr_mut)) {
		HccString target_data_type_name = hcc_data_type_string(c, target_data_type);
		HccString source_data_type_name = hcc_data_type_string(c, (*source_expr_mut)->data_type);
		hcc_astgen_bail_error_2_idx(c, HCC_ERROR_CODE_TYPE_MISMATCH_IMPLICIT_CAST, other_token_idx, (int)source_data_type_name.size, source_data_type_name.data, (int)target_data_type_name.size, target_data_type_name.data);
	}
}

bool hcc_data_type_check_compatible_arithmetic(HccCompiler* c, HccExpr** left_expr_mut, HccExpr** right_expr_mut) {
	HccExpr* left_expr = *left_expr_mut;
	HccExpr* right_expr = *right_expr_mut;

	HccDataType left_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, left_expr->data_type);
	HccDataType right_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, right_expr->data_type);
	if (left_data_type == right_data_type) {
		return true;
	}

	if (HCC_DATA_TYPE_IS_BASIC(left_data_type) && HCC_DATA_TYPE_IS_BASIC(right_data_type)) {
		bool left_is_float = HCC_DATA_TYPE_IS_FLOAT(left_data_type);
		bool right_is_float = HCC_DATA_TYPE_IS_FLOAT(right_data_type);
		U8 left_rank = hcc_data_type_basic_type_ranks[left_data_type];
		U8 right_rank = hcc_data_type_basic_type_ranks[right_data_type];
		if (left_is_float || right_is_float) {
			//
			// if one of operands is a float, then cast lower ranked operand
			// into the type of the higher ranked operand
			if (left_rank < right_rank) {
				hcc_astgen_generate_implicit_cast(c, right_data_type, left_expr_mut);
			} else if (left_rank > right_rank) {
				hcc_astgen_generate_implicit_cast(c, left_data_type, right_expr_mut);
			}
		} else {
			//
			// both operands are integers
			//

			{
				//
				// promote each operand to an int if it has a lower rank
				//

				U8 int_rank = hcc_data_type_basic_type_ranks[HCC_DATA_TYPE_SINT];
				if (left_rank < int_rank) {
					hcc_astgen_generate_implicit_cast(c, HCC_DATA_TYPE_SINT, left_expr_mut);
					left_data_type = HCC_DATA_TYPE_SINT;
					left_rank = int_rank;
				}

				if (right_rank < int_rank) {
					hcc_astgen_generate_implicit_cast(c, HCC_DATA_TYPE_SINT, right_expr_mut);
					right_data_type = HCC_DATA_TYPE_SINT;
					right_rank = int_rank;
				}
			}

			if (left_data_type != right_data_type) {
				bool left_is_unsigned = HCC_DATA_TYPE_IS_UINT(c, left_data_type);
				bool right_is_unsigned = HCC_DATA_TYPE_IS_UINT(c, right_data_type);
				if (left_is_unsigned == right_is_unsigned) {
					//
					// both types are either unsigned or signed,
					// so cast the type with the lower rank to the higher ranked type.
					//

					if (left_rank < right_rank) {
						hcc_astgen_generate_implicit_cast(c, right_data_type, left_expr_mut);
					} else {
						hcc_astgen_generate_implicit_cast(c, left_data_type, right_expr_mut);
					}

					return true;
				}

				//
				// from here one of the operands is unsigned and the other is signed.
				//

				//
				// if unsigned operand has a higher or equal rank to the signed type,
				// then convert the other operand into the unsigned data type.
				//
				if (right_is_unsigned && left_rank <= right_rank) {
					hcc_astgen_generate_implicit_cast(c, right_data_type, left_expr_mut);
					return true;
				} else if (left_is_unsigned && left_rank >= right_rank) {
					hcc_astgen_generate_implicit_cast(c, left_data_type, right_expr_mut);
					return true;
				}

				//
				// check to see if the unsigned type can fit in the other signed type.
				// if it can, convert it into that.
				//
				if (left_is_unsigned && c->basic_type_size_and_aligns[left_data_type] < c->basic_type_size_and_aligns[right_data_type]) {
					hcc_astgen_generate_implicit_cast(c, right_data_type, left_expr_mut);
					return true;
				} else if (right_is_unsigned && c->basic_type_size_and_aligns[right_data_type] < c->basic_type_size_and_aligns[left_data_type]) {
					hcc_astgen_generate_implicit_cast(c, left_data_type, right_expr_mut);
					return true;
				}

				//
				// all of the other conversion have failed, so convert both expressions to
				// the unsigned version of the signed data type.
				//
				HccDataType unsigned_data_type = hcc_data_type_signed_to_unsigned(c, right_data_type);
				if (left_is_unsigned) {
					unsigned_data_type = hcc_data_type_signed_to_unsigned(c, right_data_type);
				} else {
					unsigned_data_type = hcc_data_type_signed_to_unsigned(c, left_data_type);
				}
				hcc_astgen_generate_implicit_cast(c, unsigned_data_type, left_expr_mut);
				hcc_astgen_generate_implicit_cast(c, unsigned_data_type, right_expr_mut);
			}
		}

		return true;
	}

	return false;
}

void hcc_data_type_ensure_compatible_arithmetic(HccCompiler* c, U32 other_token_idx, HccExpr** left_expr_mut, HccExpr** right_expr_mut, HccToken operator_token) {
	if (!hcc_data_type_check_compatible_arithmetic(c, left_expr_mut, right_expr_mut)) {
		HccString left_data_type_name = hcc_data_type_string(c, (*left_expr_mut)->data_type);
		HccString right_data_type_name = hcc_data_type_string(c, (*right_expr_mut)->data_type);
		hcc_astgen_bail_error_2_idx(c, HCC_ERROR_CODE_UNSUPPORTED_BINARY_OPERATOR, other_token_idx, hcc_token_strings[operator_token], (int)right_data_type_name.size, right_data_type_name.data, (int)left_data_type_name.size, left_data_type_name.data);
	}
}

void hcc_astgen_ensure_function_args_count(HccCompiler* c, HccFunction* function, U32 args_count) {
	if (args_count < function->params_count) {
		HccString string = hcc_string_table_get(&c->string_table, function->identifier_string_id);
		hcc_astgen_error_2_idx(c, HCC_ERROR_CODE_NOT_ENOUGH_FUNCTION_ARGS, function->identifier_token_idx, function->params_count, args_count, (int)string.size, string.data);
	} else if (args_count > function->params_count) {
		HccString string = hcc_string_table_get(&c->string_table, function->identifier_string_id);
		hcc_astgen_error_2_idx(c, HCC_ERROR_CODE_TOO_MANY_FUNCTION_ARGS, function->identifier_token_idx, function->params_count, args_count, (int)string.size, string.data);
	}
}

HccDataType hcc_astgen_deduplicate_array_data_type(HccCompiler* c, HccDataType element_data_type, HccConstantId size_constant_id) {
	element_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, element_data_type);
	U32 count = hcc_stack_count(c->astgen.array_data_types);
	for (U32 i = 0; i < count; i += 1) {
		HccArrayDataType* d = hcc_stack_get(c->astgen.array_data_types, i);
		if (d->element_data_type == element_data_type && d->size_constant_id.idx_plus_one == size_constant_id.idx_plus_one) {
			return HCC_DATA_TYPE_INIT(HCC_DATA_TYPE_ARRAY, i);
		}
	}

	U32 array_data_types_idx = count;
	HccArrayDataType* d = hcc_stack_push(c->astgen.array_data_types);
	d->element_data_type = element_data_type;
	d->size_constant_id = size_constant_id;

	if (HCC_DATA_TYPE_IS_COMPOSITE_TYPE(element_data_type)) {
		HccCompoundDataType* field_compound_data_type = hcc_compound_data_type_get(c, element_data_type);
		if (field_compound_data_type->flags & HCC_COMPOUND_DATA_TYPE_FLAGS_HAS_RESOURCE) {
			d->has_resource = true;
		}
		if (field_compound_data_type->flags & HCC_COMPOUND_DATA_TYPE_FLAGS_HAS_POINTER) {
			d->has_pointer = true;
		}
		d->logically_addressable_elements_count += field_compound_data_type->logically_addressable_elements_count;
	} else if (HCC_DATA_TYPE_IS_RESOURCE(element_data_type)) {
		d->has_resource = true;
		d->logically_addressable_elements_count += 1;
	} else if (HCC_DATA_TYPE_IS_POINTER(element_data_type)) {
		d->has_pointer = true;
		d->logically_addressable_elements_count += 1;
	} else if (HCC_DATA_TYPE_IS_ARRAY(element_data_type)) {
		HccArrayDataType* other_d = hcc_array_data_type_get(c, element_data_type);
		d->logically_addressable_elements_count += other_d->logically_addressable_elements_count;
		d->has_resource |= other_d->has_resource;
		d->has_pointer |= other_d->has_pointer;
	}

	U64 cap;
	HccConstant constant = hcc_constant_table_get(c, d->size_constant_id);
	hcc_constant_as_uint(c, constant, &cap);
	d->logically_addressable_elements_count *= cap;

	HccDataType data_type = HCC_DATA_TYPE_INIT(HCC_DATA_TYPE_ARRAY, array_data_types_idx);
	hcc_astgen_data_type_found(c, data_type);
	return data_type;
}

HccDataType hcc_astgen_deduplicate_pointer_data_type(HccCompiler* c, HccDataType element_data_type) {
	element_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, element_data_type);
	U32 count = hcc_stack_count(c->astgen.pointer_data_types);
	for (U32 i = 0; i < count; i += 1) {
		HccPointerDataType* d = hcc_stack_get(c->astgen.pointer_data_types, i);
		if (d->element_data_type == element_data_type) {
			return HCC_DATA_TYPE_POINTER(i);
		}
	}

	U32 pointer_idx = count;
	HccPointerDataType* d = hcc_stack_push(c->astgen.pointer_data_types);
	d->element_data_type = element_data_type;

	HccDataType data_type = HCC_DATA_TYPE_POINTER(pointer_idx);
	return data_type;
}

HccDataType hcc_astgen_deduplicate_simple_buffer_data_type(HccCompiler* c, HccResourceType resource_type, HccDataType element_data_type) {
	element_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, element_data_type);
	U32 count = hcc_stack_count(c->astgen.simple_buffer_data_types);
	for (U32 i = 0; i < count; i += 1) {
		HccSimpleBufferDataType* d = hcc_stack_get(c->astgen.simple_buffer_data_types, i);
		if (d->element_data_type == element_data_type) {
			return HCC_DATA_TYPE_INIT(HCC_DATA_TYPE_RESOURCE_START + resource_type, i);
		}
	}

	U32 simple_buffer_idx = count;
	HccSimpleBufferDataType* d = hcc_stack_push(c->astgen.simple_buffer_data_types);
	d->element_data_type = element_data_type;

	HccDataType data_type = HCC_DATA_TYPE_INIT(HCC_DATA_TYPE_RESOURCE_START + resource_type, simple_buffer_idx);
	return data_type;
}

void _hcc_astgen_ensure_no_unused_specifiers(HccCompiler* c, char* what) {
	if (c->astgen.specifier_flags) {
		HccToken keyword_token;
		if (c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_STATIC) {
			keyword_token = HCC_TOKEN_KEYWORD_STATIC;
		} else if (c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_INLINE) {
			keyword_token = HCC_TOKEN_KEYWORD_INLINE;
		} else if (c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_NO_RETURN) {
			keyword_token = HCC_TOKEN_KEYWORD_NO_RETURN;
		} else if (c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_INTRINSIC) {
			keyword_token = HCC_TOKEN_KEYWORD_INTRINSIC;
		} else if (c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_RASTERIZER_STATE) {
			keyword_token = HCC_TOKEN_KEYWORD_RASTERIZER_STATE;
		} else if (c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_BUFFER_ELEMENT) {
			keyword_token = HCC_TOKEN_KEYWORD_BUFFER_ELEMENT;
		} else if (c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_RESOURCE_SET) {
			keyword_token = HCC_TOKEN_KEYWORD_RESOURCE_SET;
		} else if (c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_RESOURCE_TABLE) {
			keyword_token = HCC_TOKEN_KEYWORD_RESOURCE_TABLE;
		} else if (c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_RESOURCES) {
			keyword_token = HCC_TOKEN_KEYWORD_RESOURCES;
		} else if (c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_FRAGMENT_STATE) {
			keyword_token = HCC_TOKEN_KEYWORD_FRAGMENT_STATE;
		} else if (c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_POSITION) {
			keyword_token = HCC_TOKEN_KEYWORD_POSITION;
		} else if (c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_NOINTERP) {
			keyword_token = HCC_TOKEN_KEYWORD_NOINTERP;
		} else if (c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_VERTEX) {
			keyword_token = HCC_TOKEN_KEYWORD_VERTEX;
		} else if (c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_FRAGMENT) {
			keyword_token = HCC_TOKEN_KEYWORD_FRAGMENT;
		}
		hcc_astgen_error_1(c, HCC_ERROR_CODE_UNUSED_SPECIFIER, hcc_token_strings[keyword_token], what, hcc_token_strings[hcc_astgen_token_peek(c)]);
	}
}

void hcc_astgen_ensure_no_unused_specifiers_data_type(HccCompiler* c) {
	_hcc_astgen_ensure_no_unused_specifiers(c, "a data type");
}

void hcc_astgen_ensure_no_unused_specifiers_identifier(HccCompiler* c) {
	_hcc_astgen_ensure_no_unused_specifiers(c, "an identifier");
}

void hcc_astgen_variable_stack_open(HccCompiler* c) {
	if (hcc_stack_count(c->astgen.variable_stack_strings) == 0) {
		c->astgen.next_var_idx = 0;
	}
	hcc_stack_push(c->astgen.variable_stack_strings)->idx_plus_one = 0;
	*hcc_stack_push(c->astgen.variable_stack_var_indices) = U32_MAX;
}

void hcc_astgen_variable_stack_close(HccCompiler* c) {
	while (hcc_stack_count(c->astgen.variable_stack_strings)) {
		bool end = hcc_stack_get_last(c->astgen.variable_stack_strings)->idx_plus_one == 0;
		hcc_stack_pop(c->astgen.variable_stack_strings);
		hcc_stack_pop(c->astgen.variable_stack_var_indices);
		if (end) {
			break;
		}
	}
}

U32 hcc_astgen_variable_stack_add(HccCompiler* c, HccStringId string_id) {
	U32 var_idx = c->astgen.next_var_idx;
	*hcc_stack_push(c->astgen.variable_stack_strings) = string_id;
	*hcc_stack_push(c->astgen.variable_stack_var_indices) = var_idx;
	c->astgen.next_var_idx += 1;
	return var_idx;
}

U32 hcc_astgen_variable_stack_find(HccCompiler* c, HccStringId string_id) {
	HCC_DEBUG_ASSERT(string_id.idx_plus_one, "string id is null");
	for (U32 idx = hcc_stack_count(c->astgen.variable_stack_strings); idx-- > 0;) {
		if (hcc_stack_get(c->astgen.variable_stack_strings, idx)->idx_plus_one == string_id.idx_plus_one) {
			return *hcc_stack_get(c->astgen.variable_stack_var_indices, idx) + 1;
		}
	}
	return 0;
}

void hcc_astgen_logical_address_declared(HccCompiler* c, HccVariable* variable) {
	HCC_DEBUG_ASSERT(variable->logical_address_mutations_start_idx, "variable has already been declared");
	U32 logically_address_elements_count = hcc_data_type_logically_address_elements_count(c, variable->data_type);
	HCC_DEBUG_ASSERT(logically_address_elements_count, "logically_address_elements_count must not be zero here as the type should contain logically addressed data types");

	variable->logical_address_mutations_start_idx = hcc_stack_count(c->astgen.logical_address_mutations);
	hcc_stack_push_many(c->astgen.logical_address_mutations, logically_address_elements_count);
}

U32 hcc_astgen_logical_address_mutation_idx_from_expr(HccCompiler* c, HccExpr* expr) {
	switch (expr->type) {
		case HCC_EXPR_TYPE_FIELD_ACCESS: {
			HccExpr* left_expr = expr - expr->binary.left_expr_rel_idx;
			U32 base_idx = hcc_astgen_logical_address_mutation_idx_from_expr(c, left_expr);

			U32 field_idx = expr->binary.right_expr_rel_idx;
			HccDataType resolved_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, left_expr->data_type);
			HccCompoundDataType* d = hcc_compound_data_type_get(c, resolved_data_type);
			for (U32 idx = 0; idx < field_idx; idx += 1) {
				HccCompoundField* field = hcc_stack_get(c->astgen.compound_fields, d->fields_start_idx + idx);
				base_idx += hcc_data_type_logically_address_elements_count(c, field->data_type);

			}
			return base_idx;
		};
		case HCC_EXPR_TYPE_ARRAY_SUBSCRIPT: {
			HccExpr* left_expr = expr - expr->binary.left_expr_rel_idx;
			U32 base_idx = hcc_astgen_logical_address_mutation_idx_from_expr(c, left_expr);

			S32 elmt_idx = expr->binary.right_expr_rel_idx;
			HccDataType resolved_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, left_expr->data_type);
			HccArrayDataType* d = hcc_array_data_type_get(c, resolved_data_type);
			base_idx += elmt_idx * hcc_data_type_logically_address_elements_count(c, d->element_data_type);
			return base_idx;
		};
		case HCC_EXPR_TYPE_LOCAL_VARIABLE: {
			HccVariable* variable = hcc_stack_get(c->astgen.function_params_and_variables, c->astgen.function->params_start_idx + expr->variable.idx);
			return variable->logical_address_mutations_start_idx;
		};

		default: HCC_UNREACHABLE();
	}
}

void hcc_astgen_logical_address_apply_assigned(HccCompiler* c, U32 logical_mutation_base_idx, HccDataType data_type, HccLocation* location) {
	data_type = hcc_typedef_resolve_and_strip_const_volatile(c, data_type);
	U32 count = 1;
	if (HCC_DATA_TYPE_IS_COMPOUND_TYPE(data_type)) {
		//
		// we are assigning a whole structure so lets update the tracking info
		// for all of the contained logically addressable elements
		HccCompoundDataType* d = hcc_compound_data_type_get(c, data_type);
		count = d->logically_addressable_elements_count;
	}

	for (U32 idx = 0; idx < count; idx += 1) {
		HccLogicalAddressMutation* mut = hcc_stack_get(c->astgen.logical_address_mutations, logical_mutation_base_idx + idx);
		mut->block_id = c->astgen.stmt_block_idx + 1;
		mut->location = location;
	}
}

void hcc_astgen_logical_address_assigned(HccCompiler* c, HccExpr* expr, HccLocation* location) {
	U32 base_idx = hcc_astgen_logical_address_mutation_idx_from_expr(c, expr);
	hcc_astgen_logical_address_apply_assigned(c, base_idx, expr->data_type, location);
}

void hcc_astgen_logical_address_assigned_field(HccCompiler* c, HccVariable* variable, U64* elmt_indices, U32 elmts_count, HccLocation* location) {
	U32 base_idx = variable->logical_address_mutations_start_idx;
	HccDataType data_type = variable->data_type;
	for (U32 elmt_idx = 0; elmt_idx < elmts_count; elmt_idx += 1) {
		data_type = hcc_typedef_resolve_and_strip_const_volatile(c, data_type);
		U32 field_idx = elmt_indices[elmt_idx];
		switch (data_type & 0xff) {
			case HCC_DATA_TYPE_STRUCT:
			case HCC_DATA_TYPE_UNION: {
				HccCompoundDataType* d = hcc_compound_data_type_get(c, data_type);
				for (U32 idx = 0; idx < field_idx; idx += 1) {
					HccCompoundField* field = hcc_stack_get(c->astgen.compound_fields, d->fields_start_idx + idx);
					base_idx += hcc_data_type_logically_address_elements_count(c, field->data_type);
				}
				data_type = hcc_stack_get(c->astgen.compound_fields, d->fields_start_idx + field_idx)->data_type;
				break;
			};
			case HCC_EXPR_TYPE_ARRAY_SUBSCRIPT: {
				HccArrayDataType* d = hcc_array_data_type_get(c, data_type);
				base_idx += field_idx * hcc_data_type_logically_address_elements_count(c, d->element_data_type);
				data_type = d->element_data_type;
				break;
			};
			default: HCC_UNREACHABLE();
		}
	}

	hcc_astgen_logical_address_apply_assigned(c, base_idx, data_type, location);
}

void hcc_astgen_logical_address_used(HccCompiler* c, HccExpr* expr, HccLocation* location) {
	U32 idx = hcc_astgen_logical_address_mutation_idx_from_expr(c, expr);
	HccLogicalAddressMutation* mut = hcc_stack_get(c->astgen.logical_address_mutations, idx);
	if (mut->block_id == 0) {
		hcc_error_push(c, HCC_ERROR_CODE_LOGICAL_ADDRESSED_VAR_USED_BEFORE_ASSIGNED, location, NULL);
		hcc_compiler_bail(c);
	}

	U32 last_assigned_block_idx = mut->block_id - 1;
	while (last_assigned_block_idx) {
		HccStmtBlockInfo last_assigned_block_info = *hcc_astgen_stmt_block_info_get(c, last_assigned_block_idx);
		if (HCC_STMT_BLOCK_INFO_IS_CONDITIONAL_BLOCK(last_assigned_block_info)) {
			//
			// we have found a block that is conditionally accessed before we found a common ancestor block
			// with the assignment and usage expression.
			break;
		}

		U32 used_block_idx = c->astgen.stmt_block_idx;
		while (used_block_idx) {
			if (used_block_idx == last_assigned_block_idx) {
				//
				// we have found a common ancestor block with the assignment and usage expression
				// so we know this value at compile time.
				return;
			}

			HccStmtBlockInfo used_block_info = *hcc_astgen_stmt_block_info_get(c, used_block_idx);

			used_block_idx = HCC_STMT_BLOCK_INFO_PARENT_IDX(used_block_info);
		}

		last_assigned_block_idx = HCC_STMT_BLOCK_INFO_PARENT_IDX(last_assigned_block_info);
	}

	hcc_error_push(c, HCC_ERROR_CODE_LOGICAL_ADDRESSED_CONDITIONALLY_ASSIGNED_BEFORE_USE, location, mut->location);
	hcc_compiler_bail(c);
}

HccToken hcc_astgen_curly_initializer_start(HccCompiler* c, HccDataType data_type, HccDataType resolved_data_type, HccExpr* first_expr) {
	HccAstGenCurlyInitializer* gen = &c->astgen.curly_initializer;
	gen->elmt_data_type = data_type;
	gen->resolved_elmt_data_type = resolved_data_type;

	if (gen->first_initializer_expr) {
		HccAstGenCurlyInitializerNested* nested = hcc_stack_push(gen->nested);
		nested->first_initializer_expr = gen->first_initializer_expr;
		nested->prev_initializer_expr = gen->prev_initializer_expr;
		nested->nested_elmts_start_idx = gen->nested_elmts_start_idx;
	}

	//
	// start the initializer expression linked list with
	// a designated initializer to zero the whole initial composite type.
	gen->first_initializer_expr = first_expr;
	gen->prev_initializer_expr = first_expr;
	gen->nested_elmts_start_idx = hcc_stack_count(gen->nested_elmts);
	HccExpr* initializer_expr = hcc_astgen_curly_initializer_generate_designated_initializer(c);
	initializer_expr->designated_initializer.value_expr_rel_idx = 0;

	return hcc_astgen_curly_initializer_open(c);
}

HccToken hcc_astgen_curly_initializer_open(HccCompiler* c) {
	HccAstGenCurlyInitializer* gen = &c->astgen.curly_initializer;
	if (!HCC_DATA_TYPE_IS_COMPOSITE_TYPE(gen->resolved_elmt_data_type)) {
		if (gen->elmt_data_type == HCC_DATA_TYPE_VOID) {
			// this is only happens for the first opening initializer when it is not used for an assignment.
			hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INVALID_CURLY_EXPR);
		} else {
			HccString data_type_name = hcc_data_type_string(c, gen->elmt_data_type);
			hcc_astgen_warn_1(c, HCC_WARN_CODE_CURLY_INITIALIZER_ON_SCALAR, (int)data_type_name.size, data_type_name.data);
		}
	}

	*hcc_stack_push(gen->nested_curlys) = (HccAstGenCurlyInitializerCurly) {
		.nested_elmts_start_idx = hcc_stack_count(gen->nested_elmts) + 1,
		.found_designator = false,
	};

	hcc_astgen_curly_initializer_tunnel_in(c);
	return hcc_astgen_token_next(c);
}

HccToken hcc_astgen_curly_initializer_close(HccCompiler* c, bool is_finished) {
	HccAstGenCurlyInitializer* gen = &c->astgen.curly_initializer;

	//
	// restore the elements back to where the parent curly initializer was inserted.
	// so we start searching from the parent curly initializer.
	U32 new_elmts_count = hcc_stack_get_last(gen->nested_curlys)->nested_elmts_start_idx - 1;
	hcc_stack_resize(gen->nested_elmts, new_elmts_count);
	hcc_stack_pop(gen->nested_curlys);

	if (is_finished) {
		return 0;
	}

	HccAstGenCurlyInitializerElmt* nested_elmt = hcc_stack_get_last(gen->nested_elmts);
	hcc_astgen_curly_initializer_set_composite(c, nested_elmt->data_type, nested_elmt->resolved_data_type);

	return hcc_astgen_token_next(c);
}

bool hcc_astgen_curly_initializer_next_elmt(HccCompiler* c, HccDataType resolved_target_data_type) {
	HccAstGenCurlyInitializer* gen = &c->astgen.curly_initializer;

	//
	// tunnel in and out the composite data types until we reach the next non composite data type
	while (1) {
		HccAstGenCurlyInitializerElmt* nested_elmt = hcc_stack_get_last(gen->nested_elmts);
		HccAstGenCurlyInitializerCurly* curly = hcc_stack_get_last(gen->nested_curlys);
		bool had_explicit_designator_for_union_field = nested_elmt->had_explicit_designator_for_union_field;

		nested_elmt->elmt_idx += 1;
		nested_elmt->had_explicit_designator_for_union_field = false;

		if (!had_explicit_designator_for_union_field && nested_elmt->elmt_idx >= gen->elmts_end_idx) {
			//
			// the end of this initializer/data_type has been reached.
			// it could be either a composite or non composite data type.
			//

			if (curly->nested_elmts_start_idx == hcc_stack_count(gen->nested_elmts)) {
				//
				// here we have reached the end of the initializers for the explicit curly braces { }.
				// so we have a initializer that is targeting nothing.
				HccString data_type_name = hcc_data_type_string(c, gen->composite_data_type);
				hcc_astgen_warn_1(c, HCC_WARN_CODE_UNUSED_INITIALIZER_REACHED_END, (int)data_type_name.size, data_type_name.data);
				return false;
			} else {
				//
				// otherwise we are tunneled inside a nested composite data type.
				// which means one of it's parents has explicit curly braces.
				// so we just tunnel back out of our nested composite data type.
				hcc_astgen_curly_initializer_tunnel_out(c);
			}
		} else {
			if (HCC_DATA_TYPE_IS_COMPOUND_TYPE(gen->resolved_composite_data_type)) {
				//
				// this is a compound data type so fetch the next element data type
				gen->elmt_data_type = gen->compound_fields[nested_elmt->elmt_idx].data_type;
				gen->resolved_elmt_data_type = hcc_typedef_resolve_and_keep_const_volatile(c, gen->elmt_data_type);
			}

			if (resolved_target_data_type == gen->resolved_elmt_data_type) {
				return true;
			}

			if (resolved_target_data_type == HCC_DATA_TYPE_VOID) {
				return true;
			}

			if (HCC_DATA_TYPE_IS_COMPOSITE_TYPE(gen->resolved_elmt_data_type)) {
				hcc_astgen_curly_initializer_tunnel_in(c);
			} else {
				//
				// we found the non composite data type
				return true;
			}
		}
	}
}

HccToken hcc_astgen_curly_initializer_next_elmt_with_designator(HccCompiler* c) {
	HccToken token = hcc_astgen_token_peek(c);
	HCC_DEBUG_ASSERT(token == HCC_TOKEN_FULL_STOP || token == HCC_TOKEN_SQUARE_OPEN, "internal error: expected '.' or '['");
	HccAstGenCurlyInitializer* gen = &c->astgen.curly_initializer;
	HccAstGenCurlyInitializerCurly* curly = hcc_stack_get_last(gen->nested_curlys);
	curly->found_designator = true;

	//
	// remove all of the excess nested elements so we are back on
	// the open curly braces that we are in.
	hcc_stack_resize(gen->nested_elmts, curly->nested_elmts_start_idx);
	HccAstGenCurlyInitializerElmt* nested_elmt = hcc_stack_get_last(gen->nested_elmts);
	hcc_astgen_curly_initializer_set_composite(c, nested_elmt->data_type, nested_elmt->resolved_data_type);

	//
	// parse and process the chain of designators for the composite types
	// eg: .field[0].another
	while (1) {
		switch (token) {
			case HCC_TOKEN_FULL_STOP:
				if (HCC_DATA_TYPE_IS_ARRAY(gen->resolved_composite_data_type)) {
					HccString data_type_name = hcc_data_type_string(c, gen->composite_data_type);
					hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_FIELD_DESIGNATOR_ON_ARRAY_TYPE, (int)data_type_name.size, data_type_name.data);
				}

				token = hcc_astgen_token_next(c);
				if (token != HCC_TOKEN_IDENT) {
					HccString data_type_name = hcc_data_type_string(c, gen->composite_data_type);
					hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_IDENTIFIER_FIELD_DESIGNATOR, (int)data_type_name.size, data_type_name.data);
				}

				HccStringId identifier_string_id = hcc_astgen_token_value_next(c).string_id;
				hcc_astgen_compound_data_type_find_field_by_name_checked(c, gen->composite_data_type, gen->compound_data_type, identifier_string_id);
				for (U32 i = 0; i < hcc_stack_count(c->astgen.compound_type_find_fields); i += 1) {
					HccFieldAccess* field = hcc_stack_get(c->astgen.compound_type_find_fields, i);
					hcc_stack_get_last(gen->nested_elmts)->elmt_idx = field->idx;
					hcc_astgen_curly_initializer_nested_elmt_push(c, field->data_type, hcc_typedef_resolve_and_keep_const_volatile(c, field->data_type));
				}

				if (hcc_stack_count(c->astgen.compound_type_find_fields) > 1) {
					gen->composite_data_type = hcc_stack_get_back(c->astgen.compound_type_find_fields, 1)->data_type;
					gen->resolved_composite_data_type = hcc_typedef_resolve_and_keep_const_volatile(c, gen->composite_data_type);
					gen->compound_data_type = hcc_compound_data_type_get(c, gen->resolved_composite_data_type);
					gen->compound_fields = hcc_stack_get(c->astgen.compound_fields, gen->compound_data_type->fields_start_idx);
				}

				gen->elmt_data_type = hcc_stack_get_last(c->astgen.compound_type_find_fields)->data_type;
				gen->resolved_elmt_data_type = hcc_typedef_resolve_and_keep_const_volatile(c, gen->elmt_data_type);
				token = hcc_astgen_token_next(c);
				break;
			case HCC_TOKEN_SQUARE_OPEN:
				if (!HCC_DATA_TYPE_IS_ARRAY(gen->resolved_composite_data_type)) {
					HccString data_type_name = hcc_data_type_string(c, gen->composite_data_type);
					hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_ARRAY_DESIGNATOR_ON_COMPOUND_TYPE, (int)data_type_name.size, data_type_name.data);
				}

				token = hcc_astgen_token_next(c);
				HccExpr* expr = hcc_astgen_generate_expr(c, 0);
				if (expr->type != HCC_EXPR_TYPE_CONSTANT || !HCC_DATA_TYPE_IS_INT(expr->data_type)) {
					HccString data_type_name = hcc_data_type_string(c, gen->composite_data_type);
					hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_INTEGER_FOR_ARRAY_IDX, (int)data_type_name.size, data_type_name.data);
				}

				HccConstantId value_constant_id = { .idx_plus_one = expr->constant.id };
				HccConstant constant = hcc_constant_table_get(c, value_constant_id);
				U64 elmt_idx;
				if (!hcc_constant_as_uint(c, constant, &elmt_idx) || elmt_idx >= gen->elmts_end_idx) {
					hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_ARRAY_INDEX_OUT_OF_BOUNDS, gen->elmts_end_idx);
				}

				token = hcc_astgen_token_peek(c);
				if (token != HCC_TOKEN_SQUARE_CLOSE) {
					hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_ARRAY_DESIGNATOR_EXPECTED_SQUARE_BRACE_CLOSE);
				}
				token = hcc_astgen_token_next(c);

				hcc_stack_get_last(gen->nested_elmts)->elmt_idx = elmt_idx;
				hcc_astgen_curly_initializer_nested_elmt_push(c, gen->elmt_data_type, gen->resolved_elmt_data_type);
				break;
			case HCC_TOKEN_EQUAL:
				goto END;
			default: {
				//
				// we reach here when we have looped at least once and we do not have a '=', '.' or '[' with a compatible composite data type
				HccErrorCode error_code;
				if (HCC_DATA_TYPE_IS_ARRAY(gen->resolved_composite_data_type)) {
					error_code = HCC_ERROR_CODE_EXPECTED_ASSIGN_OR_ARRAY_DESIGNATOR;
				} else if (HCC_DATA_TYPE_IS_COMPOUND_TYPE(gen->resolved_composite_data_type)) {
					error_code = HCC_ERROR_CODE_EXPECTED_ASSIGN_OR_FIELD_DESIGNATOR;
				} else {
					HccString data_type_name = hcc_data_type_string(c, gen->composite_data_type);
					HCC_UNREACHABLE("we only handle array and compound types here right? but we got '%.*s'", (int)data_type_name.size, data_type_name.data);
				}
				hcc_astgen_bail_error_1(c, error_code);
			};
		}

		if (token == HCC_TOKEN_EQUAL) {
			// we reach here after processing a array or field designator that is followed by a '='
			goto END;
		} else if (!HCC_DATA_TYPE_IS_COMPOSITE_TYPE(gen->resolved_elmt_data_type)) {
			HccString data_type_name = hcc_data_type_string(c, gen->elmt_data_type);
			hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_ASSIGN, (int)data_type_name.size, data_type_name.data);
		}

		hcc_astgen_curly_initializer_set_composite(c, gen->elmt_data_type, gen->resolved_elmt_data_type);
	}
END: {}
	token = hcc_astgen_token_next(c);

	//
	// pop off the last nested element since we don't
	// want to tunnel into the last designator in the chain.
	hcc_stack_pop(gen->nested_elmts);

	if (token != HCC_TOKEN_CURLY_OPEN) {
		// take away one as the next call to hcc_astgen_curly_initializer_next_elmt
		// will increment it past where the designator has specified.
		nested_elmt = hcc_stack_get_last(gen->nested_elmts);
		nested_elmt->elmt_idx -= 1;
		nested_elmt->had_explicit_designator_for_union_field = HCC_DATA_TYPE_IS_UNION(gen->resolved_composite_data_type);
	}
	return token;
}

void hcc_astgen_curly_initializer_nested_elmt_push(HccCompiler* c, HccDataType data_type, HccDataType resolved_data_type) {
	HccAstGenCurlyInitializer* gen = &c->astgen.curly_initializer;
	*hcc_stack_push(gen->nested_elmts) = (HccAstGenCurlyInitializerElmt) {
		.elmt_idx = -1, // start on -1 so that it'll be 0 after the first call to hcc_astgen_curly_initializer_next_elmt
		.data_type =  data_type,
		.resolved_data_type = resolved_data_type,
	};
}

void hcc_astgen_curly_initializer_tunnel_in(HccCompiler* c) {
	HccAstGenCurlyInitializer* gen = &c->astgen.curly_initializer;
	hcc_astgen_curly_initializer_nested_elmt_push(c, gen->elmt_data_type, gen->resolved_elmt_data_type);
	hcc_astgen_curly_initializer_set_composite(c, gen->elmt_data_type, gen->resolved_elmt_data_type);
}

void hcc_astgen_curly_initializer_tunnel_out(HccCompiler* c) {
	HccAstGenCurlyInitializer* gen = &c->astgen.curly_initializer;
	hcc_stack_pop(gen->nested_elmts);
	HccAstGenCurlyInitializerElmt* nested_elmt = hcc_stack_get_last(gen->nested_elmts);
	hcc_astgen_curly_initializer_set_composite(c, nested_elmt->data_type, nested_elmt->resolved_data_type);
}

void hcc_astgen_curly_initializer_set_composite(HccCompiler* c, HccDataType data_type, HccDataType resolved_data_type) {
	HccAstGenCurlyInitializer* gen = &c->astgen.curly_initializer;

	gen->composite_data_type = data_type;
	gen->resolved_composite_data_type = resolved_data_type;
	if (HCC_DATA_TYPE_IS_ARRAY(gen->resolved_composite_data_type)) {
		gen->array_data_type = hcc_array_data_type_get(c, gen->resolved_composite_data_type);

		HccConstant constant = hcc_constant_table_get(c, gen->array_data_type->size_constant_id);
		U64 cap;
		hcc_constant_as_uint(c, constant, &cap);

		gen->elmt_data_type = gen->array_data_type->element_data_type;
		gen->resolved_elmt_data_type = hcc_typedef_resolve_and_keep_const_volatile(c, gen->elmt_data_type);
		gen->elmts_end_idx = cap;
	} else if (HCC_DATA_TYPE_IS_COMPOUND_TYPE(gen->resolved_composite_data_type)) {
		gen->compound_data_type = hcc_compound_data_type_get(c, gen->resolved_composite_data_type);
		gen->compound_fields = hcc_stack_get(c->astgen.compound_fields, gen->compound_data_type->fields_start_idx);
		gen->elmt_data_type = gen->compound_fields[0].data_type;
		gen->resolved_elmt_data_type = hcc_typedef_resolve_and_keep_const_volatile(c, gen->elmt_data_type);

		gen->elmts_end_idx = HCC_DATA_TYPE_IS_UNION(gen->resolved_composite_data_type) ? 1 : gen->compound_data_type->fields_count;
	} else {
		//
		// non composite data type that has explicit curly braces { }.
		gen->elmt_data_type = data_type;
		gen->resolved_elmt_data_type = resolved_data_type;
		gen->elmts_end_idx = 1;
	}
}

HccExpr* hcc_astgen_curly_initializer_generate_designated_initializer(HccCompiler* c) {
	HccAstGenCurlyInitializer* gen = &c->astgen.curly_initializer;
	U32 elmt_indices_start_idx = gen->nested_elmts_start_idx;
	U32 elmt_indices_end_idx = hcc_stack_count(gen->nested_elmts);
	U32 elmt_indices_count = elmt_indices_end_idx - elmt_indices_start_idx;

	//
	// setup the auxillary data
	U32 designated_initializer_idx = hcc_stack_count(gen->designated_initializers);
	HccAstGenDesignatorInitializer* designated_initializer = hcc_stack_push(gen->designated_initializers);
	designated_initializer->elmt_indices_start_idx = hcc_stack_count(gen->designated_initializer_elmt_indices);
	designated_initializer->elmt_indices_count = elmt_indices_count;

	//
	// copy the element indices out into the persistant array
	U64* elmt_indices = hcc_stack_push_many(gen->designated_initializer_elmt_indices, elmt_indices_count);
	for (U32 idx = 0; idx < elmt_indices_count; idx += 1) {
		elmt_indices[idx] = hcc_stack_get(gen->nested_elmts, elmt_indices_start_idx + idx)->elmt_idx;
	}

	//
	// create the expression node and reference the auxillary data
	HccExpr* initializer_expr = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_DESIGNATED_INITIALIZER);
	initializer_expr->is_stmt_block_entry = true;
	initializer_expr->next_expr_rel_idx = 0;
	initializer_expr->alt_next_expr_rel_idx = designated_initializer_idx;

	//
	// append to the link list of designated initializers
	if (gen->prev_initializer_expr) {
		gen->prev_initializer_expr->next_expr_rel_idx = initializer_expr - gen->prev_initializer_expr;
	} else {
		gen->first_initializer_expr = initializer_expr;
	}
	gen->prev_initializer_expr = initializer_expr;

	return initializer_expr;
}

U32 hcc_astgen_stmt_block_info_alloc(HccCompiler* c, U32 parent_idx) {
	U32 block_idx = hcc_stack_count(c->astgen.stmt_block_infos);
	HccStmtBlockInfo* stmt_block_info = hcc_stack_push(c->astgen.stmt_block_infos);
	*stmt_block_info = HCC_STMT_BLOCK_INFO(parent_idx);
	return block_idx - c->astgen.function->blocks_start_idx;
}

HccStmtBlockInfo* hcc_astgen_stmt_block_info_get(HccCompiler* c, U32 block_idx) {
	return hcc_stack_get(c->astgen.stmt_block_infos, c->astgen.function->blocks_start_idx + block_idx);
}

void hcc_astgen_stmt_block_found_conditional(HccCompiler* c, U32 block_idx) {
	HccStmtBlockInfo* stmt_block_info = hcc_astgen_stmt_block_info_get(c, block_idx);
	HCC_STMT_BLOCK_INFO_SET_IS_CONDITIONAL_BLOCK(stmt_block_info);
}

HccToken hcc_astgen_generate_specifiers(HccCompiler* c) {
	HccToken token = hcc_astgen_token_peek(c);
	while (1) {
		HccSpecifierFlags flag = 0;
		switch (token) {
			case HCC_TOKEN_KEYWORD_STATIC:           flag = HCC_SPECIFIER_FLAGS_STATIC;           break;
			case HCC_TOKEN_KEYWORD_INLINE:           flag = HCC_SPECIFIER_FLAGS_INLINE;           break;
			case HCC_TOKEN_KEYWORD_NO_RETURN:        flag = HCC_SPECIFIER_FLAGS_NO_RETURN;        break;
			case HCC_TOKEN_KEYWORD_INTRINSIC:        flag = HCC_SPECIFIER_FLAGS_INTRINSIC;        break;
			case HCC_TOKEN_KEYWORD_RASTERIZER_STATE: flag = HCC_SPECIFIER_FLAGS_RASTERIZER_STATE; break;
			case HCC_TOKEN_KEYWORD_BUFFER_ELEMENT:   flag = HCC_SPECIFIER_FLAGS_BUFFER_ELEMENT;   break;
			case HCC_TOKEN_KEYWORD_RESOURCE_TABLE:   flag = HCC_SPECIFIER_FLAGS_RESOURCE_TABLE;   break;
			case HCC_TOKEN_KEYWORD_RESOURCES:        flag = HCC_SPECIFIER_FLAGS_RESOURCES;        break;
			case HCC_TOKEN_KEYWORD_FRAGMENT_STATE:   flag = HCC_SPECIFIER_FLAGS_FRAGMENT_STATE;   break;
			case HCC_TOKEN_KEYWORD_POSITION:         flag = HCC_SPECIFIER_FLAGS_POSITION;         break;
			case HCC_TOKEN_KEYWORD_NOINTERP:         flag = HCC_SPECIFIER_FLAGS_NOINTERP;         break;
			case HCC_TOKEN_KEYWORD_VERTEX:           flag = HCC_SPECIFIER_FLAGS_VERTEX;           break;
			case HCC_TOKEN_KEYWORD_FRAGMENT:         flag = HCC_SPECIFIER_FLAGS_FRAGMENT;         break;
			case HCC_TOKEN_KEYWORD_AUTO: break;
			case HCC_TOKEN_KEYWORD_VOLATILE:
			case HCC_TOKEN_KEYWORD_EXTERN:
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_UNSUPPORTED_SPECIFIER, hcc_token_strings[token]);
				break;
			case HCC_TOKEN_KEYWORD_RESOURCE_SET:
				flag = HCC_SPECIFIER_FLAGS_RESOURCE_SET;

				token = hcc_astgen_token_next(c);
				if (token != HCC_TOKEN_PARENTHESIS_OPEN) {
					hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_PARENTHESIS_OPEN_RESOURCE_SET_SLOT);
				}
				token = hcc_astgen_token_next(c);

				switch (token) {
					case HCC_TOKEN_LIT_UINT:
					case HCC_TOKEN_LIT_ULONG:
					case HCC_TOKEN_LIT_ULONGLONG:
					case HCC_TOKEN_LIT_SINT:
					case HCC_TOKEN_LIT_SLONG:
					case HCC_TOKEN_LIT_SLONGLONG:
						token = hcc_astgen_token_next(c);
						HccConstantId constant_id = hcc_astgen_token_value_next(c).constant_id;
						HccConstant constant = hcc_constant_table_get(c, constant_id);

						//
						// skip the associated HccStringId kept around to turn the
						// literal back into the exact string it was parsed from.
						hcc_astgen_token_value_next(c);
						bool out_of_bounds = false;
						U64 resource_set_slot;
						if (hcc_constant_as_uint(c, constant, &resource_set_slot)) {
							out_of_bounds = resource_set_slot < c->max_resource_set_slot;
						} else {
							out_of_bounds = true;
						}
						if (out_of_bounds) {
							hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_RESOURCE_SET_SLOT_OUT_OF_BOUNDS, c->max_resource_set_slot, resource_set_slot);
						}
						c->astgen.resource_set_slot = resource_set_slot;
						break;
					default:
						hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_RESOURCE_SET_MUST_BE_A_UINT, c->max_resource_set_slot);
						break;

				}
				if (token != HCC_TOKEN_PARENTHESIS_CLOSE) {
					hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_PARENTHESIS_CLOSE_RESOURCE_SET_SLOT);
				}
				token = hcc_astgen_token_next(c);
				break;
			default: return token;
		}

		if (c->astgen.specifier_flags & flag) {
			hcc_astgen_error_1(c, HCC_ERROR_CODE_SPECIFIER_ALREADY_BEEN_USED, hcc_token_strings[token]);
		}
		c->astgen.specifier_flags |= flag;
		token = hcc_astgen_token_next(c);
	}
}

HccDataType hcc_astgen_generate_enum_data_type(HccCompiler* c) {
	HccToken token = hcc_astgen_token_peek(c);
	HCC_DEBUG_ASSERT(token == HCC_TOKEN_KEYWORD_ENUM, "internal error: expected 'enum' but got '%s'", hcc_token_strings[token]);
	token = hcc_astgen_token_next(c);

	HccDataType data_type;
	HccStringId identifier_string_id = {0};
	HccEnumDataType* enum_data_type = NULL;
	if (token == HCC_TOKEN_IDENT) {
		token = hcc_astgen_token_next(c);
		identifier_string_id = hcc_astgen_token_value_next(c).string_id;

		HccDataType* insert_value_ptr;
		if (hcc_hash_table_find_or_insert(&c->astgen.enum_declarations, identifier_string_id.idx_plus_one, &insert_value_ptr)) {
			data_type = *insert_value_ptr;
			enum_data_type = hcc_enum_data_type_get(c, data_type);
		} else {
			*insert_value_ptr = HCC_DATA_TYPE_INIT(HCC_DATA_TYPE_ENUM, hcc_stack_count(c->astgen.enum_data_types));
			goto MAKE_NEW;
		}
	} else {
MAKE_NEW: {}
		U32 enum_data_type_idx = hcc_stack_count(c->astgen.enum_data_types);
		enum_data_type = hcc_stack_push(c->astgen.enum_data_types);
		memset(enum_data_type, 0x0, sizeof(*enum_data_type)); // TODO: maybe enforce the memory allocators to just give zeroed memory
		enum_data_type->identifier_token_idx = c->astgen.token_read_idx;
		enum_data_type->identifier_string_id = identifier_string_id;

		data_type = HCC_DATA_TYPE_INIT(HCC_DATA_TYPE_ENUM, enum_data_type_idx);
	}

	if (token != HCC_TOKEN_CURLY_OPEN) {
		if (identifier_string_id.idx_plus_one) {
			return data_type;
		}
		hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_CURLY_OPEN_ENUM);
	}

	if (enum_data_type->values_count) {
		HccString data_type_name = hcc_data_type_string(c, data_type);
		c->astgen.token_read_idx -= 1;
		hcc_astgen_bail_error_2_idx(c, HCC_ERROR_CODE_REIMPLEMENTATION, enum_data_type->identifier_token_idx, (int)data_type_name.size, data_type_name.data);
	}

	token = hcc_astgen_token_next(c);
	enum_data_type->identifier_token_idx = c->astgen.token_read_idx - 2;
	enum_data_type->values_start_idx = hcc_stack_count(c->astgen.enum_values);

	if (token == HCC_TOKEN_CURLY_CLOSE) {
		hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EMPTY_ENUM);
	}

	U32 value_idx = enum_data_type->values_start_idx;
	S64 next_value = 0;
	while (token != HCC_TOKEN_CURLY_CLOSE) {
		HccEnumValue* enum_value = hcc_stack_push(c->astgen.enum_values);

		if (token != HCC_TOKEN_IDENT) {
			hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_IDENTIFIER_ENUM_VALUE);
		}

		if (next_value > S32_MAX) {
			hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_ENUM_VALUE_OVERFLOW);
		}

		HccStringId value_identifier_string_id = hcc_astgen_token_value_next(c).string_id;
		enum_value->identifier_token_idx = c->astgen.token_read_idx;
		enum_value->identifier_string_id = value_identifier_string_id;

		HccDecl decl = HCC_DECL_INIT(HCC_DECL_ENUM_VALUE, value_idx);
		hcc_astgen_insert_global_declaration(c, value_identifier_string_id, decl);

		token = hcc_astgen_token_next(c);
		bool has_explicit_value = token == HCC_TOKEN_EQUAL;
		if (has_explicit_value) {
			token = hcc_astgen_token_next(c);

			HccExpr* expr = hcc_astgen_generate_expr_no_comma_operator(c, 0);
			if (expr->type != HCC_EXPR_TYPE_CONSTANT || !HCC_DATA_TYPE_IS_INT(expr->data_type)) {
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_ENUM_VALUE_INVALID_FORMAT);
			}

			HccConstantId value_constant_id = { .idx_plus_one = expr->constant.id };
			HccConstant constant = hcc_constant_table_get(c, value_constant_id);

			S32 value;
			if (!hcc_constant_as_sint32(c, constant, &value)) {
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_ENUM_VALUE_INVALID_FORMAT);
			}

			next_value = value;
			token = hcc_astgen_token_peek(c);
		}

		//
		// do not deduplicate when adding this constant to the constant table so we can pass in a debug name for the code generation to use for the enum value debug info
		HccBasic v = hcc_basic_from_sint(c, HCC_DATA_TYPE_SINT, next_value);
		HccConstantId value_constant_id = _hcc_constant_table_deduplicate_end(c, HCC_DATA_TYPE_SINT, &v, sizeof(S32), sizeof(S32), enum_value->identifier_string_id);

		enum_value->value_constant_id = value_constant_id;
		next_value += 1;

		if (token == HCC_TOKEN_COMMA) {
			token = hcc_astgen_token_next(c);
		} else if (token != HCC_TOKEN_CURLY_CLOSE) {
			HccErrorCode error_code = has_explicit_value
				? HCC_ERROR_CODE_ENUM_VALUE_INVALID_TERMINATOR_WITH_EXPLICIT_VALUE
				: HCC_ERROR_CODE_ENUM_VALUE_INVALID_TERMINATOR;
			hcc_astgen_bail_error_1(c, error_code);
		}

		value_idx += 1;
	}

	enum_data_type->values_count = value_idx - enum_data_type->values_start_idx;

	token = hcc_astgen_token_next(c);
	hcc_astgen_data_type_found(c, data_type);
	return data_type;
}

HccDataType hcc_astgen_generate_compound_data_type(HccCompiler* c) {
	U32 compound_data_type_token_idx = c->astgen.token_read_idx;
	HccToken token = hcc_astgen_token_peek(c);
	bool is_union = false;
	switch (token) {
		case HCC_TOKEN_KEYWORD_STRUCT: break;
		case HCC_TOKEN_KEYWORD_UNION:
			is_union = true;
			break;
		default:
			HCC_UNREACHABLE("internal error: expected 'struct' or 'union' but got '%s'", hcc_token_strings[token]);
	}
	token = hcc_astgen_token_next(c);

	HccDataType data_type;
	HccStringId identifier_string_id = {0};
	HccCompoundDataType* compound_data_type = NULL;
	U32 intrinsic_id = 0;
	if (token == HCC_TOKEN_IDENT) {
		compound_data_type_token_idx = c->astgen.token_read_idx;
		token = hcc_astgen_token_next(c);
		identifier_string_id = hcc_astgen_token_value_next(c).string_id;

		if (c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_INTRINSIC) {
			if (is_union) {
				if (HCC_STRING_ID_VEC_START <= identifier_string_id.idx_plus_one && identifier_string_id.idx_plus_one < HCC_STRING_ID_VEC_END) {
					HccVec vec = identifier_string_id.idx_plus_one - HCC_STRING_ID_VEC_START;
					intrinsic_id = HCC_UNION_IDX_VEC_START + vec + 1;
				} else if (HCC_STRING_ID_MAT_START <= identifier_string_id.idx_plus_one && identifier_string_id.idx_plus_one < HCC_STRING_ID_MAT_END) {
					HccMat mat = identifier_string_id.idx_plus_one - HCC_STRING_ID_MAT_START;
					intrinsic_id = HCC_UNION_IDX_MAT_START + mat + 1;
				} else {
					HccString identifier_string = hcc_string_table_get(&c->string_table, identifier_string_id);
					hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INTRINSIC_NOT_FOUND_STRUCT, (int)identifier_string.size, identifier_string.data);
				}
			} else {
				if (HCC_STRING_ID_PVEC_START <= identifier_string_id.idx_plus_one && identifier_string_id.idx_plus_one < HCC_STRING_ID_PVEC_END) {
					HccVec vec = identifier_string_id.idx_plus_one - HCC_STRING_ID_PVEC_START;
					intrinsic_id = HCC_STRUCT_IDX_PVEC_START + vec + 1;
				} else if (HCC_STRING_ID_PMAT_START <= identifier_string_id.idx_plus_one && identifier_string_id.idx_plus_one < HCC_STRING_ID_MAT_END) {
					HccMat mat = identifier_string_id.idx_plus_one - HCC_STRING_ID_PMAT_START;
					intrinsic_id = HCC_STRUCT_IDX_PMAT_START + mat + 1;
				} else {
					U32 i = 0;
					for (; i < HCC_ARRAY_COUNT(hcc_intrinsic_structs); i += 1) {
						HccIntrinsicStruct* s = &hcc_intrinsic_structs[i];
						if (s->string_id.idx_plus_one == identifier_string_id.idx_plus_one) {
							break;
						}
					}

					if (i == HCC_ARRAY_COUNT(hcc_intrinsic_structs)) {
						HccString identifier_string = hcc_string_table_get(&c->string_table, identifier_string_id);
						hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INTRINSIC_NOT_FOUND_STRUCT, (int)identifier_string.size, identifier_string.data);
					} else {
						intrinsic_id = i + 1;
					}
				}
			}

			c->astgen.specifier_flags &= ~HCC_SPECIFIER_FLAGS_INTRINSIC;
		}

		HccDataType* insert_value_ptr;
		HccHashTable(HccStringId, HccDataType)* declarations;
		if (is_union) {
			declarations = &c->astgen.union_declarations;
		} else {
			declarations = &c->astgen.struct_declarations;
		}

		if (hcc_hash_table_find_or_insert(declarations, identifier_string_id.idx_plus_one, &insert_value_ptr)) {
			data_type = *insert_value_ptr;
			compound_data_type = hcc_compound_data_type_get(c, data_type);
		} else {
			U32 insert_idx = intrinsic_id ? intrinsic_id - 1 : hcc_stack_count(c->astgen.compound_data_types);
			*insert_value_ptr = HCC_DATA_TYPE_INIT(is_union ? HCC_DATA_TYPE_UNION : HCC_DATA_TYPE_STRUCT, insert_idx);
			goto MAKE_NEW;
		}
	} else {
MAKE_NEW: {}
		U32 compound_data_type_idx;
		if (intrinsic_id) {
			compound_data_type_idx = intrinsic_id - 1;
			compound_data_type = hcc_stack_get(c->astgen.compound_data_types, compound_data_type_idx);
		} else {
			compound_data_type_idx = hcc_stack_count(c->astgen.compound_data_types);
			compound_data_type = hcc_stack_push(c->astgen.compound_data_types);
		}

		memset(compound_data_type, 0x0, sizeof(*compound_data_type)); // TODO see if we can just make the allocators give back zeroed memory instead
		compound_data_type->identifier_token_idx = c->astgen.token_read_idx;
		compound_data_type->identifier_string_id = identifier_string_id;
		if (is_union) {
			compound_data_type->flags |= HCC_COMPOUND_DATA_TYPE_FLAGS_IS_UNION;
			data_type = HCC_DATA_TYPE_INIT(HCC_DATA_TYPE_UNION, compound_data_type_idx);
		} else {
			data_type = HCC_DATA_TYPE_INIT(HCC_DATA_TYPE_STRUCT, compound_data_type_idx);
		}
	}

	if (token != HCC_TOKEN_CURLY_OPEN) {
		if (identifier_string_id.idx_plus_one) {
			return data_type;
		}
		hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_CURLY_OPEN_COMPOUND_TYPE);
	}

	{
		hcc_astgen_validate_specifiers(c, HCC_SPECIFIER_FLAGS_ALL_NON_STRUCT_SPECIFIERS, HCC_ERROR_CODE_INVALID_SPECIFIER_FOR_STRUCT);
		if (c->astgen.specifier_flags) {
			//
			// ensure only one specifier is enabled
			if (!HCC_IS_POWER_OF_TWO_OR_ZERO(c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_ALL_STRUCT_FIELD_SPECIFIERS)) {
				hcc_astgen_error_1(c, HCC_ERROR_CODE_INVALID_SPECIFIER_CONFIG_FOR_STRUCT, hcc_token_strings[HCC_TOKEN_KEYWORD_RASTERIZER_STATE], hcc_token_strings[HCC_TOKEN_KEYWORD_FRAGMENT_STATE]);
			}

			U32 idx = HCC_LEAST_SET_BIT_IDX_U32(c->astgen.specifier_flags);
			if (is_union) {
				hcc_astgen_error_1(c, HCC_ERROR_CODE_NOT_AVAILABLE_FOR_UNION, hcc_token_strings[hcc_specifier_tokens[idx]]);
			}


			switch (idx) {
				case HCC_SPECIFIER_RASTERIZER_STATE:
					compound_data_type->kind = HCC_COMPOUND_DATA_TYPE_KIND_RASTERIZER_STATE;
					break;
				case HCC_SPECIFIER_FRAGMENT_STATE:
					compound_data_type->kind = HCC_COMPOUND_DATA_TYPE_KIND_FRAGMENT_STATE;
					break;
				case HCC_SPECIFIER_BUFFER_ELEMENT:
					compound_data_type->kind = HCC_COMPOUND_DATA_TYPE_KIND_BUFFER_ELEMENT;
					break;
				case HCC_SPECIFIER_RESOURCE_SET:
					compound_data_type->kind = HCC_COMPOUND_DATA_TYPE_KIND_RESOURCE_SET;
					compound_data_type->resource_set_slot = c->astgen.resource_set_slot;
					break;
				case HCC_SPECIFIER_RESOURCE_TABLE:
					if (c->resource_model == HCC_RESOURCE_MODEL_BINDING) {
						hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INVALID_RESOURCE_TABLE_RESOURCE_MODEL);
					}
					compound_data_type->kind = HCC_COMPOUND_DATA_TYPE_KIND_RESOURCE_TABLE;
					break;
				case HCC_SPECIFIER_RESOURCES:
					compound_data_type->kind = HCC_COMPOUND_DATA_TYPE_KIND_RESOURCES;
					break;
			}
		}

		c->astgen.specifier_flags &= ~HCC_SPECIFIER_FLAGS_ALL_STRUCT_SPECIFIERS;
	}

	if (compound_data_type->fields_count) {
		HccString data_type_name = hcc_data_type_string(c, data_type);
		c->astgen.token_read_idx -= 1;
		hcc_astgen_bail_error_2_idx(c, HCC_ERROR_CODE_REIMPLEMENTATION, compound_data_type->identifier_token_idx, (int)data_type_name.size, data_type_name.data);
	}

	token = hcc_astgen_token_next(c);
	compound_data_type->identifier_token_idx = c->astgen.token_read_idx - 2;
	compound_data_type->fields_start_idx = hcc_stack_count(c->astgen.compound_fields);

	//
	// scan ahead an count how many fields we are going to have.
	// this is because when generating fields we can recurse down
	// into generating another compound data type.
	U32 ahead_by = 0;
	U32 curly_open = 0; // to avoid counting the comma operator
	while (1) {
		HccToken token = hcc_astgen_token_peek_ahead(c, ahead_by);
		switch (token) {
			case HCC_TOKEN_EOF:
				goto END_FIELDS_COUNT;
			case HCC_TOKEN_SEMICOLON:
				if (curly_open == 0) {
					compound_data_type->fields_count += 1;
				}
				break;
			case HCC_TOKEN_CURLY_OPEN:
				curly_open += 1;
				break;
			case HCC_TOKEN_CURLY_CLOSE:
				if (curly_open == 0) {
					goto END_FIELDS_COUNT;
				}
				curly_open -= 1;
				break;
		}
		ahead_by += 1;
	}
END_FIELDS_COUNT: {}

	HccCompoundField* fields = hcc_stack_push_many(c->astgen.compound_fields, compound_data_type->fields_count);
	U32 field_idx = 0;
	bool found_position = false;
	U32 resource_constants_size = 0;
	while (1) { // for each field
		HccCompoundField* compound_field = &fields[field_idx];
		token = hcc_astgen_generate_specifiers(c);

		//
		// process the compound field specifiers
		//
		{
			if (c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_ALL_NON_STRUCT_FIELD_SPECIFIERS) {
				HccSpecifier specifier = HCC_LEAST_SET_BIT_IDX_U32(c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_ALL_NON_STRUCT_FIELD_SPECIFIERS);
				HccToken token = hcc_specifier_tokens[specifier];
				hcc_astgen_error_1(c, HCC_ERROR_CODE_INVALID_SPECIFIER_FOR_STRUCT_FIELD, hcc_token_strings[token]);
			}

			if (c->astgen.specifier_flags) {
				if (compound_data_type->kind != HCC_COMPOUND_DATA_TYPE_KIND_RASTERIZER_STATE) {
					c->astgen.token_read_idx -= 1;
					hcc_astgen_bail_error_2_idx(c, HCC_ERROR_CODE_MISSING_RASTERIZER_STATE_SPECIFIER, compound_data_type_token_idx, hcc_token_strings[HCC_TOKEN_KEYWORD_RASTERIZER_STATE], hcc_token_strings[HCC_TOKEN_KEYWORD_POSITION], hcc_token_strings[HCC_TOKEN_KEYWORD_NOINTERP]);
				}

				//
				// ensure only one specifier is enabled
				if (!HCC_IS_POWER_OF_TWO_OR_ZERO(c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_ALL_STRUCT_FIELD_SPECIFIERS)) {
					hcc_astgen_error_1(c, HCC_ERROR_CODE_INVALID_SPECIFIER_CONFIG_FOR_STRUCT_FIELD, hcc_token_strings[HCC_TOKEN_KEYWORD_POSITION], hcc_token_strings[HCC_TOKEN_KEYWORD_NOINTERP]);
				}

				switch (HCC_LEAST_SET_BIT_IDX_U32(c->astgen.specifier_flags)) {
					case HCC_SPECIFIER_POSITION:
						if (found_position) {
							hcc_astgen_error_1(c, HCC_ERROR_CODE_POSITION_ALREADY_SPECIFIED, hcc_token_strings[HCC_TOKEN_KEYWORD_POSITION]);
						}
						found_position = true;
						compound_field->rasterizer_state_field_kind = HCC_RASTERIZER_STATE_FIELD_KIND_POSITION;
						break;
					case HCC_SPECIFIER_NOINTERP: compound_field->rasterizer_state_field_kind = HCC_RASTERIZER_STATE_FIELD_KIND_NOINTERP; break;
				}

				c->astgen.specifier_flags &= ~HCC_SPECIFIER_FLAGS_ALL_STRUCT_FIELD_SPECIFIERS;
			}
		}

		U64 alignas_align = 0;
		if (token == HCC_TOKEN_KEYWORD_ALIGNAS) {
			if (compound_data_type->kind != HCC_COMPOUND_DATA_TYPE_KIND_DEFAULT) {
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_ALIGNAS_ON_SPECIAL_COMPOUND_DATA_TYPE);
			}

			token = hcc_astgen_token_next(c);
			if (token != HCC_TOKEN_PARENTHESIS_OPEN) {
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_PARENTHESIS_OPEN_ALIGNAS);
			}
			token = hcc_astgen_token_next(c);

			switch (token) {
				case HCC_TOKEN_LIT_SINT:
				case HCC_TOKEN_LIT_UINT:
				case HCC_TOKEN_LIT_SLONG:
				case HCC_TOKEN_LIT_ULONG: {
					token = hcc_astgen_token_next(c);
					HccConstantId constant_id = hcc_astgen_token_value_next(c).constant_id;
					HccConstant constant = hcc_constant_table_get(c, constant_id);

					//
					// skip the associated HccStringId kept around to turn the
					// literal back into the exact string it was parsed from.
					hcc_astgen_token_value_next(c);
					if (!hcc_constant_as_uint(c, constant, &alignas_align)) {
						hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INVALID_ALIGNAS_INT_CONSTANT);
					}
					break;
				};
				default: {
					HccDataType alignas_data_type = hcc_astgen_generate_data_type(c, HCC_ERROR_CODE_INVALID_ALIGNAS_OPERAND);
					alignas_data_type = hcc_astgen_generate_pointer_data_type_if_exists(c, alignas_data_type);
					alignas_data_type = hcc_astgen_generate_array_data_type_if_exists(c, alignas_data_type);
					U64 unused_size;
					hcc_data_type_size_align(c, alignas_data_type, &unused_size, &alignas_align);
					token = hcc_astgen_token_peek(c);
					break;
				};
			}

			if (token != HCC_TOKEN_PARENTHESIS_CLOSE) {
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_PARENTHESIS_CLOSE_ALIGNAS);
			}
			token = hcc_astgen_token_next(c);
		}

		bool requires_name;
		switch (token) {
			case HCC_TOKEN_CURLY_CLOSE:
				goto END;
			case HCC_TOKEN_KEYWORD_STRUCT:
			case HCC_TOKEN_KEYWORD_UNION: {
				compound_field->data_type = hcc_astgen_generate_compound_data_type(c);
				requires_name = false;
				break;
			};
			case HCC_TOKEN_KEYWORD_ENUM: {
				compound_field->data_type = hcc_astgen_generate_enum_data_type(c);
				requires_name = true;
				break;
			};
			default: {
				compound_field->data_type = hcc_astgen_generate_data_type(c, HCC_ERROR_CODE_COMPOUND_FIELD_INVALID_TERMINATOR);
				compound_field->data_type = hcc_astgen_generate_pointer_data_type_if_exists(c, compound_field->data_type);
				requires_name = true;
				break;
			};
		}

		HccDataType data_type = hcc_typedef_resolve_and_strip_const_volatile(c, compound_field->data_type);
		if (HCC_DATA_TYPE_IS_INTRINSIC_BASIC(data_type)) {
			HccIntrinsicType intrinsic_type = hcc_intrinsic_type_from_data_type(c, data_type);
			HCC_INTRINSIC_BASIC_TYPE_MASK_SET(&compound_data_type->has_intrinsic_basic_types, intrinsic_type);
		} else if (HCC_DATA_TYPE_IS_COMPOUND_TYPE(data_type)) {
			HccCompoundDataType* field_compound_data_type = hcc_compound_data_type_get(c, data_type);
			compound_data_type->has_intrinsic_basic_types |= field_compound_data_type->has_intrinsic_basic_types;
			if (field_compound_data_type->flags & HCC_COMPOUND_DATA_TYPE_FLAGS_HAS_RESOURCE) {
				compound_data_type->flags |= HCC_COMPOUND_DATA_TYPE_FLAGS_HAS_RESOURCE;
			}
			if (field_compound_data_type->flags & HCC_COMPOUND_DATA_TYPE_FLAGS_HAS_POINTER) {
				compound_data_type->flags |= HCC_COMPOUND_DATA_TYPE_FLAGS_HAS_POINTER;
			}
			compound_data_type->logically_addressable_elements_count += field_compound_data_type->logically_addressable_elements_count;
		} else if (HCC_DATA_TYPE_IS_RESOURCE(data_type)) {
			compound_data_type->flags |= HCC_COMPOUND_DATA_TYPE_FLAGS_HAS_RESOURCE;
			compound_data_type->logically_addressable_elements_count += 1;
		} else if (HCC_DATA_TYPE_IS_POINTER(data_type)) {
			compound_data_type->flags |= HCC_COMPOUND_DATA_TYPE_FLAGS_HAS_POINTER;
			compound_data_type->logically_addressable_elements_count += 1;
		} else if (HCC_DATA_TYPE_IS_ARRAY(data_type)) {
			HccArrayDataType* d = hcc_array_data_type_get(c, data_type);
			compound_data_type->logically_addressable_elements_count += d->logically_addressable_elements_count;
			if (d->has_resource) {
				compound_data_type->flags |= HCC_COMPOUND_DATA_TYPE_FLAGS_HAS_RESOURCE;
			}
			if (d->has_pointer) {
				compound_data_type->flags |= HCC_COMPOUND_DATA_TYPE_FLAGS_HAS_POINTER;
			}
		}
		if (compound_data_type->flags & HCC_COMPOUND_DATA_TYPE_FLAGS_IS_UNION) {
			HccString data_type_name = hcc_data_type_string(c, compound_field->data_type);
			hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_RESOURCE_IN_UNION, (int)data_type_name.size, data_type_name.data);
		}

		//
		// validate the compound data type field given what the kind of compound data type this is.
		bool is_resource_constant = false;
		switch (compound_data_type->kind) {
			case HCC_COMPOUND_DATA_TYPE_KIND_DEFAULT:
				hcc_data_type_ensure_valid_variable(c, compound_field->data_type, HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_COMPOUND_DATA_TYPE);
				break;
			case HCC_COMPOUND_DATA_TYPE_KIND_RESOURCE_TABLE:
				if (hcc_data_type_is_resource_set_pointer(c, data_type)) {
					HccString data_type_name = hcc_data_type_string(c, compound_field->data_type);
					hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_RESOURCE_TABLE, (int)data_type_name.size, data_type_name.data);
				}

				hcc_data_type_ensure_compound_type_has_no_resources(c, compound_field->data_type, HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_RESOURCE_TABLE);
				hcc_data_type_ensure_compound_type_default_kind(c, compound_field->data_type, HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_RESOURCE_TABLE);
				if (!hcc_data_type_is_resource_table_pointer(c, data_type)) {
					hcc_data_type_ensure_has_no_pointers(c, compound_field->data_type, HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_BUFFER_ELEMENT);
				}
				break;
			case HCC_COMPOUND_DATA_TYPE_KIND_RASTERIZER_STATE:
				if (!HCC_DATA_TYPE_IS_INTRINSIC(data_type)) {
					HccString data_type_name = hcc_data_type_string(c, compound_field->data_type);
					hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INVALID_DATA_TYPE_RASTERIZER_STATE, (int)data_type_name.size, data_type_name.data);
				}

				if (
					compound_field->rasterizer_state_field_kind == HCC_RASTERIZER_STATE_FIELD_KIND_POSITION &&
					data_type != HCC_DATA_TYPE_VECTOR(HCC_VEC4F32)
				) {
					HccString expected_data_type_name = hcc_data_type_string(c, HCC_DATA_TYPE_VECTOR(HCC_VEC4F32));
					HccString data_type_name = hcc_data_type_string(c, compound_field->data_type);
					hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_POSITION_MUST_BE_VEC4_F32, hcc_token_strings[HCC_TOKEN_KEYWORD_POSITION], (int)expected_data_type_name.size, expected_data_type_name.data, (int)data_type_name.size, data_type_name.data);
				}
				hcc_data_type_ensure_has_no_pointers(c, compound_field->data_type, HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_BUFFER_ELEMENT);
				break;
			case HCC_COMPOUND_DATA_TYPE_KIND_FRAGMENT_STATE:
				if (!HCC_DATA_TYPE_IS_INTRINSIC(data_type) || HCC_DATA_TYPE_IS_MATRIX(data_type)) {
					HccString data_type_name = hcc_data_type_string(c, compound_field->data_type);
					hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INVALID_DATA_TYPE_FRAGMENT_STATE, (int)data_type_name.size, data_type_name.data);
				}
				hcc_data_type_ensure_has_no_pointers(c, compound_field->data_type, HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_BUFFER_ELEMENT);
				break;
			case HCC_COMPOUND_DATA_TYPE_KIND_BUFFER_ELEMENT:
				hcc_data_type_ensure_compound_type_default_kind(c, compound_field->data_type, HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_BUFFER_ELEMENT);
				hcc_data_type_ensure_has_no_resources(c, compound_field->data_type, HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_BUFFER_ELEMENT);
				hcc_data_type_ensure_has_no_pointers(c, compound_field->data_type, HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_BUFFER_ELEMENT);
				break;
			case HCC_COMPOUND_DATA_TYPE_KIND_RESOURCE_SET:
				if (!HCC_DATA_TYPE_IS_RESOURCE(data_type)) {
					HccString data_type_name = hcc_data_type_string(c, compound_field->data_type);
					hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_RESOURCE_SET, (int)data_type_name.size, data_type_name.data);
				}
				break;
			case HCC_COMPOUND_DATA_TYPE_KIND_RESOURCES: {
				HccErrorCode error_code;
				switch (c->resource_model) {
					case HCC_RESOURCE_MODEL_BINDING:
						error_code = HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_RESOURCES_BINDING;
						if (hcc_data_type_is_resource_table_pointer(c, data_type)) {
							hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INVALID_RESOURCE_TABLE_RESOURCE_MODEL);
						}
						break;
					case HCC_RESOURCE_MODEL_BINDING_AND_BINDLESS:
						error_code = HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_RESOURCES_BINDING_AND_BINDLESS;
						if (HCC_DATA_TYPE_IS_CONSTBUFFER(data_type)) {
							hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_CONST_BUFFER_IN_RESOURCES_USING_BINDLESS);
						}
						break;
				}
				hcc_data_type_ensure_compound_type_default_kind(c, compound_field->data_type, error_code);
				hcc_data_type_ensure_compound_type_has_no_resources(c, compound_field->data_type, error_code);

				HccCompoundDataType* rs_d = hcc_data_type_get_resource_set(c, data_type);
				if (rs_d) {
					//
					// ensure the resource set slot is unique
					for (U32 other_field_idx = 0; other_field_idx < field_idx; other_field_idx += 1) {
						HccCompoundField* prev_field = &fields[other_field_idx];
						HccDataType prev_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, prev_field->data_type);
						HccCompoundDataType* prev_rs_d = hcc_data_type_get_resource_set(c, prev_data_type);
						if (!prev_rs_d) {
							continue;
						}

						if (rs_d->resource_set_slot == prev_rs_d->resource_set_slot) {
							HccString data_type_name = hcc_data_type_string(c, compound_field->data_type);
							HccString other_data_type_name = hcc_data_type_string(c, prev_field->data_type);
							hcc_astgen_bail_error_2_idx(c, HCC_ERROR_CODE_MATCHING_RESOURCE_SLOTS_IN_RESOURCES, prev_field->identifier_token_idx, (int)data_type_name.size, data_type_name.data, (int)other_data_type_name.size, other_data_type_name.data, rs_d->resource_set_slot);
						}
					}
				} else if (!hcc_data_type_has_resources(c, data_type)) {
					hcc_data_type_ensure_has_no_pointers(c, compound_field->data_type, HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_BUFFER_ELEMENT);
					is_resource_constant = true;
				}
				break;
			};
		}

		token = hcc_astgen_token_peek(c);
		if (token != HCC_TOKEN_IDENT) {
			if (requires_name) {
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_COMPOUND_FIELD_MISSING_NAME);
			}

			compound_field->identifier_token_idx = 0;
			compound_field->identifier_string_id.idx_plus_one = 0;
		} else {
			HccStringId field_identifier_string_id = hcc_astgen_token_value_next(c).string_id;
			compound_field->identifier_token_idx = c->astgen.token_read_idx;
			compound_field->identifier_string_id = field_identifier_string_id;

			token = hcc_astgen_token_next(c);
			compound_field->data_type = hcc_astgen_generate_array_data_type_if_exists(c, compound_field->data_type);
		}
		hcc_astgen_ensure_semicolon(c);
		token = hcc_astgen_token_peek(c);

		//
		// TODO: in future this will be a platform specific problem
		U64 size;
		U64 align;
		hcc_data_type_size_align(c, compound_field->data_type, &size, &align);

		if (alignas_align) {
			if (alignas_align < align) {
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_ALIGNAS_REDUCES_ALIGNMENT, alignas_align, align);
			}
			align = alignas_align;
		}

		if (is_union) {
			if (compound_data_type->size < size) {
				compound_data_type->largest_sized_field_idx = field_idx;
				compound_data_type->size = size;
			}
		} else {
			compound_data_type->size = HCC_INT_ROUND_UP_ALIGN(compound_data_type->size, align) + size;
		}
		compound_data_type->align = HCC_MAX(compound_data_type->align, align);

		if (is_resource_constant) {
			resource_constants_size = HCC_INT_ROUND_UP_ALIGN(resource_constants_size, align) + size;
			resource_constants_size = HCC_MAX(resource_constants_size, align);
		}

		field_idx += 1;
	}

END:{}
	hcc_hash_table_clear(&c->astgen.field_name_to_token_idx);
	hcc_astgen_compound_data_type_validate_field_names(c, data_type, compound_data_type);
	if (resource_constants_size > c->max_resource_constants_size) {
		hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_OVERFLOW_RESOURCE_CONSTANTS_SIZE, c->max_resource_constants_size, resource_constants_size);
	}

	if (!is_union) {
		compound_data_type->size = HCC_INT_ROUND_UP_ALIGN(compound_data_type->size, compound_data_type->align);
	}

	if (compound_data_type->kind == HCC_COMPOUND_DATA_TYPE_KIND_RASTERIZER_STATE && !found_position) {
		c->astgen.token_read_idx = compound_data_type_token_idx;
		hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_POSITION_NOT_SPECIFIED, hcc_token_strings[HCC_TOKEN_KEYWORD_POSITION]);
	}

	if (intrinsic_id) {
		intrinsic_id -= 1;
		if (intrinsic_id < HCC_STRUCT_IDX_INTRINSIC_END) {
			HccIntrinsicStruct* s = &hcc_intrinsic_structs[intrinsic_id];
			if (s->fields_count != compound_data_type->fields_count) {
				c->astgen.token_read_idx = compound_data_type_token_idx;
				HccString name = hcc_string_table_get(&c->string_table, identifier_string_id);
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INTRINSIC_INVALID_COMPOUND_STRUCT_FIELDS_COUNT, (int)name.size, name.data, s->fields_count, compound_data_type->fields_count);
			}

			for (U32 field_idx = 0; field_idx < s->fields_count; field_idx += 1) {
				HccIntrinsicStructField* isf = &s->fields[field_idx];
				HccCompoundField* f = &fields[field_idx];
				HccString expected_identifier_string = hcc_string_table_get(&c->string_table, isf->string_id);
				if (isf->data_type != f->data_type || isf->string_id.idx_plus_one != f->identifier_string_id.idx_plus_one) {
					c->astgen.token_read_idx = f->identifier_token_idx;
					HccString data_type_name = hcc_data_type_string(c, isf->data_type);
					hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INTRINSIC_INVALID_COMPOUND_STRUCT_FIELD, (int)data_type_name.size, data_type_name.data, (int)expected_identifier_string.size, expected_identifier_string.data);
				}
			}
		} else if (HCC_STRUCT_IDX_PVEC_START <= intrinsic_id && intrinsic_id < HCC_STRUCT_IDX_PVEC_END) {
			HccVec vec = intrinsic_id - HCC_STRUCT_IDX_PVEC_START;
			U32 size = hcc_packed_vec_sizes[vec];
			U32 align = hcc_packed_vec_aligns[vec];
			if (compound_data_type->size != size || compound_data_type->align != align) {
				HccString data_type_name = hcc_string_table_get(&c->string_table, identifier_string_id);
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INTRINSIC_VECTOR_INVALID_SIZE_AND_ALIGN, (int)data_type_name.size, data_type_name.data, size, align, compound_data_type->size, compound_data_type->align);
			}
		} else if (HCC_UNION_IDX_VEC_START <= intrinsic_id && intrinsic_id < HCC_UNION_IDX_VEC_END) {
			HccVec vec = intrinsic_id - HCC_UNION_IDX_VEC_START;
			U32 size_and_align = hcc_vec_size_and_aligns[vec];
			if (compound_data_type->size != size_and_align || compound_data_type->align != size_and_align) {
				HccString data_type_name = hcc_string_table_get(&c->string_table, identifier_string_id);
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INTRINSIC_VECTOR_INVALID_SIZE_AND_ALIGN, (int)data_type_name.size, data_type_name.data, size_and_align, size_and_align, compound_data_type->size, compound_data_type->align);
			}
		} else if (HCC_STRUCT_IDX_PMAT_START <= intrinsic_id && intrinsic_id < HCC_STRUCT_IDX_PMAT_END) {
			HccMat mat = intrinsic_id - HCC_STRUCT_IDX_PMAT_START;
			U32 size = hcc_packed_mat_sizes[mat];
			U32 align = hcc_packed_mat_aligns[mat];
			if (compound_data_type->size != size || compound_data_type->align != align) {
				HccString data_type_name = hcc_string_table_get(&c->string_table, identifier_string_id);
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INTRINSIC_MATRIX_INVALID_SIZE_AND_ALIGN, (int)data_type_name.size, data_type_name.data, size, align, compound_data_type->size, compound_data_type->align);
			}
		} else if (HCC_UNION_IDX_MAT_START <= intrinsic_id && intrinsic_id < HCC_UNION_IDX_MAT_END) {
			HccMat mat = intrinsic_id - HCC_UNION_IDX_MAT_START;
			U32 size = hcc_mat_sizes[mat];
			U32 align = hcc_mat_aligns[mat];
			if (compound_data_type->size != size || compound_data_type->align != align) {
				HccString data_type_name = hcc_string_table_get(&c->string_table, identifier_string_id);
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INTRINSIC_MATRIX_INVALID_SIZE_AND_ALIGN, (int)data_type_name.size, data_type_name.data, size, align, compound_data_type->size, compound_data_type->align);
			}
		}
	}

	token = hcc_astgen_token_next(c);
	hcc_astgen_data_type_found(c, data_type);
	return data_type;
}

HccToken hcc_astgen_generate_type_specifiers(HccCompiler* c, HccLocation* location, HccTypeSpecfier* type_specifiers_mut) {
	HccToken token = hcc_astgen_token_peek(c);
	while (1) {
		HccTypeSpecfier found_specifier;
		switch (token) {
			case HCC_TOKEN_KEYWORD_VOID: found_specifier = HCC_TYPE_SPECIFIER_VOID; break;
			case HCC_TOKEN_KEYWORD_BOOL: found_specifier = HCC_TYPE_SPECIFIER_BOOL; break;
			case HCC_TOKEN_KEYWORD_CHAR: found_specifier = HCC_TYPE_SPECIFIER_CHAR; break;
			case HCC_TOKEN_KEYWORD_SHORT: found_specifier = HCC_TYPE_SPECIFIER_SHORT; break;
			case HCC_TOKEN_KEYWORD_INT: found_specifier = HCC_TYPE_SPECIFIER_INT; break;
			case HCC_TOKEN_KEYWORD_LONG: found_specifier = *type_specifiers_mut & HCC_TYPE_SPECIFIER_LONG ? HCC_TYPE_SPECIFIER_LONGLONG : HCC_TYPE_SPECIFIER_LONG; break;
			case HCC_TOKEN_KEYWORD_FLOAT: found_specifier = HCC_TYPE_SPECIFIER_FLOAT; break;
			case HCC_TOKEN_KEYWORD_DOUBLE: found_specifier = HCC_TYPE_SPECIFIER_DOUBLE; break;
			case HCC_TOKEN_KEYWORD_GENERIC_FLOAT: found_specifier = HCC_TYPE_SPECIFIER_GENERIC_FLOAT; break;
			case HCC_TOKEN_KEYWORD_UNSIGNED: found_specifier = HCC_TYPE_SPECIFIER_UNSIGNED; break;
			case HCC_TOKEN_KEYWORD_SIGNED: found_specifier = HCC_TYPE_SPECIFIER_SIGNED; break;
			case HCC_TOKEN_KEYWORD_COMPLEX: found_specifier = HCC_TYPE_SPECIFIER_COMPLEX; break;
			case HCC_TOKEN_KEYWORD_ATOMIC: found_specifier = HCC_TYPE_SPECIFIER_ATOMIC; break;
			case HCC_TOKEN_KEYWORD_CONST: found_specifier = HCC_TYPE_SPECIFIER_CONST; break;
			case HCC_TOKEN_KEYWORD_VOLATILE: found_specifier = HCC_TYPE_SPECIFIER_VOLATILE; break;
			default: return token;
		}

		if (*type_specifiers_mut & found_specifier) {
			hcc_astgen_bail_error_1_merge_apply(c, HCC_ERROR_CODE_DUPLICATE_TYPE_SPECIFIER, location, hcc_type_specifier_string(found_specifier));
		}

		*type_specifiers_mut |= found_specifier;
		token = hcc_astgen_token_next(c);
	}
}

HccDataType hcc_astgen_generate_data_type(HccCompiler* c, HccErrorCode error_code) {
	HccToken token = hcc_astgen_token_peek(c);

	HccLocation* location = hcc_token_bag_location_get(c, &c->astgen.token_bag, c->astgen.token_read_idx);
	HccTypeSpecfier type_specifiers = 0;
	token = hcc_astgen_generate_type_specifiers(c, location, &type_specifiers);

	HccDataType data_type = 0;
	if (!(type_specifiers & HCC_TYPE_SPECIFIER_TYPES)) {
		switch (token) {
			case HCC_TOKEN_KEYWORD_STRUCT:
			case HCC_TOKEN_KEYWORD_UNION: {
				data_type = hcc_astgen_generate_compound_data_type(c);
				hcc_astgen_generate_type_specifiers(c, location, &type_specifiers);
				break;
			};
			case HCC_TOKEN_KEYWORD_ENUM:
				data_type = hcc_astgen_generate_enum_data_type(c);
				hcc_astgen_generate_type_specifiers(c, location, &type_specifiers);
				break;
			case HCC_TOKEN_IDENT: {
				HccDecl decl;
				HccStringId identifier_string_id = hcc_astgen_token_value_peek(c).string_id;
				if (hcc_hash_table_find(&c->astgen.global_declarations, identifier_string_id.idx_plus_one, &decl)) {
					if (HCC_DECL_IS_DATA_TYPE(decl)) {
						data_type = decl;
						hcc_astgen_generate_type_specifiers(c, location, &type_specifiers);
						hcc_astgen_token_value_next(c);
						hcc_astgen_token_next(c);
					}
				}
				break;
			};
			default:
				if (HCC_TOKEN_KEYWORD_RESOURCE_START <= token && token < HCC_TOKEN_KEYWORD_RESOURCE_END) {
					HccResourceType resource_type = token - HCC_TOKEN_KEYWORD_RESOURCE_START;
					if (hcc_resource_type_has_generic_type[resource_type]) {
						token = hcc_astgen_token_next(c);
						if (token != HCC_TOKEN_PARENTHESIS_OPEN) {
							hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_PARENTHESIS_OPEN_RESOURCE_TYPE_GENERIC, hcc_resource_type_strings[resource_type]);
						}

						HccDataType generic_data_type = hcc_astgen_generate_data_type(c, HCC_ERROR_CODE_EXPECTED_TYPE_NAME);
						HccDataType resolved_generic_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, generic_data_type);
						token = hcc_astgen_token_peek(c);
						if (token != HCC_TOKEN_PARENTHESIS_CLOSE) {
							hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_PARENTHESIS_CLOSE_RESOURCE_TYPE_GENERIC);
						}

						if (HCC_RESOURCE_TYPE_HAS_TEXEL_TYPE(resource_type)) {
							if (!HCC_DATA_TYPE_IS_INTRINSIC(resolved_generic_data_type) || HCC_DATA_TYPE_IS_MATRIX(resolved_generic_data_type)) {
								HccString data_type_name = hcc_data_type_string(c, generic_data_type);
								hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INVALID_TEXEL_TYPE, (int)data_type_name.size, data_type_name.data);
							}

							HccIntrinsicType intrinsic_type = hcc_intrinsic_type_from_data_type(c, resolved_generic_data_type);
							data_type = HCC_DATA_TYPE_INIT(HCC_DATA_TYPE_RESOURCE_START + resource_type, intrinsic_type);
						} else if (HCC_RESOURCE_TYPE_IS_SIMPLE_BUFFER(resource_type)) {
							bool is_error = !HCC_DATA_TYPE_IS_COMPOUND_TYPE(resolved_generic_data_type);
							if (!is_error) {
								HccCompoundDataType* cdt = hcc_compound_data_type_get(c, resolved_generic_data_type);
								is_error = cdt->kind != HCC_COMPOUND_DATA_TYPE_KIND_BUFFER_ELEMENT;
							}
							if (is_error) {
								HccString data_type_name = hcc_data_type_string(c, generic_data_type);
								hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INVALID_BUFFER_ELEMENT_TYPE, (int)data_type_name.size, data_type_name.data);
							}
							data_type = hcc_astgen_deduplicate_simple_buffer_data_type(c, resource_type, resolved_generic_data_type);
						} else if (resource_type == HCC_RESOURCE_TYPE_SAMPLER_STATE) {
							data_type = HCC_DATA_TYPE_RESOURCE_START + HCC_RESOURCE_TYPE_SAMPLER_STATE;
						} else {
							HCC_UNREACHABLE("unhandled resource type %u", resource_type);
						}
					} else {
						data_type = HCC_DATA_TYPE_RESOURCE_START + resource_type;
					}
				}
				break;
		}
	}

	switch (data_type & 0xff) {
		case HCC_DATA_TYPE_STRUCT:
		case HCC_DATA_TYPE_UNION:
		case HCC_DATA_TYPE_TYPEDEF:
		case HCC_DATA_TYPE_ENUM:
NON_NUM_TYPE: {}
			if (type_specifiers & HCC_TYPE_SPECIFIER_ATOMIC) {
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_ATOMIC_UNSUPPORTED_AT_THIS_TIME);
			}

			if (type_specifiers & HCC_TYPE_SPECIFIER_UNSIGNED_SIGNED) {
				hcc_astgen_bail_error_1_merge_apply(c, HCC_ERROR_CODE_UNSIGNED_OR_SIGNED_ON_NON_INT_TYPE, location);
			}

			if (type_specifiers & HCC_TYPE_SPECIFIER_COMPLEX) {
				hcc_astgen_bail_error_1_merge_apply(c, HCC_ERROR_CODE_COMPLEX_ON_NON_FLOAT_TYPE, location);
			}

			if (type_specifiers & HCC_TYPE_SPECIFIER_TYPES) {
				hcc_astgen_bail_error_1_merge_apply(c, HCC_ERROR_CODE_MULTIPLE_TYPES_SPECIFIED, location);
			}
			break;
		default: {
			if (HCC_DATA_TYPE_IS_RESOURCE(data_type)) {
				goto NON_NUM_TYPE;
			}

			if (type_specifiers == 0) {
				if (error_code != HCC_ERROR_CODE_NONE) {
					HccToken token = hcc_astgen_token_peek(c);
					hcc_astgen_bail_error_1(c, error_code, hcc_token_strings[token]);
				}
				return HCC_DATA_TYPE_INVALID;
			}

			U32 num_types = hcc_onebitscount32((type_specifiers & HCC_TYPE_SPECIFIER_TYPES) & ~HCC_TYPE_SPECIFIER_INT);
			if (
				num_types > 1 &&
				!(num_types == 2 && type_specifiers & HCC_TYPE_SPECIFIER_LONG_DOUBLE)
			) {
				hcc_astgen_bail_error_1_merge_apply(c, HCC_ERROR_CODE_MULTIPLE_TYPES_SPECIFIED, location);
			}

			if (type_specifiers & HCC_TYPE_SPECIFIER_FLOAT_TYPES) {
				if (type_specifiers & HCC_TYPE_SPECIFIER_COMPLEX) {
					hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_COMPLEX_UNSUPPORTED_AT_THIS_TIME);
				}

				if (type_specifiers & HCC_TYPE_SPECIFIER_UNSIGNED_SIGNED) {
					hcc_astgen_bail_error_1_merge_apply(c, HCC_ERROR_CODE_UNSIGNED_OR_SIGNED_ON_NON_INT_TYPE, location);
				}

				if ((type_specifiers & HCC_TYPE_SPECIFIER_LONG_DOUBLE) == HCC_TYPE_SPECIFIER_LONG_DOUBLE) {
					hcc_astgen_bail_error_1_merge_apply(c, HCC_ERROR_CODE_LONG_DOUBLE_IS_UNSUPPORTED, location);
				}

				if (type_specifiers & HCC_TYPE_SPECIFIER_FLOAT) {
					data_type = HCC_DATA_TYPE_FLOAT;
				} else if (type_specifiers & HCC_TYPE_SPECIFIER_DOUBLE) {
					data_type = HCC_DATA_TYPE_DOUBLE;
				} else if (type_specifiers & HCC_TYPE_SPECIFIER_GENERIC_FLOAT) {
					data_type = HCC_DATA_TYPE_GENERIC_FLOAT;
				} else {
					HCC_ABORT("wat?");
				}
				break;
			} else {
				if (type_specifiers & HCC_TYPE_SPECIFIER_COMPLEX) {
					hcc_astgen_bail_error_1_merge_apply(c, HCC_ERROR_CODE_COMPLEX_ON_NON_FLOAT_TYPE, location);
				}
			}

			if (type_specifiers & HCC_TYPE_SPECIFIER_VOID) {
				if (type_specifiers & HCC_TYPE_SPECIFIER_UNSIGNED_SIGNED) {
					hcc_astgen_bail_error_1_merge_apply(c, HCC_ERROR_CODE_UNSIGNED_OR_SIGNED_ON_NON_INT_TYPE, location);
				}

				data_type = HCC_DATA_TYPE_VOID;
				break;
			}

			if (type_specifiers & HCC_TYPE_SPECIFIER_BOOL) {
				if (type_specifiers & HCC_TYPE_SPECIFIER_UNSIGNED_SIGNED) {
					hcc_astgen_bail_error_1_merge_apply(c, HCC_ERROR_CODE_UNSIGNED_OR_SIGNED_ON_NON_INT_TYPE, location);
				}

				data_type = HCC_DATA_TYPE_BOOL;
				break;
			}

			if ((type_specifiers & HCC_TYPE_SPECIFIER_UNSIGNED_SIGNED) == HCC_TYPE_SPECIFIER_UNSIGNED_SIGNED) {
				hcc_astgen_bail_error_1_merge_apply(c, HCC_ERROR_CODE_UNSIGNED_AND_SIGNED, location);
			}

			if (type_specifiers & HCC_TYPE_SPECIFIER_CHAR) {
				if (type_specifiers == HCC_TYPE_SPECIFIER_CHAR) {
					data_type = HCC_DATA_TYPE_CHAR;
				} else if (type_specifiers & HCC_TYPE_SPECIFIER_UNSIGNED) {
					data_type = HCC_DATA_TYPE_UCHAR;
				} else {
					data_type = HCC_DATA_TYPE_SCHAR;
				}

				break;
			}

			if (type_specifiers & HCC_TYPE_SPECIFIER_SHORT) {
				if (type_specifiers & HCC_TYPE_SPECIFIER_UNSIGNED) {
					data_type = HCC_DATA_TYPE_USHORT;
				} else {
					data_type = HCC_DATA_TYPE_SSHORT;
				}

				break;
			}

			if (type_specifiers & HCC_TYPE_SPECIFIER_LONG) {
				if (type_specifiers & HCC_TYPE_SPECIFIER_UNSIGNED) {
					data_type = HCC_DATA_TYPE_ULONG;
				} else {
					data_type = HCC_DATA_TYPE_SLONG;
				}

				break;
			}

			if (type_specifiers & HCC_TYPE_SPECIFIER_LONGLONG) {
				if (type_specifiers & HCC_TYPE_SPECIFIER_UNSIGNED) {
					data_type = HCC_DATA_TYPE_ULONGLONG;
				} else {
					data_type = HCC_DATA_TYPE_SLONGLONG;
				}

				break;
			}

			if (type_specifiers & HCC_TYPE_SPECIFIER_INT) {
				if (type_specifiers & HCC_TYPE_SPECIFIER_UNSIGNED) {
					data_type = HCC_DATA_TYPE_UINT;
				} else {
					data_type = HCC_DATA_TYPE_SINT;
				}

				break;
			}

			break;
		};
	}

	if (type_specifiers & HCC_TYPE_SPECIFIER_CONST) {
		data_type = HCC_DATA_TYPE_CONST(data_type);
	}

	if (type_specifiers & HCC_TYPE_SPECIFIER_VOLATILE) {
		data_type = HCC_DATA_TYPE_VOLATILE(data_type);
	}

	hcc_astgen_ensure_not_unsupported_basic_type(c, location, data_type);
	return data_type;
}

HccDataType hcc_astgen_generate_pointer_data_type_if_exists(HccCompiler* c, HccDataType element_data_type) {
	HccToken token = hcc_astgen_token_peek(c);
	if (token != HCC_TOKEN_ASTERISK) {
		return element_data_type;
	}
	hcc_astgen_token_next(c);

	if (HCC_DATA_TYPE_IS_POINTER(element_data_type)) {
		hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_ONLY_SINGLE_POINTERS_ARE_SUPPORTED);
	}

	bool TODO_POINTER_TYPE_FOR_ALL_THE_OTHER_THINGS = false;

	HccDataType resolved_element_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, element_data_type);
	if (HCC_DATA_TYPE_IS_COMPOUND_TYPE(resolved_element_data_type)) {
		HccCompoundDataType* d = hcc_compound_data_type_get(c, resolved_element_data_type);
		switch (d->kind) {
			case HCC_COMPOUND_DATA_TYPE_KIND_RASTERIZER_STATE:
			case HCC_COMPOUND_DATA_TYPE_KIND_FRAGMENT_STATE:
			case HCC_COMPOUND_DATA_TYPE_KIND_RESOURCES: {
				HccString data_type_name = hcc_data_type_string(c, element_data_type);
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_POINTER_DATA_TYPE, (int)data_type_name.size, data_type_name.data);
			};
			case HCC_COMPOUND_DATA_TYPE_KIND_RESOURCE_SET:
			case HCC_COMPOUND_DATA_TYPE_KIND_RESOURCE_TABLE:
				TODO_POINTER_TYPE_FOR_ALL_THE_OTHER_THINGS = true;
				if (!HCC_DATA_TYPE_IS_CONST(element_data_type)) {

				}

				// fallthrough
			case HCC_COMPOUND_DATA_TYPE_KIND_BUFFER_ELEMENT:
				break;
		}
	}
	HCC_ASSERT(TODO_POINTER_TYPE_FOR_ALL_THE_OTHER_THINGS, "pointer type has only been implemented for ResourceSet and ResourceTable atm");

	HccDataType data_type = hcc_astgen_deduplicate_pointer_data_type(c, element_data_type);
	HccLocation* location = hcc_token_bag_location_get(c, &c->astgen.token_bag, c->astgen.token_read_idx);
	HccTypeSpecfier type_specifiers;
	token = hcc_astgen_generate_type_specifiers(c, location, &type_specifiers);
	if (type_specifiers & HCC_TYPE_SPECIFIER_CONST) {
		data_type = HCC_DATA_TYPE_CONST(data_type);
	}
	if (type_specifiers & HCC_TYPE_SPECIFIER_VOLATILE) {
		data_type = HCC_DATA_TYPE_VOLATILE(data_type);
	}
	if (type_specifiers & HCC_TYPE_SPECIFIER_ATOMIC) {
		hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_ATOMIC_UNSUPPORTED_AT_THIS_TIME);
	}

	if (type_specifiers & HCC_TYPE_SPECIFIER_UNSIGNED_SIGNED) {
		hcc_astgen_bail_error_1_merge_apply(c, HCC_ERROR_CODE_UNSIGNED_OR_SIGNED_ON_NON_INT_TYPE, location);
	}

	if (type_specifiers & HCC_TYPE_SPECIFIER_COMPLEX) {
		hcc_astgen_bail_error_1_merge_apply(c, HCC_ERROR_CODE_COMPLEX_ON_NON_FLOAT_TYPE, location);
	}

	if (type_specifiers & HCC_TYPE_SPECIFIER_TYPES) {
		hcc_astgen_bail_error_1_merge_apply(c, HCC_ERROR_CODE_MULTIPLE_TYPES_SPECIFIED, location);
	}
	return data_type;
}

HccDataType hcc_astgen_generate_array_data_type_if_exists(HccCompiler* c, HccDataType element_data_type) {
	HccToken token = hcc_astgen_token_peek(c);
	if (token != HCC_TOKEN_SQUARE_OPEN) {
		return element_data_type;
	}

	if (token == HCC_TOKEN_SQUARE_CLOSE) {
		hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_ARRAY_SIZE);
	}

	HccExpr* size_expr = hcc_astgen_generate_expr(c, 0);
	if (size_expr->type != HCC_EXPR_TYPE_CONSTANT || !HCC_DATA_TYPE_IS_INT(size_expr->data_type)) {
		hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_INTEGER_CONSTANT_ARRAY_SIZE);
	}

	HccConstantId size_constant_id = { .idx_plus_one = size_expr->constant.id };
	HccConstant constant = hcc_constant_table_get(c, size_constant_id);
	U64 size;
	if (!hcc_constant_as_uint(c, constant, &size)) {
		hcc_astgen_error_1(c, HCC_ERROR_CODE_ARRAY_SIZE_CANNOT_BE_NEGATIVE);
	}
	if (size == 0) {
		hcc_astgen_error_1(c, HCC_ERROR_CODE_ARRAY_SIZE_CANNOT_BE_ZERO);
	}

	token = hcc_astgen_token_peek(c);
	if (token != HCC_TOKEN_SQUARE_CLOSE) {
		hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_ARRAY_DECL_EXPECTED_SQUARE_BRACE_CLOSE);
	}
	token = hcc_astgen_token_next(c);

	HccDataType data_type = hcc_astgen_deduplicate_array_data_type(c, element_data_type, size_constant_id);
	data_type = hcc_astgen_generate_array_data_type_if_exists(c, data_type);
	return data_type;

}

HccDataType hcc_astgen_generate_typedef(HccCompiler* c) {
	HCC_DEBUG_ASSERT(hcc_astgen_token_peek(c) == HCC_TOKEN_KEYWORD_TYPEDEF, "internal error: expected a typedef token");
	hcc_astgen_token_consume(c, 1);

	HccSpecifierFlags intrinsic_specifier_flags = c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_INTRINSIC;

	HccDataType aliased_data_type = hcc_astgen_generate_data_type(c, HCC_ERROR_CODE_EXPECTED_TYPE_NAME);
	aliased_data_type = hcc_astgen_generate_pointer_data_type_if_exists(c, aliased_data_type);

	c->astgen.specifier_flags |= intrinsic_specifier_flags;
	return hcc_astgen_generate_typedef_with_data_type(c, aliased_data_type);
}

HccDataType hcc_astgen_generate_typedef_with_data_type(HccCompiler* c, HccDataType aliased_data_type) {
	HccToken token = hcc_astgen_token_peek(c);
	if (token != HCC_TOKEN_IDENT) {
		hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_IDENTIFIER_TYPEDEF, hcc_token_strings[token]);
	}
	HccStringId identifier_string_id = hcc_astgen_token_value_next(c).string_id;
	hcc_astgen_token_next(c);
	aliased_data_type = hcc_astgen_generate_array_data_type_if_exists(c, aliased_data_type);

	hcc_astgen_validate_specifiers(c, HCC_SPECIFIER_FLAGS_ALL_NON_TYPEDEF_SPECIFIERS, HCC_ERROR_CODE_INVALID_SPECIFIER_FOR_TYPEDEF);

	U32 intrinsic_id = 0;
	if (c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_INTRINSIC) {
		U32 i = 0;
		HccIntrinsicTypedef* it;
		for (; i < HCC_ARRAY_COUNT(hcc_intrinsic_typedefs); i += 1) {
			it = &hcc_intrinsic_typedefs[i];
			if (it->string_id.idx_plus_one == identifier_string_id.idx_plus_one) {
				break;
			}
		}

		if (i == HCC_ARRAY_COUNT(hcc_intrinsic_typedefs)) {
			HccString identifier_string = hcc_string_table_get(&c->string_table, identifier_string_id);
			hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INTRINSIC_NOT_FOUND_TYPEDEF, (int)identifier_string.size, identifier_string.data);
		}
		intrinsic_id = i + 1;

		if (it->aliased_data_type != HCC_DATA_TYPE_VOID && it->aliased_data_type != aliased_data_type) {
			HccString identifier_string = hcc_string_table_get(&c->string_table, identifier_string_id);
			HccString found_data_type_name = hcc_data_type_string(c, aliased_data_type);
			HccString data_type_name = hcc_data_type_string(c, it->aliased_data_type);
			hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INTRINSIC_INVALID_TYPEDEF,
				(int)data_type_name.size, data_type_name.data, (int)identifier_string.size, identifier_string.data,
				(int)found_data_type_name.size, found_data_type_name.data, (int)identifier_string.size, identifier_string.data
			);
		}

		c->astgen.specifier_flags &= ~HCC_SPECIFIER_FLAGS_INTRINSIC;
	}

	HccDataType* insert_value_ptr;
	HccTypedef* typedef_ = NULL;
	HccDataType data_type;
	if (hcc_hash_table_find_or_insert(&c->astgen.global_declarations, identifier_string_id.idx_plus_one, &insert_value_ptr)) {
		data_type = *insert_value_ptr;
		typedef_ = hcc_typedef_get(c, data_type);
		if (typedef_->aliased_data_type != aliased_data_type) {
			HccString data_type_name = hcc_string_table_get(&c->string_table, identifier_string_id);
			U32 other_token_idx = hcc_data_type_token_idx(c, data_type);
			hcc_astgen_bail_error_2_idx(c, HCC_ERROR_CODE_REDEFINITION_IDENTIFIER_GLOBAL, other_token_idx, (int)data_type_name.size, data_type_name.data);
		}
	} else {
		U32 typedef_idx;
		if (intrinsic_id) {
			typedef_idx = intrinsic_id - 1;
			typedef_ = &c->astgen.typedefs[typedef_idx];
		} else {
			typedef_idx = hcc_stack_count(c->astgen.typedefs);
			typedef_ = hcc_stack_push(c->astgen.typedefs);
		}

		data_type = HCC_DATA_TYPE_INIT(HCC_DATA_TYPE_TYPEDEF, typedef_idx);
		typedef_->identifier_token_idx = c->astgen.token_read_idx;
		typedef_->identifier_string_id = identifier_string_id;
		typedef_->aliased_data_type = aliased_data_type;

		hcc_astgen_data_type_found(c, data_type);
		*insert_value_ptr = data_type;
	}

	hcc_astgen_ensure_semicolon(c);
	return data_type;
}

void hcc_astgen_generate_implicit_cast(HccCompiler* c, HccDataType dst_data_type, HccExpr** expr_mut) {
	HccExpr* expr = *expr_mut;
	if (hcc_typedef_resolve_and_strip_const_volatile(c, expr->data_type) == hcc_typedef_resolve_and_strip_const_volatile(c, dst_data_type)) {
		return;
	}

	if (expr->type == HCC_EXPR_TYPE_CONSTANT) {
		hcc_astgen_eval_cast(c, expr, dst_data_type);
		return;
	}

	HccExpr* cast_expr = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_CAST);
	cast_expr->unary.expr_rel_idx = cast_expr - expr;
	cast_expr->data_type = dst_data_type;
	*expr_mut = cast_expr;
}

HccExpr* hcc_astgen_generate_unary_op(HccCompiler* c, HccExpr* inner_expr, HccUnaryOp unary_op, HccToken operator_token) {
	HccDataType resolved_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, inner_expr->data_type);

	if (!HCC_DATA_TYPE_IS_NON_VOID_BASIC(resolved_data_type)) {
		HccString data_type_name = hcc_data_type_string(c, inner_expr->data_type);
		hcc_astgen_error_1(c, HCC_ERROR_CODE_UNARY_OPERATOR_NOT_SUPPORTED, hcc_token_strings[operator_token], (int)data_type_name.size, data_type_name.data);
	}

	if (unary_op != HCC_UNARY_OP_LOGICAL_NOT) {
		if (HCC_DATA_TYPE_IS_INT(resolved_data_type)) {
			U8 rank = hcc_data_type_basic_type_ranks[resolved_data_type];
			U8 int_rank = hcc_data_type_basic_type_ranks[HCC_DATA_TYPE_SINT];
			if (rank < int_rank) {
				hcc_astgen_generate_implicit_cast(c, HCC_DATA_TYPE_SINT, &inner_expr);
			}
		}
	}

	HccExpr* expr = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_UNARY_OP_START + unary_op);
	expr->unary.expr_rel_idx = expr - inner_expr;
	expr->data_type = unary_op == HCC_UNARY_OP_LOGICAL_NOT ? HCC_DATA_TYPE_BOOL : inner_expr->data_type;

	return expr;
}

HccExpr* hcc_astgen_generate_unary_expr(HccCompiler* c) {
	HccToken token = hcc_astgen_token_peek(c);
	HccUnaryOp unary_op;
	switch (token) {
		case HCC_TOKEN_KEYWORD_TRUE:
		case HCC_TOKEN_KEYWORD_FALSE:
		case HCC_TOKEN_LIT_SINT:
		case HCC_TOKEN_LIT_SLONG:
		case HCC_TOKEN_LIT_SLONGLONG:
		case HCC_TOKEN_LIT_UINT:
		case HCC_TOKEN_LIT_ULONG:
		case HCC_TOKEN_LIT_ULONGLONG:
		case HCC_TOKEN_LIT_FLOAT:
		case HCC_TOKEN_LIT_DOUBLE: {
			HccDataType data_type;
			HccConstantId constant_id;
			switch (token) {
				case HCC_TOKEN_KEYWORD_TRUE:
					data_type = HCC_DATA_TYPE_BOOL;
					constant_id = c->basic_type_one_constant_ids[HCC_DATA_TYPE_BOOL];
					break;
				case HCC_TOKEN_KEYWORD_FALSE:
					data_type = HCC_DATA_TYPE_BOOL;
					constant_id = c->basic_type_zero_constant_ids[HCC_DATA_TYPE_BOOL];
					break;
				case HCC_TOKEN_LIT_SINT: data_type = HCC_DATA_TYPE_SINT; break;
				case HCC_TOKEN_LIT_SLONG: data_type = HCC_DATA_TYPE_SLONG; break;
				case HCC_TOKEN_LIT_SLONGLONG: data_type = HCC_DATA_TYPE_SLONGLONG; break;
				case HCC_TOKEN_LIT_UINT: data_type = HCC_DATA_TYPE_UINT; break;
				case HCC_TOKEN_LIT_ULONG: data_type = HCC_DATA_TYPE_ULONG; break;
				case HCC_TOKEN_LIT_ULONGLONG: data_type = HCC_DATA_TYPE_ULONGLONG; break;
				case HCC_TOKEN_LIT_FLOAT: data_type = HCC_DATA_TYPE_FLOAT; break;
				case HCC_TOKEN_LIT_DOUBLE: data_type = HCC_DATA_TYPE_DOUBLE; break;
			}
			if (data_type != HCC_DATA_TYPE_BOOL) {
				constant_id = hcc_astgen_token_value_next(c).constant_id;

				//
				// skip the associated HccStringId kept around to turn the
				// literal back into the exact string it was parsed from.
				hcc_astgen_token_value_next(c);
			}

			HccExpr* expr = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_CONSTANT);
			expr->constant.id = constant_id.idx_plus_one;
			expr->data_type = data_type;
			hcc_astgen_token_consume(c, 1);
			return expr;
		};
		case HCC_TOKEN_IDENT: {
			HccTokenValue identifier_value = hcc_astgen_token_value_next(c);
			hcc_astgen_token_consume(c, 1);

			U32 existing_variable_id = hcc_astgen_variable_stack_find(c, identifier_value.string_id);
			if (existing_variable_id) {
				HccVariable* variable = hcc_stack_get(c->astgen.function_params_and_variables, c->astgen.function->params_start_idx + existing_variable_id - 1);

				HccExpr* expr = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_LOCAL_VARIABLE);
				expr->variable.idx = existing_variable_id - 1;
				expr->data_type = variable->data_type;

				if (variable->is_static) {
					hcc_astgen_static_variable_usage_found(c, HCC_DECL_INIT(HCC_DECL_LOCAL_VARIABLE, existing_variable_id - 1));
				}
				return expr;
			}

			HccDecl decl;
			if (hcc_hash_table_find(&c->astgen.global_declarations, identifier_value.string_id.idx_plus_one, &decl)) {
				if (HCC_DECL_IS_DATA_TYPE(decl)) {
					HccExpr* expr = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_DATA_TYPE);
					expr->data_type = decl;
					return expr;
				} else if (HCC_DECL_IS_FUNCTION(decl)) {
					HccExpr* expr = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_FUNCTION);
					expr->function.idx = HCC_DECL_IDX(decl);
					return expr;
				} else if (HCC_DECL_IS_ENUM_VALUE(decl)) {
					HccExpr* expr = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_CONSTANT);
					HccEnumValue* enum_value = hcc_enum_value_get(c, decl);
					expr->constant.id = enum_value->value_constant_id.idx_plus_one;
					expr->data_type = HCC_DATA_TYPE_SINT;
					return expr;
				} else if (HCC_DECL_IS_GLOBAL_VARIABLE(decl)) {
					HccExpr* expr = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_GLOBAL_VARIABLE);
					HccVariable* variable = hcc_global_variable_get(c, decl);
					expr->variable.idx = HCC_DECL_IDX(decl);
					expr->data_type = variable->data_type;

					hcc_astgen_static_variable_usage_found(c, decl);
					return expr;
				} else {
					HCC_UNREACHABLE("unhandled decl type here %u", decl);
				}
			}

			HccString string = hcc_string_table_get(&c->string_table, identifier_value.string_id);
			hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_UNDECLARED_IDENTIFIER, (int)string.size, string.data);
		};
		case HCC_TOKEN_TILDE: unary_op = HCC_UNARY_OP_BIT_NOT; goto UNARY;
		case HCC_TOKEN_EXCLAMATION_MARK: unary_op = HCC_UNARY_OP_LOGICAL_NOT; goto UNARY;
		case HCC_TOKEN_PLUS: unary_op = HCC_UNARY_OP_PLUS; goto UNARY;
		case HCC_TOKEN_MINUS: unary_op = HCC_UNARY_OP_NEGATE; goto UNARY;
		case HCC_TOKEN_INCREMENT: unary_op = HCC_UNARY_OP_PRE_INCREMENT; goto UNARY;
		case HCC_TOKEN_DECREMENT: unary_op = HCC_UNARY_OP_PRE_DECREMENT; goto UNARY;
		case HCC_TOKEN_ASTERISK: unary_op = HCC_UNARY_OP_DEREF; goto UNARY;
		case HCC_TOKEN_AMPERSAND: unary_op = HCC_UNARY_OP_ADDRESS_OF; goto UNARY;
UNARY:
		{
			HccToken operator_token = token;
			hcc_astgen_token_consume(c, 1);
			U8 precedence = hcc_unary_op_precedence[unary_op];

			HccExpr* inner_expr = hcc_astgen_generate_expr(c, precedence);
			return hcc_astgen_generate_unary_op(c, inner_expr, unary_op, operator_token);
		};
		case HCC_TOKEN_PARENTHESIS_OPEN: {
			hcc_astgen_token_consume(c, 1);
			HccExpr* expr = hcc_astgen_generate_expr(c, 0);
			HccToken token = hcc_astgen_token_peek(c);
			if (token != HCC_TOKEN_PARENTHESIS_CLOSE) {
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_PARENTHESIS_CLOSE_EXPR);
			}
			token = hcc_astgen_token_next(c);

			if (expr->type == HCC_EXPR_TYPE_DATA_TYPE) {
				if (token == HCC_TOKEN_CURLY_OPEN) {
					//
					// found compound literal
					c->astgen.assign_data_type = expr->data_type;
					return hcc_astgen_generate_unary_expr(c);
				} else {
					HccExpr* right_expr = hcc_astgen_generate_expr(c, 2);
					HccDataType resolved_cast_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, expr->data_type);
					HccDataType resolved_castee_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, right_expr->data_type);
					if (resolved_cast_data_type != resolved_castee_data_type) {
						if (!HCC_DATA_TYPE_IS_BASIC(resolved_cast_data_type) || !HCC_DATA_TYPE_IS_BASIC(resolved_castee_data_type)) {
							HccString target_data_type_name = hcc_data_type_string(c, expr->data_type);
							HccString source_data_type_name = hcc_data_type_string(c, right_expr->data_type);
							hcc_astgen_error_1(c, HCC_ERROR_CODE_INVALID_CAST, (int)source_data_type_name.size, source_data_type_name.data, (int)target_data_type_name.size, target_data_type_name.data);
						}

						if (right_expr->type == HCC_EXPR_TYPE_CONSTANT) {
							hcc_astgen_eval_cast(c, right_expr, expr->data_type);
							return right_expr;
						}

						HccExpr* cast_expr = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_CAST);
						cast_expr->unary.expr_rel_idx = cast_expr - right_expr;
						cast_expr->data_type = expr->data_type;
						return cast_expr;
					}
					return right_expr;
				}
			}

			return expr;
		};
		case HCC_TOKEN_CURLY_OPEN: {
			HccDataType assign_data_type = c->astgen.assign_data_type;
			HccDataType resolved_assign_data_type = hcc_typedef_resolve_and_keep_const_volatile(c, assign_data_type);
			c->astgen.assign_data_type = HCC_DATA_TYPE_VOID;
			HccAstGenCurlyInitializer* gen = &c->astgen.curly_initializer;

			HccExpr* curly_initializer_expr = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_CURLY_INITIALIZER);
			curly_initializer_expr->data_type = assign_data_type;

			HccExpr* variable_expr;
			HccVariable* variable;
			{
				variable = hcc_stack_push(c->astgen.function_params_and_variables);
				variable->identifier_string_id.idx_plus_one = 0;
				variable->identifier_token_idx = 0;
				variable->data_type = assign_data_type;
				c->astgen.stmt_block->stmt_block.variables_count += 1;

				U32 variable_idx = c->astgen.next_var_idx;
				c->astgen.next_var_idx += 1;

				variable_expr = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_LOCAL_VARIABLE);
				variable_expr->variable.idx = variable_idx;
				variable_expr->next_expr_rel_idx = 0;
			}

			bool is_logically_addressed = hcc_data_type_has_logically_address_elements(c, resolved_assign_data_type);
			if (is_logically_addressed) {
				hcc_astgen_logical_address_declared(c, variable);
			}

			U32 nested_curlys_start_idx = hcc_stack_count(gen->nested_curlys);
			token = hcc_astgen_curly_initializer_start(c, assign_data_type, resolved_assign_data_type, variable_expr);

			while (1) {
				if (token == HCC_TOKEN_CURLY_OPEN) {
					//
					// we have just found a another curly initializer, so nest down into the next element type
					//
					hcc_astgen_curly_initializer_next_elmt(c, HCC_DATA_TYPE_VOID);
					token = hcc_astgen_curly_initializer_open(c);
					continue;
				}

				HccLocation* location = hcc_token_bag_location_get(c, &c->astgen.token_bag, c->astgen.token_read_idx);
				if (token == HCC_TOKEN_FULL_STOP || token == HCC_TOKEN_SQUARE_OPEN) {
					token = hcc_astgen_curly_initializer_next_elmt_with_designator(c);
					if (token == HCC_TOKEN_CURLY_OPEN) {
						token = hcc_astgen_curly_initializer_open(c);
						continue;
					}
				} else if (hcc_stack_get_last(gen->nested_curlys)->found_designator) {
					hcc_astgen_warn_1(c, HCC_WARN_CODE_NO_DESIGNATOR_AFTER_DESIGNATOR);
				}

				HccExpr* value_expr = hcc_astgen_generate_expr_no_comma_operator(c, 0);
				HccDataType resolved_value_data_type = hcc_typedef_resolve_and_keep_const_volatile(c, value_expr->data_type);
				bool emit_elmt_initializer = hcc_astgen_curly_initializer_next_elmt(c, resolved_value_data_type);
				if (emit_elmt_initializer) {
					U32 other_token_idx = U32_MAX;
					hcc_data_type_ensure_compatible_assignment(c, other_token_idx, c->astgen.curly_initializer.elmt_data_type, &value_expr);
					HccExpr* initializer_expr = hcc_astgen_curly_initializer_generate_designated_initializer(c);
					initializer_expr->designated_initializer.value_expr_rel_idx = initializer_expr - value_expr;

					if (is_logically_addressed) {
						HccAstGenDesignatorInitializer* designated_initializer = hcc_stack_get_last(gen->designated_initializers);
						hcc_astgen_logical_address_assigned_field(
							c,
							variable,
							hcc_stack_get(gen->designated_initializer_elmt_indices, designated_initializer->elmt_indices_start_idx),
							designated_initializer->elmt_indices_count,
							location
						);
					}
				}

				token = hcc_astgen_token_peek(c);

				//
				// loop to close curly braces and/or go to the next element.
				// loop until we find the final curly close or when we find a ',' that is _not_ followed by a '}'
				while (1) {
					bool found_one = false;
					if (token == HCC_TOKEN_CURLY_CLOSE) {
						bool is_finished = hcc_stack_count(gen->nested_curlys) == nested_curlys_start_idx + 1;
						token = hcc_astgen_curly_initializer_close(c, is_finished);
						if (is_finished) {
							goto CURLY_INITIALIZER_FINISH;
						}
						found_one = true;
					}

					if (token == HCC_TOKEN_COMMA) {
						token = hcc_astgen_token_next(c);
						if (token != HCC_TOKEN_CURLY_CLOSE) {
							break;
						}
						found_one = true;
					}

					if (!found_one) {
						hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INVALID_CURLY_INITIALIZER_LIST_END);
					}
				}
			}
CURLY_INITIALIZER_FINISH: {}
			token = hcc_astgen_token_next(c);
			curly_initializer_expr->curly_initializer.first_expr_rel_idx = gen->first_initializer_expr - curly_initializer_expr;

			//
			// if we have nested into another curly initializer expression
			// then restore the parent curly initializers state in the HccAstGenCurlyInitializer structure.
			if (nested_curlys_start_idx) {
				HccAstGenCurlyInitializerElmt* nested_elmt = hcc_stack_get_last(gen->nested_elmts);
				hcc_astgen_curly_initializer_set_composite(c, nested_elmt->data_type, nested_elmt->resolved_data_type);

				HccAstGenCurlyInitializerNested* nested = hcc_stack_get_last(gen->nested);
				gen->prev_initializer_expr = nested->prev_initializer_expr;
				gen->first_initializer_expr = nested->first_initializer_expr;
				gen->nested_elmts_start_idx = nested->nested_elmts_start_idx;
				hcc_stack_pop(gen->nested);
			}

			return curly_initializer_expr;
		};
		case HCC_TOKEN_KEYWORD_SIZEOF:
		case HCC_TOKEN_KEYWORD_ALIGNOF:
		{
			bool is_sizeof = token == HCC_TOKEN_KEYWORD_SIZEOF;
			token = hcc_astgen_token_next(c);
			bool has_parenthesis = token == HCC_TOKEN_PARENTHESIS_OPEN;
			if (has_parenthesis) {
				token = hcc_astgen_token_next(c);
			}
			HccExpr* expr = hcc_astgen_generate_unary_expr(c);
			if (has_parenthesis) {
				token = hcc_astgen_token_peek(c);
				if (token != HCC_TOKEN_PARENTHESIS_CLOSE) {
					hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_PARENTHESIS_CLOSE_EXPR);
				}
				token = hcc_astgen_token_next(c);
			} else if (expr->type == HCC_EXPR_TYPE_DATA_TYPE) {
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_SIZEALIGNOF_TYPE_OPERAND_NOT_WRAPPED, hcc_token_strings[token]);
			}

			U64 size;
			U64 align;
			hcc_data_type_size_align(c, expr->data_type, &size, &align);

			// TODO the actual type of sizeof must be a size_t aka uintptr_t
			HccBasic TODO_intptr_support_plz = hcc_basic_from_uint(c, HCC_DATA_TYPE_UINT, is_sizeof ? size : align);

			expr->type = HCC_EXPR_TYPE_CONSTANT;
			expr->constant.id = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_UINT, &TODO_intptr_support_plz).idx_plus_one;
			expr->data_type = HCC_DATA_TYPE_UINT;
			return expr;
		};

		case HCC_TOKEN_KEYWORD_VOID:
		case HCC_TOKEN_KEYWORD_BOOL:
		case HCC_TOKEN_KEYWORD_CHAR:
		case HCC_TOKEN_KEYWORD_SHORT:
		case HCC_TOKEN_KEYWORD_INT:
		case HCC_TOKEN_KEYWORD_LONG:
		case HCC_TOKEN_KEYWORD_FLOAT:
		case HCC_TOKEN_KEYWORD_DOUBLE:
		case HCC_TOKEN_KEYWORD_UNSIGNED:
		case HCC_TOKEN_KEYWORD_SIGNED:
		case HCC_TOKEN_KEYWORD_STRUCT:
		case HCC_TOKEN_KEYWORD_UNION:
		default: {
			HccDataType data_type = hcc_astgen_generate_data_type(c, HCC_ERROR_CODE_EXPECTED_EXPR);
			data_type = hcc_astgen_generate_pointer_data_type_if_exists(c, data_type);
			data_type = hcc_astgen_generate_array_data_type_if_exists(c, data_type);
			HccExpr* expr = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_DATA_TYPE);
			expr->data_type = data_type;
			return expr;
		};
	}
}

void hcc_astgen_generate_binary_op(HccCompiler* c, HccExprType* binary_op_type_out, U32* precedence_out, bool* is_assignment_out) {
	HccToken token = hcc_astgen_token_peek(c);
	*is_assignment_out = false;
	switch (token) {
		case HCC_TOKEN_INCREMENT:
			*binary_op_type_out = HCC_EXPR_TYPE_UNARY_OP(POST_INCREMENT);
			*precedence_out = 1;
			break;
		case HCC_TOKEN_DECREMENT:
			*binary_op_type_out = HCC_EXPR_TYPE_UNARY_OP(POST_DECREMENT);
			*precedence_out = 1;
			break;
		case HCC_TOKEN_FULL_STOP:
			*binary_op_type_out = HCC_EXPR_TYPE_FIELD_ACCESS;
			*precedence_out = 1;
			break;
		case HCC_TOKEN_PARENTHESIS_OPEN:
			*binary_op_type_out = HCC_EXPR_TYPE_CALL;
			*precedence_out = 1;
			break;
		case HCC_TOKEN_SQUARE_OPEN:
			*binary_op_type_out = HCC_EXPR_TYPE_ARRAY_SUBSCRIPT;
			*precedence_out = 1;
			break;
		case HCC_TOKEN_ASTERISK:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(MULTIPLY);
			*precedence_out = 3;
			break;
		case HCC_TOKEN_FORWARD_SLASH:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(DIVIDE);
			*precedence_out = 3;
			break;
		case HCC_TOKEN_PERCENT:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(MODULO);
			*precedence_out = 3;
			break;
		case HCC_TOKEN_PLUS:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(ADD);
			*precedence_out = 4;
			break;
		case HCC_TOKEN_MINUS:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(SUBTRACT);
			*precedence_out = 4;
			break;
		case HCC_TOKEN_BIT_SHIFT_LEFT:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(BIT_SHIFT_LEFT);
			*precedence_out = 5;
			break;
		case HCC_TOKEN_BIT_SHIFT_RIGHT:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(BIT_SHIFT_RIGHT);
			*precedence_out = 5;
			break;
		case HCC_TOKEN_LESS_THAN:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(LESS_THAN);
			*precedence_out = 6;
			break;
		case HCC_TOKEN_LESS_THAN_OR_EQUAL:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(LESS_THAN_OR_EQUAL);
			*precedence_out = 6;
			break;
		case HCC_TOKEN_GREATER_THAN:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(GREATER_THAN);
			*precedence_out = 6;
			break;
		case HCC_TOKEN_GREATER_THAN_OR_EQUAL:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(GREATER_THAN_OR_EQUAL);
			*precedence_out = 6;
			break;
		case HCC_TOKEN_LOGICAL_EQUAL:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(EQUAL);
			*precedence_out = 7;
			break;
		case HCC_TOKEN_LOGICAL_NOT_EQUAL:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(NOT_EQUAL);
			*precedence_out = 7;
			break;
		case HCC_TOKEN_AMPERSAND:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(BIT_AND);
			*precedence_out = 8;
			break;
		case HCC_TOKEN_CARET:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(BIT_XOR);
			*precedence_out = 9;
			break;
		case HCC_TOKEN_PIPE:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(BIT_OR);
			*precedence_out = 10;
			break;
		case HCC_TOKEN_LOGICAL_AND:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(LOGICAL_AND);
			*precedence_out = 11;
			break;
		case HCC_TOKEN_LOGICAL_OR:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(LOGICAL_OR);
			*precedence_out = 12;
			break;
		case HCC_TOKEN_QUESTION_MARK:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(TERNARY);
			*precedence_out = 13;
			break;
		case HCC_TOKEN_EQUAL:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(ASSIGN);
			*precedence_out = 14;
			*is_assignment_out = true;
			break;
		case HCC_TOKEN_ADD_ASSIGN:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(ADD);
			*precedence_out = 14;
			*is_assignment_out = true;
			break;
		case HCC_TOKEN_SUBTRACT_ASSIGN:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(SUBTRACT);
			*precedence_out = 14;
			*is_assignment_out = true;
			break;
		case HCC_TOKEN_MULTIPLY_ASSIGN:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(MULTIPLY);
			*precedence_out = 14;
			*is_assignment_out = true;
			break;
		case HCC_TOKEN_DIVIDE_ASSIGN:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(DIVIDE);
			*precedence_out = 14;
			*is_assignment_out = true;
			break;
		case HCC_TOKEN_MODULO_ASSIGN:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(MODULO);
			*precedence_out = 14;
			*is_assignment_out = true;
			break;
		case HCC_TOKEN_BIT_SHIFT_LEFT_ASSIGN:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(BIT_SHIFT_LEFT);
			*precedence_out = 14;
			*is_assignment_out = true;
			break;
		case HCC_TOKEN_BIT_SHIFT_RIGHT_ASSIGN:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(BIT_SHIFT_RIGHT);
			*precedence_out = 14;
			*is_assignment_out = true;
			break;
		case HCC_TOKEN_BIT_AND_ASSIGN:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(BIT_AND);
			*precedence_out = 14;
			*is_assignment_out = true;
			break;
		case HCC_TOKEN_BIT_XOR_ASSIGN:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(BIT_XOR);
			*precedence_out = 14;
			*is_assignment_out = true;
			break;
		case HCC_TOKEN_BIT_OR_ASSIGN:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(BIT_OR);
			*precedence_out = 14;
			*is_assignment_out = true;
			break;
		case HCC_TOKEN_COMMA:
			*binary_op_type_out = HCC_EXPR_TYPE_BINARY_OP(COMMA);
			*precedence_out = 15;
			*is_assignment_out = true;
			break;
		default:
			*binary_op_type_out = HCC_EXPR_TYPE_NONE;
			*precedence_out = 0;
			break;
	}
}

HccExpr* hcc_astgen_generate_call_expr(HccCompiler* c, HccExpr* function_expr) {
	U32 args_count = 0;
	HccExpr* call_args_expr = NULL;

	U32 function_idx = function_expr->function.idx;
	HccFunction* function = hcc_function_get(c, HCC_DECL_INIT(HCC_DECL_FUNCTION, function_idx));
	if (function->shader_stage != HCC_FUNCTION_SHADER_STAGE_NONE) {
		c->astgen.token_read_idx -= 2;
		hcc_astgen_bail_error_2_idx(c, HCC_ERROR_CODE_CANNOT_CALL_SHADER_FUNCTION, function->identifier_token_idx);
	}

	if (function_idx >= HCC_FUNCTION_IDX_USER_START) {
		*hcc_stack_push(c->astgen.function_used_function_indices) = function_idx;
	}

	HccToken token = hcc_astgen_token_peek(c);
	if (token == HCC_TOKEN_PARENTHESIS_CLOSE) {
		hcc_astgen_ensure_function_args_count(c, function, 0);
		token = hcc_astgen_token_next(c);
		call_args_expr = hcc_astgen_alloc_expr_many(c, 2);
		call_args_expr->type = HCC_EXPR_TYPE_CALL_ARG_LIST;
		call_args_expr->is_stmt_block_entry = true;
		((U8*)call_args_expr)[1] = 0;

		HccExpr* expr = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_CALL);
		expr->binary.left_expr_rel_idx = expr - function_expr;
		expr->binary.right_expr_rel_idx = expr - call_args_expr;
		expr->data_type = function->return_data_type;
		return expr;
	}

	//
	// scan ahead an count how many arguments we are going to have.
	args_count = 1;
	U32 ahead_by = 0;
	U32 parenthesis_open = 0; // to avoid counting the comma operator
	while (1) {
		HccToken token = hcc_astgen_token_peek_ahead(c, ahead_by);
		switch (token) {
			case HCC_TOKEN_EOF:
				goto END_ARG_COUNT;
			case HCC_TOKEN_COMMA:
				if (parenthesis_open == 0) {
					args_count += 1;
				}
				break;
			case HCC_TOKEN_PARENTHESIS_OPEN:
				parenthesis_open += 1;
				break;
			case HCC_TOKEN_PARENTHESIS_CLOSE:
				if (parenthesis_open == 0) {
					goto END_ARG_COUNT;
				}
				parenthesis_open -= 1;
				break;
		}
		ahead_by += 1;
	}
END_ARG_COUNT: {}

	//
	// preallocating enough room in and after the call_args_expr to store relative indices to the next args for each argument expression
	U32 required_header_expressions = ((args_count + 2) / 8) + 1;
	call_args_expr = hcc_astgen_alloc_expr_many(c, required_header_expressions);
	call_args_expr->type = HCC_EXPR_TYPE_CALL_ARG_LIST;
	call_args_expr->is_stmt_block_entry = true;
	((U8*)call_args_expr)[1] = args_count;
	U8* next_arg_expr_rel_indices = &((U8*)call_args_expr)[2];

	HccExpr* prev_arg_expr = call_args_expr;

	U32 arg_idx = 0;
	token = hcc_astgen_token_peek(c);
	HccVariable* params_array = hcc_stack_get(c->astgen.function_params_and_variables, function->params_start_idx);
	while (1) {
		HccExpr* arg_expr = hcc_astgen_generate_expr_no_comma_operator(c, 0);
		HccVariable* param = &params_array[arg_idx];
		HccDataType param_data_type = HCC_DATA_TYPE_STRIP_CONST(param->data_type);
		hcc_data_type_ensure_compatible_assignment(c, param->identifier_token_idx, param_data_type, &arg_expr);

		next_arg_expr_rel_indices[arg_idx] = arg_expr - prev_arg_expr;
		arg_idx += 1;

		token = hcc_astgen_token_peek(c);
		if (token != HCC_TOKEN_COMMA) {
			if (token != HCC_TOKEN_PARENTHESIS_CLOSE) {
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INVALID_FUNCTION_ARG_DELIMITER);
			}
			token = hcc_astgen_token_next(c);
			break;
		}
		token = hcc_astgen_token_next(c);
		prev_arg_expr = arg_expr;
	}

	HCC_DEBUG_ASSERT(arg_idx == args_count, "internal error: the scan ahead arguments count code is out of sync with the parser");

	hcc_astgen_ensure_function_args_count(c, function, arg_idx);

	HccDataType return_data_type = function->return_data_type;

	function_expr->function.idx = function_idx;

	HccExpr* expr = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_CALL);
	expr->binary.left_expr_rel_idx = expr - function_expr;
	expr->binary.right_expr_rel_idx = expr - call_args_expr;
	expr->data_type = return_data_type;
	return expr;
}

HccExpr* hcc_astgen_generate_array_subscript_expr(HccCompiler* c, HccExpr* array_expr) {
	HccExpr* index_expr = hcc_astgen_generate_expr(c, 0);
	HccToken token = hcc_astgen_token_peek(c);
	if (token != HCC_TOKEN_SQUARE_CLOSE) {
		hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_ARRAY_SUBSCRIPT_EXPECTED_SQUARE_BRACE_CLOSE);
	}
	hcc_astgen_token_next(c);

	HccArrayDataType* d = hcc_array_data_type_get(c, array_expr->data_type);

	HccExpr* expr = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_ARRAY_SUBSCRIPT);
	expr->binary.left_expr_rel_idx = expr - array_expr;
	expr->binary.right_expr_rel_idx = expr - index_expr;
	expr->data_type = d->element_data_type | (array_expr->data_type & HCC_DATA_TYPE_CONST_AND_VOLATILE_MASK);
	return expr;
}

HccExpr* hcc_astgen_generate_field_access_expr(HccCompiler* c, HccExpr* left_expr) {
	HccToken token = hcc_astgen_token_peek(c);
	if (token != HCC_TOKEN_IDENT) {
		HccString left_data_type_name = hcc_data_type_string(c, left_expr->data_type);
		U32 token_idx = hcc_data_type_token_idx(c, left_expr->data_type);
		hcc_astgen_bail_error_2_idx(c, HCC_ERROR_CODE_EXPECTED_IDENTIFIER_FIELD_ACCESS, token_idx, (int)left_data_type_name.size, left_data_type_name.data);
	}

	HccCompoundDataType* compound_data_type = hcc_compound_data_type_get(c, left_expr->data_type);

	HccStringId identifier_string_id = hcc_astgen_token_value_next(c).string_id;
	hcc_astgen_compound_data_type_find_field_by_name_checked(c, left_expr->data_type, compound_data_type, identifier_string_id);

	hcc_astgen_token_next(c);

	HccDataType mask = left_expr->data_type & HCC_DATA_TYPE_CONST_AND_VOLATILE_MASK;

	U32 fields_count = hcc_stack_count(c->astgen.compound_type_find_fields);
	for (U32 i = 0; i < fields_count; i += 1) {
		HccFieldAccess* access = hcc_stack_get(c->astgen.compound_type_find_fields, i);
		HccExpr* expr = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_FIELD_ACCESS);
		expr->binary.left_expr_rel_idx = i == 0 ? (expr - left_expr) : 1; // link to the previous expression
		expr->binary.right_expr_rel_idx = access->idx;
		expr->data_type = access->data_type | mask;
	}

	HccExpr* field_access_expr = hcc_stack_get_last(c->astgen.exprs);
	return field_access_expr;
}

HccExpr* hcc_astgen_generate_ternary_expr(HccCompiler* c, HccExpr* cond_expr) {
	hcc_astgen_data_type_ensure_is_condition(c, cond_expr->data_type);

	HccExpr* true_expr = hcc_astgen_generate_expr(c, 0);

	HccToken token = hcc_astgen_token_peek(c);
	if (token != HCC_TOKEN_COLON) {
		hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_MISSING_COLON_TERNARY_OP);
	}
	token = hcc_astgen_token_next(c);

	HccExpr* false_expr = hcc_astgen_generate_expr(c, 0);

	U32 other_token_idx = -1;
	if (!hcc_data_type_check_compatible_arithmetic(c, &true_expr, &false_expr)) {
		HccString true_data_type_name = hcc_data_type_string(c, true_expr->data_type);
		HccString false_data_type_name = hcc_data_type_string(c, false_expr->data_type);
		hcc_astgen_bail_error_2_idx(c, HCC_ERROR_CODE_TYPE_MISMATCH, other_token_idx, (int)false_data_type_name.size, false_data_type_name.data, (int)true_data_type_name.size, true_data_type_name.data);
	}

	HccExpr* expr = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_BINARY_OP(TERNARY));
	expr->ternary.cond_expr_rel_idx = expr - cond_expr;
	expr->ternary.true_expr_rel_idx = expr - true_expr;
	expr->ternary.false_expr_rel_idx = expr - false_expr;
	expr->data_type = HCC_DATA_TYPE_STRIP_CONST(true_expr->data_type);
	return expr;
}

HccExpr* hcc_astgen_generate_expr_(HccCompiler* c, U32 min_precedence, bool no_comma_operator) {
	U32 callee_token_idx = c->astgen.token_read_idx;
	HccExpr* left_expr = hcc_astgen_generate_unary_expr(c);
	if (left_expr->type == HCC_EXPR_TYPE_DATA_TYPE) {
		goto RETURN;
	}

	while (1) {
		HccExprType binary_op_type;
		U32 precedence;
		bool is_assignment;
		HccToken operator_token = hcc_astgen_token_peek(c);
		if (no_comma_operator && operator_token == HCC_TOKEN_COMMA) {
			goto RETURN;
		}

		hcc_astgen_generate_binary_op(c, &binary_op_type, &precedence, &is_assignment);
		if (binary_op_type == HCC_EXPR_TYPE_NONE || (min_precedence && min_precedence <= precedence)) {
			goto RETURN;
		}
		hcc_astgen_token_next(c);
		HccDataType resolved_left_expr_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, left_expr->data_type);

		if (binary_op_type == HCC_EXPR_TYPE_CALL) {
			if (left_expr->type != HCC_EXPR_TYPE_FUNCTION) { // TODO add function pointer support
				hcc_astgen_bail_error_2_idx(c, HCC_ERROR_CODE_PARENTHISES_USED_ON_NON_FUNCTION, callee_token_idx);
			}

			left_expr = hcc_astgen_generate_call_expr(c, left_expr);
		} else if (binary_op_type == HCC_EXPR_TYPE_ARRAY_SUBSCRIPT) {
			if (!HCC_DATA_TYPE_IS_ARRAY(resolved_left_expr_data_type)) { // TODO add pointer support
				HccString left_data_type_name = hcc_data_type_string(c, left_expr->data_type);
				hcc_astgen_bail_error_2_idx(c, HCC_ERROR_CODE_SQUARE_BRACE_USED_ON_NON_ARRAY_DATA_TYPE, callee_token_idx, (int)left_data_type_name.size, left_data_type_name.data);
			}

			left_expr = hcc_astgen_generate_array_subscript_expr(c, left_expr);
		} else if (binary_op_type == HCC_EXPR_TYPE_FIELD_ACCESS) {
			if (!HCC_DATA_TYPE_IS_COMPOUND_TYPE(resolved_left_expr_data_type)) {
				HccString left_data_type_name = hcc_data_type_string(c, left_expr->data_type);
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_FULL_STOP_USED_ON_NON_COMPOUND_DATA_TYPE, (int)left_data_type_name.size, left_data_type_name.data);
			}

			left_expr = hcc_astgen_generate_field_access_expr(c, left_expr);
		} else if (binary_op_type == HCC_EXPR_TYPE_BINARY_OP(TERNARY)) {
			left_expr = hcc_astgen_generate_ternary_expr(c, left_expr);
		} else if (binary_op_type == HCC_EXPR_TYPE_UNARY_OP(POST_INCREMENT) || binary_op_type == HCC_EXPR_TYPE_UNARY_OP(POST_DECREMENT)) {
			HccUnaryOp unary_op = binary_op_type - HCC_EXPR_TYPE_UNARY_OP_START;
			left_expr = hcc_astgen_generate_unary_op(c, left_expr, unary_op, operator_token);
		} else {
			HccLocation* location = hcc_token_bag_location_get(c, &c->astgen.token_bag, c->astgen.token_read_idx - 1);
			HccExpr* right_expr = hcc_astgen_generate_expr(c, precedence);

			U32 other_token_idx = -1;
			if (is_assignment) {
				hcc_data_type_ensure_compatible_assignment(c, other_token_idx, resolved_left_expr_data_type, &right_expr);
			} else {
				hcc_data_type_ensure_compatible_arithmetic(c, other_token_idx, &left_expr, &right_expr, operator_token);
			}

			if (binary_op_type == HCC_EXPR_TYPE_BINARY_OP(ASSIGN)) {
				if (hcc_data_type_has_logically_address_elements(c, left_expr->data_type)) {
					hcc_astgen_logical_address_assigned(c, left_expr, location);
				}
			}

			HccDataType data_type;
			if (HCC_EXPR_TYPE_BINARY_OP(EQUAL) <= binary_op_type && binary_op_type <= HCC_EXPR_TYPE_BINARY_OP(LOGICAL_OR)) {
				data_type = HCC_DATA_TYPE_BOOL;
			} else {
				data_type = left_expr->data_type; // TODO make implicit conversions explicit in the AST and make the error above work correctly
			}
			data_type = HCC_DATA_TYPE_STRIP_CONST(data_type);

			if (
				hcc_options_is_enabled(c, HCC_OPTION_CONSTANT_FOLDING) &&
				left_expr->type == HCC_EXPR_TYPE_CONSTANT &&
				right_expr->type == HCC_EXPR_TYPE_CONSTANT
			) {
				//HccConstantId left_constant_id = { .idx_plus_one = left_expr->constant.id };
				//HccConstantId right_constant_id = { .idx_plus_one = right_expr->constant.id };
				HCC_ABORT("TODO CONSTANT FOLDING");
				//
				// combine left_expr and right_expr and store them in the left_expr
				//
			} else {
				if (is_assignment && HCC_DATA_TYPE_IS_CONST(data_type)) {
					HccString left_data_type_name = hcc_data_type_string(c, data_type);
					hcc_astgen_error_1(c, HCC_ERROR_CODE_CANNOT_ASSIGN_TO_CONST, (int)left_data_type_name.size, left_data_type_name.data);
				}

				HccExpr* expr = hcc_astgen_alloc_expr(c, binary_op_type);
				expr->binary.left_expr_rel_idx = expr - left_expr;
				expr->binary.right_expr_rel_idx = right_expr ? expr - right_expr : 0;
				expr->binary.is_assignment = is_assignment;
				expr->data_type = data_type;
				left_expr = expr;
			}
		}
	}

RETURN: {}
	if (hcc_data_type_has_logically_address_elements(c, left_expr->data_type)) {
		HccLocation* location = hcc_token_bag_location_get(c, &c->astgen.token_bag, callee_token_idx);
		hcc_astgen_logical_address_used(c, left_expr, location);
	}
	return left_expr;
}

HccExpr* hcc_astgen_generate_expr(HccCompiler* c, U32 min_precedence) {
	return hcc_astgen_generate_expr_(c, min_precedence, false);
}

HccExpr* hcc_astgen_generate_expr_no_comma_operator(HccCompiler* c, U32 min_precedence) {
	return hcc_astgen_generate_expr_(c, min_precedence, true);
}

HccExpr* hcc_astgen_generate_cond_expr(HccCompiler* c) {
	HccToken token = hcc_astgen_token_peek(c);
	if (token != HCC_TOKEN_PARENTHESIS_OPEN) {
		hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_PARENTHESIS_OPEN_CONDITION_EXPR);
	}
	token = hcc_astgen_token_next(c);

	HccExpr* cond_expr = hcc_astgen_generate_expr(c, 0);
	hcc_astgen_data_type_ensure_is_condition(c, cond_expr->data_type);

	token = hcc_astgen_token_peek(c);
	if (token != HCC_TOKEN_PARENTHESIS_CLOSE) {
		hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_PARENTHESIS_CLOSE_CONDITION_EXPR);
	}
	token = hcc_astgen_token_next(c);
	return cond_expr;
}

U32 hcc_astgen_generate_variable_decl(HccCompiler* c, bool is_global, HccDataType element_data_type, HccDataType* data_type_mut, HccExpr** init_expr_out) {
	HccToken token = hcc_astgen_token_peek(c);
	HCC_DEBUG_ASSERT(token == HCC_TOKEN_IDENT, "internal error: expected '%s' at the start of generating a variable", hcc_token_strings[HCC_TOKEN_IDENT]);
	HccStringId identifier_string_id = hcc_astgen_token_value_next(c).string_id;
	U32 identifier_token_idx = c->astgen.token_read_idx;

	token = hcc_astgen_token_next(c);
	if (c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_ALL_NON_VARIABLE_SPECIFIERS) {
		HccSpecifier specifier = HCC_LEAST_SET_BIT_IDX_U32(c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_ALL_NON_VARIABLE_SPECIFIERS);
		HccToken token = hcc_specifier_tokens[specifier];
		hcc_astgen_error_1(c, HCC_ERROR_CODE_INVALID_SPECIFIER_VARIABLE_DECL, hcc_token_strings[token]);
	}

	U32 existing_variable_id = hcc_astgen_variable_stack_find(c, identifier_string_id);
	if (existing_variable_id) { // TODO: support shadowing but also warn or error about it
		U32 other_token_idx = -1;// TODO: location of existing variable
		HccString string = hcc_string_table_get(&c->string_table, identifier_string_id);
		hcc_astgen_bail_error_2_idx(c, HCC_ERROR_CODE_REDEFINITION_IDENTIFIER_LOCAL, other_token_idx, (int)string.size, string.data);
	}

	U32 variable_idx;
	HccVariable* variable;
	if (is_global) {
		variable_idx = hcc_stack_count(c->astgen.global_variables);
		variable = hcc_stack_push(c->astgen.global_variables);

		HccDecl decl = HCC_DECL_INIT(HCC_DECL_GLOBAL_VARIABLE, variable_idx);
		hcc_astgen_insert_global_declaration(c, identifier_string_id, decl);
	} else {
		variable_idx = hcc_astgen_variable_stack_add(c, identifier_string_id);
		variable = hcc_stack_push(c->astgen.function_params_and_variables);
		c->astgen.stmt_block->stmt_block.variables_count += 1;
	}
	variable->identifier_string_id = identifier_string_id;
	variable->identifier_token_idx = identifier_token_idx;
	variable->data_type = *data_type_mut;
	variable->is_static = !!(c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_STATIC) || is_global;
	variable->initializer_constant_id.idx_plus_one = 0;

	variable->data_type = hcc_astgen_generate_array_data_type_if_exists(c, variable->data_type);
	*data_type_mut = variable->data_type;
	token = hcc_astgen_token_peek(c);
	hcc_data_type_ensure_valid_variable(c, variable->data_type, HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_VARIABLE);
	bool is_logically_addressed = hcc_data_type_has_logically_address_elements(c, variable->data_type);
	if (is_logically_addressed) {
		if (is_global && !HCC_DATA_TYPE_IS_CONST(element_data_type)) {
			hcc_astgen_error_1(c, HCC_ERROR_CODE_NON_CONST_STATIC_VARIABLE_CANNOT_BE_LOGICALLY_ADDRESSED);
		}
		hcc_astgen_logical_address_declared(c, variable);
	}

	switch (token) {
		case HCC_TOKEN_SEMICOLON:
			if (init_expr_out) *init_expr_out = NULL;
			break;
		case HCC_TOKEN_EQUAL: {
			hcc_astgen_token_next(c);
			if (is_logically_addressed) {
				HccLocation* location = hcc_token_bag_location_get(c, &c->astgen.token_bag, identifier_token_idx);
				hcc_astgen_logical_address_assigned_field(c, variable, NULL, 0, location);
			}

			c->astgen.assign_data_type = variable->data_type;
			HccExpr* init_expr = hcc_astgen_generate_expr_no_comma_operator(c, 0);
			U32 other_token_idx = -1;
			HccDataType variable_data_type = HCC_DATA_TYPE_STRIP_CONST(variable->data_type);
			hcc_data_type_ensure_compatible_assignment(c, other_token_idx, variable_data_type, &init_expr);
			c->astgen.assign_data_type = HCC_DATA_TYPE_VOID;

			if (variable->is_static) {
				if (init_expr->type != HCC_EXPR_TYPE_CONSTANT) {
					hcc_astgen_error_1(c, HCC_ERROR_CODE_STATIC_VARIABLE_INITIALIZER_MUST_BE_CONSTANT);
				}
				variable->initializer_constant_id.idx_plus_one = init_expr->constant.id;
				if (init_expr_out) *init_expr_out = NULL;
			} else {
				if (init_expr_out) *init_expr_out = init_expr;
			}
			break;
		};
		case HCC_TOKEN_COMMA: break;
		default:
			hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INVALID_VARIABLE_DECL_TERMINATOR);
	}

	if (variable->is_static && variable->initializer_constant_id.idx_plus_one == 0) {
		variable->initializer_constant_id = hcc_constant_table_deduplicate_zero(c, variable->data_type);
	}

	c->astgen.specifier_flags &= ~HCC_SPECIFIER_FLAGS_ALL_VARIABLE_SPECIFIERS;
	return variable_idx;
}

HccExpr* hcc_astgen_generate_variable_decl_expr(HccCompiler* c, HccDataType data_type) {
	HccExpr* prev_expr = NULL;
	HccExpr* init_expr = NULL;
	HccToken token = hcc_astgen_token_peek(c);

	HccDataType element_data_type = hcc_data_type_strip_all_pointers(c, data_type);
	while (1) {
		U32 variable_idx = hcc_astgen_generate_variable_decl(c, false, element_data_type, &data_type, &init_expr);
		if (init_expr) {
			HccExpr* left_expr = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_LOCAL_VARIABLE);
			left_expr->variable.idx = variable_idx;
			left_expr->data_type = data_type;

			HccExpr* stmt = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_BINARY_OP(ASSIGN));
			stmt->binary.is_assignment = true;
			stmt->binary.left_expr_rel_idx = stmt - left_expr;
			stmt->binary.right_expr_rel_idx = stmt - init_expr;

			if (prev_expr) {
				HccExpr* expr = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_BINARY_OP(COMMA));
				expr->binary.is_assignment = false;
				expr->binary.left_expr_rel_idx = expr - prev_expr;
				expr->binary.right_expr_rel_idx = expr - stmt;
				prev_expr = expr;
			} else {
				prev_expr = stmt;
			}
		}

		token = hcc_astgen_token_peek(c);
		if (token != HCC_TOKEN_COMMA) {
			break;
		}
		data_type = hcc_astgen_generate_pointer_data_type_if_exists(c, element_data_type);
		token = hcc_astgen_token_next(c);
	}

	return prev_expr;
}

HccExpr* hcc_astgen_generate_stmt(HccCompiler* c) {
	HccToken token = hcc_astgen_token_peek(c);
	switch (token) {
		case HCC_TOKEN_CURLY_OPEN: {
			hcc_astgen_variable_stack_open(c);

			HccExpr* prev_stmt = NULL;

			HccExpr* stmt_block = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_STMT_BLOCK);
			U32 stmts_count = 0;

			HccExpr* prev_stmt_block = c->astgen.stmt_block;
			U32 prev_stmt_block_idx = c->astgen.stmt_block_idx;

			stmt_block->is_stmt_block_entry = true;
			stmt_block->stmt_block.variables_count = 0;
			stmt_block->stmt_block.block_idx = hcc_astgen_stmt_block_info_alloc(c, prev_stmt_block ? prev_stmt_block->stmt_block.block_idx : 0);

			c->astgen.stmt_block = stmt_block;
			c->astgen.stmt_block_idx = stmt_block->stmt_block.block_idx;

			token = hcc_astgen_token_next(c);
			while (token != HCC_TOKEN_CURLY_CLOSE) {
				HccExpr* stmt = hcc_astgen_generate_stmt(c);
				if (stmt == NULL) {
					continue;
				}
				stmt->is_stmt_block_entry = true;
				stmt_block->stmt_block.has_return_stmt |= stmt->type == HCC_EXPR_TYPE_STMT_RETURN;

				if (prev_stmt) {
					prev_stmt->next_expr_rel_idx = stmt - prev_stmt;
				} else {
					stmt_block->stmt_block.first_expr_rel_idx = stmt - stmt_block;
				}

				stmts_count += 1;
				token = hcc_astgen_token_peek(c);
				prev_stmt = stmt;
			}

			stmt_block->stmt_block.stmts_count = stmts_count;
			hcc_astgen_variable_stack_close(c);
			token = hcc_astgen_token_next(c);
			c->astgen.stmt_block = prev_stmt_block;
			c->astgen.stmt_block_idx = prev_stmt_block_idx;
			return stmt_block;
		};
		case HCC_TOKEN_KEYWORD_RETURN: {
			hcc_astgen_token_next(c);
			HccExpr* expr = hcc_astgen_generate_expr(c, 0);

			hcc_data_type_ensure_compatible_assignment(c, c->astgen.function->return_data_type_token_idx, c->astgen.function->return_data_type, &expr);

			HccExpr* stmt = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_STMT_RETURN);
			stmt->unary.expr_rel_idx = stmt - expr;
			hcc_astgen_ensure_semicolon(c);

			return stmt;
		};
		case HCC_TOKEN_KEYWORD_IF: {
			//
			// bit of a HACK, play pretend and pretend there is a block here that wrap the if statement.
			// this solves the problem of logical addresses being set inside the if condition or
			// if statements without statement blocks :/
			U32 prev_block_idx = c->astgen.stmt_block_idx;
			U32 block_idx = hcc_astgen_stmt_block_info_alloc(c, c->astgen.stmt_block_idx);
			hcc_astgen_stmt_block_found_conditional(c, block_idx);

			HccExpr* stmt = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_STMT_IF);
			hcc_astgen_token_next(c);
			HccExpr* cond_expr = hcc_astgen_generate_cond_expr(c);

			HccExpr* true_stmt = hcc_astgen_generate_stmt(c);
			true_stmt->is_stmt_block_entry = true;

			token = hcc_astgen_token_peek(c);
			HccExpr* false_stmt = NULL;
			if (token == HCC_TOKEN_KEYWORD_ELSE) {
				token = hcc_astgen_token_next(c);
				if (token != HCC_TOKEN_KEYWORD_IF && token != HCC_TOKEN_CURLY_OPEN) {
					hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INVALID_ELSE);
				}
				false_stmt = hcc_astgen_generate_stmt(c);
				false_stmt->is_stmt_block_entry = true;
			}

			stmt->type = HCC_EXPR_TYPE_STMT_IF;
			stmt->if_.cond_expr_rel_idx = cond_expr - stmt;
			stmt->if_.true_stmt_rel_idx = true_stmt - stmt;

			true_stmt->if_aux.false_stmt_rel_idx = false_stmt ? false_stmt - true_stmt : 0;
			true_stmt->if_aux.true_and_false_stmts_have_return_stmt = false;
			if (false_stmt) {
				true_stmt->if_aux.true_and_false_stmts_have_return_stmt = hcc_stmt_has_return(true_stmt) && hcc_stmt_has_return(false_stmt);
			}
			c->astgen.stmt_block_idx = prev_block_idx;
			return stmt;
		};
		case HCC_TOKEN_KEYWORD_SWITCH: {
			HccExpr* stmt = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_STMT_SWITCH);
			token = hcc_astgen_token_next(c);

			HccExpr* cond_expr;
			{
				if (token != HCC_TOKEN_PARENTHESIS_OPEN) {
					hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_PARENTHESIS_OPEN_CONDITION_EXPR);
				}
				token = hcc_astgen_token_next(c);

				cond_expr = hcc_astgen_generate_expr(c, 0);
				if (!HCC_DATA_TYPE_IS_INT(cond_expr->data_type)) {
					HccString data_type_name = hcc_data_type_string(c, cond_expr->data_type);
					hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INVALID_SWITCH_CONDITION_TYPE, (int)data_type_name.size, data_type_name.data);
				}

				token = hcc_astgen_token_peek(c);
				if (token != HCC_TOKEN_PARENTHESIS_CLOSE) {
					hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_PARENTHESIS_CLOSE_CONDITION_EXPR);
				}
				token = hcc_astgen_token_next(c);
			}
			stmt->switch_.cond_expr_rel_idx = cond_expr - stmt;

			if (token != HCC_TOKEN_CURLY_OPEN) {
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_CURLY_OPEN_SWITCH_STATEMENT);
			}

			HccSwitchState* switch_state = &c->astgen.switch_state;
			HccSwitchState prev_switch_state = *switch_state;

			switch_state->switch_stmt = stmt;
			switch_state->first_switch_case = NULL;
			switch_state->prev_switch_case = NULL;
			switch_state->default_switch_case = NULL;
			switch_state->switch_condition_type = cond_expr->data_type;
			switch_state->case_stmts_count = 0;

			HccExpr* block_stmt = hcc_astgen_generate_stmt(c);
			hcc_astgen_stmt_block_found_conditional(c, block_stmt->stmt_block.block_idx);
			block_stmt->is_stmt_block_entry = true;
			block_stmt->switch_aux.case_stmts_count = switch_state->case_stmts_count;
			block_stmt->switch_aux.first_case_expr_rel_idx = switch_state->first_switch_case ? switch_state->first_switch_case - block_stmt : 0;

			stmt->switch_.block_expr_rel_idx = block_stmt - stmt;
			stmt->alt_next_expr_rel_idx = switch_state->default_switch_case ? switch_state->default_switch_case - stmt : 0;

			*switch_state = prev_switch_state;
			return stmt;
		};
		case HCC_TOKEN_KEYWORD_DO: {
			//
			// bit of a HACK, play pretend and pretend there is a block here that wrap the if statement.
			// this solves the problem of logical addresses being set inside the while condition.
			U32 prev_block_idx = c->astgen.stmt_block_idx;
			U32 block_idx = hcc_astgen_stmt_block_info_alloc(c, c->astgen.stmt_block_idx);
			hcc_astgen_stmt_block_found_conditional(c, block_idx);

			HccExpr* stmt = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_STMT_WHILE);
			hcc_astgen_token_next(c);

			bool prev_is_in_loop = c->astgen.is_in_loop;
			c->astgen.is_in_loop = true;
			HccExpr* loop_stmt = hcc_astgen_generate_stmt(c);
			loop_stmt->is_stmt_block_entry = true;
			c->astgen.is_in_loop = prev_is_in_loop;

			token = hcc_astgen_token_peek(c);
			if (token != HCC_TOKEN_KEYWORD_WHILE) {
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_WHILE_CONDITION_FOR_DO_WHILE);
			}
			token = hcc_astgen_token_next(c);

			HccExpr* cond_expr = hcc_astgen_generate_cond_expr(c);

			stmt->while_.cond_expr_rel_idx = cond_expr - stmt;
			stmt->while_.loop_stmt_rel_idx = loop_stmt - stmt;

			hcc_astgen_ensure_semicolon(c);
			c->astgen.stmt_block_idx = prev_block_idx;
			return stmt;
		};
		case HCC_TOKEN_KEYWORD_WHILE: {
			//
			// bit of a HACK, play pretend and pretend there is a block here that wrap the if statement.
			// this solves the problem of logical addresses being set inside the while condition.
			U32 prev_block_idx = c->astgen.stmt_block_idx;
			U32 block_idx = hcc_astgen_stmt_block_info_alloc(c, c->astgen.stmt_block_idx);
			hcc_astgen_stmt_block_found_conditional(c, block_idx);

			HccExpr* stmt = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_STMT_WHILE);
			hcc_astgen_token_next(c);

			HccExpr* cond_expr = hcc_astgen_generate_cond_expr(c);

			bool prev_is_in_loop = c->astgen.is_in_loop;
			c->astgen.is_in_loop = true;
			HccExpr* loop_stmt = hcc_astgen_generate_stmt(c);
			loop_stmt->is_stmt_block_entry = true;
			c->astgen.is_in_loop = prev_is_in_loop;

			stmt->while_.cond_expr_rel_idx = cond_expr - stmt;
			stmt->while_.loop_stmt_rel_idx = loop_stmt - stmt;

			c->astgen.stmt_block_idx = prev_block_idx;
			return stmt;
		};
		case HCC_TOKEN_KEYWORD_FOR: {
			hcc_astgen_variable_stack_open(c);

			HccExpr* stmt = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_STMT_FOR);
			token = hcc_astgen_token_next(c);

			if (token != HCC_TOKEN_PARENTHESIS_OPEN) {
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_PARENTHESIS_OPEN_FOR);
			}
			token = hcc_astgen_token_next(c);

			HccExpr* init_expr = hcc_astgen_generate_expr(c, 0);
			if (init_expr->type == HCC_EXPR_TYPE_DATA_TYPE) {
				token = hcc_astgen_token_peek(c);
				if (token != HCC_TOKEN_IDENT) {
					hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_IDENTIFIER_FOR_VARIABLE_DECL);
				}
				init_expr = hcc_astgen_generate_variable_decl_expr(c, init_expr->data_type);
			}
			hcc_astgen_ensure_semicolon(c);

			HccExpr* cond_expr = hcc_astgen_generate_expr(c, 0);
			hcc_astgen_data_type_ensure_is_condition(c, cond_expr->data_type);
			hcc_astgen_ensure_semicolon(c);

			HccExpr* inc_expr = hcc_astgen_generate_expr(c, 0);

			token = hcc_astgen_token_peek(c);
			if (token != HCC_TOKEN_PARENTHESIS_CLOSE) {
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_PARENTHESIS_CLOSE_FOR);
			}
			token = hcc_astgen_token_next(c);

			bool prev_is_in_loop = c->astgen.is_in_loop;
			c->astgen.is_in_loop = true;
			HccExpr* loop_stmt = hcc_astgen_generate_stmt(c);
			loop_stmt->is_stmt_block_entry = true;
			c->astgen.is_in_loop = prev_is_in_loop;

			stmt->for_.init_expr_rel_idx = init_expr - stmt;
			stmt->for_.cond_expr_rel_idx = cond_expr - stmt;
			stmt->for_.inc_expr_rel_idx = inc_expr - stmt;
			stmt->for_.loop_stmt_rel_idx = loop_stmt - stmt;

			hcc_astgen_variable_stack_close(c);
			return stmt;
		};
		case HCC_TOKEN_KEYWORD_CASE: {
			HccSwitchState* switch_state = &c->astgen.switch_state;
			if (switch_state->switch_condition_type == HCC_DATA_TYPE_VOID) {
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_CASE_STATEMENT_OUTSIDE_OF_SWITCH);
			}

			token = hcc_astgen_token_next(c);

			HccExpr* expr = hcc_astgen_generate_expr(c, 0);
			if (expr->type != HCC_EXPR_TYPE_CONSTANT) {
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_SWITCH_CASE_VALUE_MUST_BE_A_CONSTANT);
			}
			U32 other_token_idx = -1;// TODO: the switch condition expr
			hcc_data_type_ensure_compatible_assignment(c, other_token_idx, switch_state->switch_condition_type, &expr);

			expr->type = HCC_EXPR_TYPE_STMT_CASE;
			expr->is_stmt_block_entry = true;
			expr->next_expr_rel_idx = 0;
			expr->alt_next_expr_rel_idx = 0;

			token = hcc_astgen_token_peek(c);
			if (token != HCC_TOKEN_COLON) {
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_COLON_SWITCH_CASE);
			}
			hcc_astgen_token_next(c);

			//
			// TODO: add this constant to a linear array with a location in a parallel array and check to see
			// if this constant has already been used in the switch case

			if (switch_state->prev_switch_case) {
				switch_state->prev_switch_case->alt_next_expr_rel_idx = expr - switch_state->prev_switch_case;
			} else {
				switch_state->first_switch_case = expr;
			}

			switch_state->case_stmts_count += 1;
			switch_state->prev_switch_case = expr;
			return expr;
		};
		case HCC_TOKEN_KEYWORD_DEFAULT: {
			HccSwitchState* switch_state = &c->astgen.switch_state;
			if (switch_state->switch_condition_type == HCC_DATA_TYPE_VOID) {
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_DEFAULT_STATMENT_OUTSIDE_OF_SWITCH);
			}
			if (switch_state->default_switch_case) {
				hcc_astgen_error_1(c, HCC_ERROR_CODE_DEFAULT_STATEMENT_ALREADY_DECLARED);
			}

			HccExpr* stmt = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_STMT_DEFAULT);
			stmt->is_stmt_block_entry = true;

			token = hcc_astgen_token_next(c);
			if (token != HCC_TOKEN_COLON) {
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_COLON_SWITCH_DEFAULT);
			}
			hcc_astgen_token_next(c);

			switch_state->default_switch_case = stmt;
			return stmt;
		};
		case HCC_TOKEN_KEYWORD_BREAK: {
			if (c->astgen.switch_state.switch_condition_type == HCC_DATA_TYPE_VOID && !c->astgen.is_in_loop) {
				hcc_astgen_error_1(c, HCC_ERROR_CODE_INVALID_BREAK_STATEMENT_USAGE);
			}
			HccExpr* stmt = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_STMT_BREAK);
			stmt->is_stmt_block_entry = true;
			hcc_astgen_token_next(c);
			hcc_astgen_ensure_semicolon(c);
			return stmt;
		};
		case HCC_TOKEN_KEYWORD_CONTINUE: {
			if (c->astgen.switch_state.switch_condition_type == HCC_DATA_TYPE_VOID && !c->astgen.is_in_loop) {
				hcc_astgen_error_1(c, HCC_ERROR_CODE_INVALID_CONTINUE_STATEMENT_USAGE);
			}
			HccExpr* stmt = hcc_astgen_alloc_expr(c, HCC_EXPR_TYPE_STMT_CONTINUE);
			stmt->is_stmt_block_entry = true;
			hcc_astgen_token_next(c);
			hcc_astgen_ensure_semicolon(c);
			return stmt;
		};
		case HCC_TOKEN_KEYWORD_TYPEDEF:
			hcc_astgen_generate_typedef(c);
			return NULL;
		case HCC_TOKEN_SEMICOLON:
			hcc_astgen_token_next(c);
			return NULL;
		default: {
			hcc_astgen_generate_specifiers(c);
			HccExpr* expr = hcc_astgen_generate_expr(c, 0);
			if (expr->type == HCC_EXPR_TYPE_DATA_TYPE) {
				token = hcc_astgen_token_peek(c);
				token = hcc_astgen_generate_specifiers(c);

				if (token == HCC_TOKEN_IDENT) {
					expr = hcc_astgen_generate_variable_decl_expr(c, expr->data_type);
				} else if (token == HCC_TOKEN_KEYWORD_TYPEDEF) {
					hcc_astgen_generate_typedef_with_data_type(c, expr->data_type);
				} else {
					hcc_astgen_ensure_no_unused_specifiers_identifier(c);
					expr = NULL;
				}
			} else {
				hcc_astgen_ensure_no_unused_specifiers_data_type(c);
			}

			hcc_astgen_ensure_semicolon(c);
			return expr;
		};
	}
}

void hcc_astgen_generate_function(HccCompiler* c, HccDataType return_data_type, U32 data_type_token_idx) {
	HccToken token = hcc_astgen_token_peek(c);
	HCC_DEBUG_ASSERT(token == HCC_TOKEN_IDENT, "internal error: expected '%s' at the start of generating a function", hcc_token_strings[HCC_TOKEN_IDENT]);
	HccStringId identifier_string_id = hcc_astgen_token_value_next(c).string_id;
	U32 identifier_token_idx = c->astgen.token_read_idx;
	U32 params_token_idx = c->astgen.token_read_idx;

	bool is_intrinsic = false;
	HccFunctionShaderStage shader_stage = HCC_FUNCTION_SHADER_STAGE_NONE;
	HccFunctionFlags flags = 0;
	{
		if (c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_ALL_NON_FUNCTION_SPECIFIERS) {
			HccSpecifier specifier = HCC_LEAST_SET_BIT_IDX_U32(c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_ALL_NON_FUNCTION_SPECIFIERS);
			HccToken token = hcc_specifier_tokens[specifier];
			hcc_astgen_error_1(c, HCC_ERROR_CODE_INVALID_SPECIFIER_FUNCTION_DECL, hcc_token_strings[token]);
		}

		if (!HCC_IS_POWER_OF_TWO_OR_ZERO(c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_ALL_SHADER_STAGES)) {
			hcc_astgen_error_1(c, HCC_ERROR_CODE_MULTIPLE_SHADER_STAGES_ON_FUNCTION);
		}

		if (c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_VERTEX) {
			shader_stage = HCC_FUNCTION_SHADER_STAGE_VERTEX;
		} else if (c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_FRAGMENT) {
			shader_stage = HCC_FUNCTION_SHADER_STAGE_FRAGMENT;
		}

		if (c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_STATIC) {
			flags |= HCC_FUNCTION_FLAGS_STATIC;
		}

		if (c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_INLINE) {
			flags |= HCC_FUNCTION_FLAGS_INLINE;
		}

		is_intrinsic = (bool)(c->astgen.specifier_flags & HCC_SPECIFIER_FLAGS_INTRINSIC);
		c->astgen.specifier_flags &= ~HCC_SPECIFIER_FLAGS_ALL_FUNCTION_SPECIFIERS;
	}

	U32 function_idx;
	HccFunction* function;
	bool is_new = true;
	if (is_intrinsic) {
		if (identifier_string_id.idx_plus_one < HCC_STRING_ID_FUNCTION_IDXS_START || identifier_string_id.idx_plus_one >= HCC_STRING_ID_FUNCTION_IDXS_END) {
			HccString identifier_string = hcc_string_table_get(&c->string_table, identifier_string_id);
			hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INTRINSIC_NOT_FOUND_FUNCTION, (int)identifier_string.size, identifier_string.data);
		}

		function_idx = identifier_string_id.idx_plus_one - HCC_STRING_ID_FUNCTION_IDXS_START;
	} else {
		HccDecl decl;
		if (hcc_hash_table_find(&c->astgen.global_declarations, identifier_string_id.idx_plus_one, &decl)) {
			if (!HCC_DECL_IS_FUNCTION(decl)) {
				U32 other_token_idx = hcc_decl_token_idx(c, decl);
				HccString string = hcc_string_table_get(&c->string_table, identifier_string_id);
				hcc_astgen_bail_error_2_idx(c, HCC_ERROR_CODE_REDEFINITION_IDENTIFIER_GLOBAL, other_token_idx, (int)string.size, string.data);
			}

			function_idx = HCC_DECL_IDX(decl);
			is_new = false;
		} else {
			function_idx = hcc_stack_count(c->astgen.functions);
			hcc_stack_push(c->astgen.functions);
		}
	}
	function = hcc_stack_get(c->astgen.functions, function_idx);
	c->astgen.function = function;
	function->identifier_token_idx = identifier_token_idx;
	function->shader_stage = shader_stage;
	function->flags = flags;

	token = hcc_astgen_token_next(c);

	switch (function->shader_stage) {
		case HCC_FUNCTION_SHADER_STAGE_VERTEX:
			if (!hcc_data_type_is_rasterizer_state(c, return_data_type)) {
				c->astgen.token_read_idx = data_type_token_idx;
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_VERTEX_SHADER_MUST_RETURN_RASTERIZER_STATE);
			}
			break;
		case HCC_FUNCTION_SHADER_STAGE_FRAGMENT:
			if (!hcc_data_type_is_fragment_state(c, return_data_type)) {
				c->astgen.token_read_idx = data_type_token_idx;
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_FRAGMENT_SHADER_MUST_RETURN_FRAGMENT_STATE);
			}
			break;
	}

	function->identifier_string_id = identifier_string_id;
	function->return_data_type = return_data_type;
	function->return_data_type_token_idx = data_type_token_idx;

	HccDecl decl = HCC_DECL_INIT(HCC_DECL_FUNCTION, function_idx);
	if (is_new) {
		hcc_astgen_insert_global_declaration(c, identifier_string_id, decl);
	}

	hcc_astgen_variable_stack_open(c);

	if (is_new) {
		function->params_start_idx = hcc_stack_count(c->astgen.function_params_and_variables);
		function->params_count = 0;
	}
	token = hcc_astgen_token_next(c);
	U32 param_idx = 0;
	if (token != HCC_TOKEN_PARENTHESIS_CLOSE) {
		while (1) {
			HccVariable* param;
			if (is_new) {
				param = hcc_stack_push(c->astgen.function_params_and_variables);
				function->params_count += 1;
			} else {
				param = hcc_stack_get(c->astgen.function_params_and_variables, function->params_start_idx + param_idx);
			}

			HccDataType param_data_type = hcc_astgen_generate_data_type(c, HCC_ERROR_CODE_EXPECTED_TYPE_NAME);
			param_data_type = hcc_astgen_generate_pointer_data_type_if_exists(c, param_data_type);
			hcc_data_type_ensure_valid_variable(c, param_data_type, HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_FUNCTION_PARAM);
			if (!(flags & HCC_FUNCTION_FLAGS_INLINE)) {
				hcc_data_type_ensure_has_no_resources(c, param_data_type, HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_FUNCTION_PARAM_INLINE);
				if (HCC_DATA_TYPE_IS_ARRAY(param_data_type)) {
					HccString data_type_name = hcc_data_type_string(c, param_data_type);
					hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INVALID_DATA_TYPE_FOR_FUNCTION_PARAM_INLINE, (int)data_type_name.size, data_type_name.data);
				}
			}

			token = hcc_astgen_token_peek(c);
			if (token != HCC_TOKEN_IDENT) {
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_IDENTIFIER_FUNCTION_PARAM);
			}
			HccStringId param_identifier_string_id = hcc_astgen_token_value_next(c).string_id;
			U32 param_identifier_token_idx = c->astgen.token_read_idx;
			if (function->shader_stage != HCC_FUNCTION_SHADER_STAGE_NONE && !HCC_DATA_TYPE_IS_CONST(param_data_type)) {
				HccString identifier = hcc_string_table_get(&c->string_table, param_identifier_string_id);
				HccString data_type_name = hcc_data_type_string(c, param_data_type);
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_EXPECTED_SHADER_PARAM_TO_BE_CONST, (int)data_type_name.size, data_type_name.data, (int)identifier.size, identifier.data);
			}

			U32 existing_variable_id = hcc_astgen_variable_stack_find(c, param_identifier_string_id);
			if (existing_variable_id) {
				U32 other_token_idx = -1;// TODO: location of existing variable
				HccString string = hcc_string_table_get(&c->string_table, param_identifier_string_id);
				hcc_astgen_bail_error_2_idx(c, HCC_ERROR_CODE_REDEFINITION_IDENTIFIER_FUNCTION_PARAM, other_token_idx, (int)string.size, string.data);
			}
			hcc_astgen_variable_stack_add(c, param_identifier_string_id);
			token = hcc_astgen_token_next(c);

			if (is_new) {
				param->data_type = param_data_type;
				param->identifier_string_id = param_identifier_string_id;
				param->identifier_token_idx = param_identifier_token_idx;
			} else {
				if (param->data_type != param_data_type) {
					HccString identifier_string = hcc_string_table_get(&c->string_table, identifier_string_id);
					HccString param_identifier_string = hcc_string_table_get(&c->string_table, param_identifier_string_id);
					HccString expected_data_type_name = hcc_data_type_string(c, param->data_type);
					HccString data_type_name = hcc_data_type_string(c, param_data_type);
					hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_REDEFINITION_OF_FUNCTION_MISMATCH_PARAM_DATA_TYPE, (int)identifier_string.size, identifier_string.data, (int)param_identifier_string.size, param_identifier_string.data, (int)expected_data_type_name.size, expected_data_type_name.data, (int)data_type_name.size, data_type_name.data);
				}
			}

			if (token != HCC_TOKEN_COMMA) {
				if (token != HCC_TOKEN_PARENTHESIS_CLOSE) {
					hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_FUNCTION_INVALID_TERMINATOR);
				}
				break;
			}
			token = hcc_astgen_token_next(c);

			param_idx += 1;
			if (!is_new && param_idx == function->params_count) {
				HccString identifier_string = hcc_string_table_get(&c->string_table, identifier_string_id);
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_REDEFINITION_OF_FUNCTION_TOO_MANY_PARAMETERS, (int)identifier_string.size, identifier_string.data, function->params_count);
			}
		}
	}
	token = hcc_astgen_token_next(c);

	if (!is_new && param_idx != function->params_count) {
		HccString identifier_string = hcc_string_table_get(&c->string_table, identifier_string_id);
		hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_REDEFINITION_OF_FUNCTION_NOT_ENOUGH_PARAMETERS, (int)identifier_string.size, identifier_string.data, function->params_count, param_idx);
	}

	switch (function->shader_stage) {
		case HCC_FUNCTION_SHADER_STAGE_VERTEX: {
			if (function->params_count != 1) {
				c->astgen.token_read_idx = params_token_idx;
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_FUNCTION_SHADER_PROTOTYPE_VERTEX_INVALID_COUNT);
			}

			HccVariable* vertex_input_var = hcc_stack_get(c->astgen.function_params_and_variables, function->params_start_idx + 0);
			if (hcc_typedef_resolve_and_keep_const_volatile(c, vertex_input_var->data_type) != HCC_DATA_TYPE_CONST(HCC_DATA_TYPE_INIT(HCC_DATA_TYPE_STRUCT, HCC_STRUCT_IDX_VERTEX_INPUT))) {
				c->astgen.token_read_idx = vertex_input_var->identifier_token_idx;
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_FUNCTION_SHADER_PROTOTYPE_VERTEX_INVALID_INPUT);
			}
			break;
		};
		case HCC_FUNCTION_SHADER_STAGE_FRAGMENT: {
			if (function->params_count != 2) {
				c->astgen.token_read_idx = params_token_idx;
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_FUNCTION_SHADER_PROTOTYPE_FRAGMENT_INVALID_COUNT);
			}

			HccVariable* fragment_input_var = hcc_stack_get(c->astgen.function_params_and_variables, function->params_start_idx + 0);
			if (hcc_typedef_resolve_and_keep_const_volatile(c, fragment_input_var->data_type) != HCC_DATA_TYPE_CONST(HCC_DATA_TYPE_INIT(HCC_DATA_TYPE_STRUCT, HCC_STRUCT_IDX_FRAGMENT_INPUT))) {
				c->astgen.token_read_idx = fragment_input_var->identifier_token_idx;
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_FUNCTION_SHADER_PROTOTYPE_FRAGMENT_INVALID_INPUT);
			}

			HccVariable* rasterizer_state_var = hcc_stack_get(c->astgen.function_params_and_variables, function->params_start_idx + 1);
			if (!hcc_data_type_is_rasterizer_state(c, rasterizer_state_var->data_type)) {
				c->astgen.token_read_idx = rasterizer_state_var->identifier_token_idx;
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_FUNCTION_SHADER_PROTOTYPE_FRAGMENT_INVALID_RASTERIZER_STATE);
			}

			break;
		};
	}

	if (function->shader_stage != HCC_FUNCTION_SHADER_STAGE_NONE) {
		*hcc_stack_push(c->astgen.entry_point_function_indices) = function_idx;
	}

	if (function_idx < HCC_FUNCTION_IDX_INTRINSIC_END) {
		HccIntrinsicFunction* f = &hcc_intrinsic_functions[function_idx];
		if (f->return_data_type != return_data_type) {
			HccString identifier_string = hcc_string_table_get(&c->string_table, identifier_string_id);
			HccString expected_data_type_name = hcc_data_type_string(c, f->return_data_type);
			HccString data_type_name = hcc_data_type_string(c, return_data_type);
			hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INTRINSIC_INVALID_FUNCTION_RETURN_DATA_TYPE, (int)identifier_string.size, identifier_string.data, (int)expected_data_type_name.size, expected_data_type_name.data, (int)data_type_name.size, data_type_name.data);
		}

		if (f->params_count != function->params_count) {
			HccString identifier_string = hcc_string_table_get(&c->string_table, identifier_string_id);
			hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INTRINSIC_INVALID_FUNCTION_PARAMS_COUNT, (int)identifier_string.size, identifier_string.data, f->params_count, function->params_count);
		}

		for (U32 idx = 0; idx < function->params_count; idx += 1) {
			HccDataType expected_data_type = f->param_data_types[idx];
			HccVariable* variable = &c->astgen.function_params_and_variables[function->params_start_idx + idx];
			if (variable->data_type != expected_data_type) {
				HccString identifier_string = hcc_string_table_get(&c->string_table, identifier_string_id);
				HccString expected_data_type_name = hcc_data_type_string(c, expected_data_type);
				HccString data_type_name = hcc_data_type_string(c, variable->data_type);
				hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_INTRINSIC_INVALID_FUNCTION_PARAM_DATA_TYPE, (int)identifier_string.size, identifier_string.data, idx, (int)expected_data_type_name.size, expected_data_type_name.data, (int)data_type_name.size, data_type_name.data);
			}
		}
	}

	if (token == HCC_TOKEN_SEMICOLON) {
		hcc_astgen_variable_stack_close(c);
		hcc_astgen_token_next(c);
		c->astgen.function = NULL;
		return;
	} else if (token != HCC_TOKEN_CURLY_OPEN) {
		hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_UNEXPECTED_TOKEN_FUNCTION_PROTOTYPE_END, hcc_token_strings[token]);
	}

	if (function->block_expr_id.idx_plus_one) {
		HccString identifier_string = hcc_string_table_get(&c->string_table, identifier_string_id);
		hcc_astgen_bail_error_1(c, HCC_ERROR_CODE_REDEFINITION_OF_FUNCTION_BODY_ALREADY_DECLARED, (int)identifier_string.size, identifier_string.data);
	}

	U32 ordered_data_types_start_idx = hcc_stack_count(c->astgen.ordered_data_types);
	function->used_static_variables_start_idx = hcc_stack_count(c->astgen.function_used_static_variables);
	function->used_function_indices_start_idx = hcc_stack_count(c->astgen.function_used_function_indices);
	function->unsupported_basic_types_deferred_messages_start_idx = hcc_stack_count(c->message_sys.deferred_elmts);
	function->blocks_start_idx = hcc_stack_count(c->astgen.stmt_block_infos);

	function->block_expr_id.idx_plus_one = 0;
	if (token == HCC_TOKEN_CURLY_OPEN) {
		HccExpr* expr = hcc_astgen_generate_stmt(c);
		function->block_expr_id.idx_plus_one = (expr - c->astgen.exprs) + 1;
	}

	hcc_astgen_variable_stack_close(c);
	function->variables_count = c->astgen.next_var_idx;

	function->used_static_variables_count = hcc_stack_count(c->astgen.function_used_static_variables) - function->used_static_variables_start_idx;
	function->used_function_indices_count = hcc_stack_count(c->astgen.function_used_function_indices) - function->used_function_indices_start_idx;
	function->unsupported_basic_types_deferred_messages_count = hcc_stack_count(c->message_sys.deferred_elmts) - function->unsupported_basic_types_deferred_messages_start_idx;

	//
	// TODO: these silly buggers actually shadow! so we need to store any function local declarations
	// in their own hash tables and simply nuke them at the end of a function.
	for (U32 i = ordered_data_types_start_idx; i < hcc_stack_count(c->astgen.ordered_data_types); i += 1) {
		HccDataType data_type = *hcc_stack_get(c->astgen.ordered_data_types, i);
		switch (data_type & 0xff) {
		case HCC_DATA_TYPE_STRUCT:
		case HCC_DATA_TYPE_UNION: {
			HccCompoundDataType* d = hcc_compound_data_type_get(c, data_type);
			if (d->identifier_string_id.idx_plus_one) {
				HccHashTable(HccStringId, HccDataType)* declarations;
				if (HCC_DATA_TYPE_IS_UNION(data_type)) {
					declarations = &c->astgen.union_declarations;
				} else {
					declarations = &c->astgen.struct_declarations;
				}

				HCC_DEBUG_ASSERT(hcc_hash_table_remove(declarations, d->identifier_string_id.idx_plus_one, NULL), "internal error: compound type should have existed");
			}
			break;
		};
		case HCC_DATA_TYPE_ENUM: {
			HccEnumDataType* enum_data_type = hcc_enum_data_type_get(c, data_type);
			HCC_DEBUG_ASSERT(hcc_hash_table_remove(&c->astgen.enum_declarations, enum_data_type->identifier_string_id.idx_plus_one, NULL), "internal error: enum type should have existed");
			break;
		};
		case HCC_DATA_TYPE_TYPEDEF: {
			HccTypedef* typedef_ = hcc_typedef_get(c, data_type);
			HCC_DEBUG_ASSERT(hcc_hash_table_remove(&c->astgen.global_declarations, typedef_->identifier_string_id.idx_plus_one, NULL), "internal error: typedef should have existed");
			break;
		};
		}
	}

	c->astgen.function = NULL;
}

const char* hcc_astgen_make_callstack(HccCompiler* c, U32* function_indices, U32 functions_count) {
	static char callstack[1024];
	U32 size = 0;
	for (U32 idx = 0; idx < functions_count; idx += 1) {
		HccFunction* function = hcc_stack_get(c->astgen.functions, *hcc_stack_get(function_indices, idx));
		HccString identifier_string = hcc_string_table_get(&c->string_table, function->identifier_string_id);
		size += snprintf(callstack + size, sizeof(callstack) - size, "%u: %.*s\n", idx, (int)identifier_string.size, identifier_string.data);
	}
	return callstack;
}

void hcc_astgen_recurse_used_functions(HccCompiler* c, U32 function_idx) {
	HccFunction* function = hcc_stack_get(c->astgen.functions, function_idx);
	if (function_idx >= HCC_FUNCTION_IDX_USER_START && function->block_expr_id.idx_plus_one == 0) {
		hcc_astgen_bail_error_2_idx(c, HCC_ERROR_CODE_CANNOT_CALL_UNIMPLEMENTED_FUNCTION, function->identifier_token_idx);
	}

	for (U32 idx = 0; idx < hcc_stack_count(c->astgen.recursive_function_indices_stack); idx += 1) {
		if (*hcc_stack_get(c->astgen.recursive_function_indices_stack, idx) == function_idx) {
			hcc_stack_resize(c->astgen.recursive_function_indices_stack, idx);
			*hcc_stack_push(c->astgen.recursive_function_indices_stack) = function_idx;
			const char* callstack = hcc_astgen_make_callstack(c, c->astgen.recursive_function_indices_stack, hcc_stack_count(c->astgen.recursive_function_indices_stack));
			HccString identifier_string = hcc_string_table_get(&c->string_table, function->identifier_string_id);
			U32 token_idx = HCC_MIN(c->astgen.token_read_idx, function->identifier_token_idx);
			HccLocation* location = hcc_token_bag_location_get(c, &c->astgen.token_bag, token_idx);
			hcc_error_push(c, HCC_ERROR_CODE_FUNCTION_RECURSION, location, NULL, (int)identifier_string.size, identifier_string.data, callstack);
			return;
		}
	}
	*hcc_stack_push(c->astgen.recursive_function_indices_stack) = function_idx;

	for (U32 idx = 0; idx < hcc_stack_count(c->astgen.used_function_indices); idx += 1) {
		if (*hcc_stack_get(c->astgen.used_function_indices, idx) == function_idx) {
			// function has already been added to the used array and check before
			// so nothing to do for this one!
			return;
		}
	}
	*hcc_stack_push(c->astgen.used_function_indices) = function_idx;

	if (function->unsupported_basic_types_deferred_messages_count) {
		hcc_message_copy_deferred(c, function->unsupported_basic_types_deferred_messages_start_idx, function->unsupported_basic_types_deferred_messages_count);

		//
		// return as this function with the unsupported basics types is built for
		// supporting these basic types so we in turn call many other functions that use this unsupported data type.
		// lets avoid spamming the errors to the user.
		//
		return;
	}

	for (U32 called_function_idx = 0; called_function_idx < function->used_function_indices_count; called_function_idx += 1) {
		U32 used_function_idx = *hcc_stack_get(c->astgen.function_used_function_indices, function->used_function_indices_start_idx + called_function_idx);
		hcc_astgen_recurse_used_functions(c, used_function_idx);
	}

	hcc_stack_pop(c->astgen.recursive_function_indices_stack);
}

void hcc_astgen_generate(HccCompiler* c) {
	while (1) {
		HccToken token = hcc_astgen_token_peek(c);
		token = hcc_astgen_generate_specifiers(c);

		switch (token) {
			case HCC_TOKEN_EOF:
				goto END_OF_FILE;
			case HCC_TOKEN_KEYWORD_TYPEDEF:
				hcc_astgen_generate_typedef(c);
				break;
			default: {
				HccDataType data_type = hcc_astgen_generate_data_type(c, HCC_ERROR_CODE_UNEXPECTED_TOKEN);
				data_type = hcc_astgen_generate_pointer_data_type_if_exists(c, data_type);
				U32 data_type_token_idx = c->astgen.token_read_idx;
				token = hcc_astgen_generate_specifiers(c);
				bool ensure_semi_colon = true;
				if (token == HCC_TOKEN_IDENT) {
					if (hcc_astgen_token_peek_ahead(c, 1) == HCC_TOKEN_PARENTHESIS_OPEN) {
						hcc_astgen_generate_function(c, data_type, data_type_token_idx);
						ensure_semi_colon = false;
					} else {
						HccDataType element_data_type = hcc_data_type_strip_all_pointers(c, data_type);
						while (1) {
							hcc_astgen_generate_variable_decl(c, true, element_data_type, &data_type, NULL);
							token = hcc_astgen_token_peek(c);
							if (token != HCC_TOKEN_COMMA) {
								break;
							}
							data_type = hcc_astgen_generate_pointer_data_type_if_exists(c, element_data_type);
							token = hcc_astgen_token_next(c);
						}
					}
				} else if (token == HCC_TOKEN_KEYWORD_TYPEDEF) {
					hcc_astgen_generate_typedef_with_data_type(c, data_type);
				} else {
					hcc_astgen_ensure_no_unused_specifiers_identifier(c);
				}
				if (ensure_semi_colon) {
					hcc_astgen_ensure_semicolon(c);
				}
				break;
			};
		}
	}
END_OF_FILE:{}

	U32 entry_points_count = hcc_stack_count(c->astgen.entry_point_function_indices);
	for (U32 entry_point_idx = 0; entry_point_idx < entry_points_count; entry_point_idx += 1) {
		U32 entry_point_function_idx = c->astgen.entry_point_function_indices[entry_point_idx];
		hcc_astgen_recurse_used_functions(c, entry_point_function_idx);
	}
}

void hcc_astgen_print_expr(HccCompiler* c, HccExpr* expr, U32 indent, FILE* f) {
	static char* indent_chars = "\t\t\t\t\t\t\t\t\t\t\t\t\t\t";
	fprintf(f, "%.*s", indent, indent_chars);
	if (!expr->is_stmt_block_entry) {
		HccString data_type_name = hcc_data_type_string(c, expr->data_type);
		fprintf(f, "(%.*s)", (int)data_type_name.size, data_type_name.data);
	}

	const char* expr_name;
	switch (expr->type) {
		case HCC_EXPR_TYPE_CONSTANT: expr_name = "EXPR_CONSTANT"; goto CONSTANT;
		case HCC_EXPR_TYPE_STMT_CASE: expr_name = "STMT_CASE"; goto CONSTANT;
CONSTANT: {
			fprintf(f, "%s ", expr_name);
			HccConstantId constant_id = { .idx_plus_one = expr->constant.id };
			hcc_constant_print(c, constant_id, stdout);
			break;
		};
		case HCC_EXPR_TYPE_STMT_BLOCK: {
			U32 stmts_count = expr->stmt_block.stmts_count;
			fprintf(f, "STMT_BLOCK[%u] {\n", stmts_count);
			HccExpr* stmt = &expr[expr->stmt_block.first_expr_rel_idx];
			U32 variables_count = expr->stmt_block.variables_count;
			for (U32 i = 0; i < variables_count; i += 1) {
				char buf[1024] = "<CURLY_INITIALIZER_RESULT>";
				U32 variable_idx = c->astgen.print_variable_base_idx + i;
				HccVariable* variable = hcc_stack_get(c->astgen.function_params_and_variables, c->astgen.function->params_start_idx + variable_idx);
				if (variable->identifier_string_id.idx_plus_one) {
					hcc_variable_to_string(c, variable, buf, sizeof(buf), false);
				}
				fprintf(f, "%.*sLOCAL_VARIABLE(#%u): %s", indent + 1, indent_chars, variable_idx, buf);
				if (variable->initializer_constant_id.idx_plus_one) {
					fprintf(f, " = ");
					hcc_constant_print(c, variable->initializer_constant_id, f);
				}
				fprintf(f, "\n");
			}
			c->astgen.print_variable_base_idx += variables_count;

			for (U32 i = 0; i < stmts_count; i += 1) {
				hcc_astgen_print_expr(c, stmt, indent + 1, f);
				stmt = &stmt[stmt->next_expr_rel_idx];
			}
			fprintf(f, "%.*s}", indent, indent_chars);
			break;
		};
		case HCC_EXPR_TYPE_FUNCTION: {
			HccFunction* function = hcc_stack_get(c->astgen.functions, expr->function.idx);
			char buf[1024];
			hcc_function_to_string(c, function, buf, sizeof(buf), false);
			fprintf(f, "EXPR_FUNCTION Function(#%u): %s", expr->function.idx, buf);
			break;
		};
		case HCC_EXPR_TYPE_STMT_RETURN: expr_name = "STMT_RETURN"; goto UNARY;
		case HCC_EXPR_TYPE_UNARY_OP(LOGICAL_NOT): expr_name = "EXPR_LOGICAL_NOT"; goto UNARY;
		case HCC_EXPR_TYPE_UNARY_OP(BIT_NOT): expr_name = "EXPR_BIT_NOT"; goto UNARY;
		case HCC_EXPR_TYPE_UNARY_OP(PLUS): expr_name = "EXPR_PLUS"; goto UNARY;
		case HCC_EXPR_TYPE_UNARY_OP(NEGATE): expr_name = "EXPR_NEGATE"; goto UNARY;
		case HCC_EXPR_TYPE_UNARY_OP(PRE_INCREMENT): expr_name = "EXPR_PRE_INCREMENT"; goto UNARY;
		case HCC_EXPR_TYPE_UNARY_OP(PRE_DECREMENT): expr_name = "EXPR_PRE_DECREMENT"; goto UNARY;
		case HCC_EXPR_TYPE_UNARY_OP(POST_INCREMENT): expr_name = "EXPR_POST_INCREMENT"; goto UNARY;
		case HCC_EXPR_TYPE_UNARY_OP(POST_DECREMENT): expr_name = "EXPR_POST_DECREMENT"; goto UNARY;
UNARY:
		{
			fprintf(f, "%s: {\n", expr_name);
			HccExpr* unary_expr = expr - expr->unary.expr_rel_idx;
			hcc_astgen_print_expr(c, unary_expr, indent + 1, f);
			fprintf(f, "%.*s}", indent, indent_chars);
			break;
		};
		case HCC_EXPR_TYPE_CAST: {
			fprintf(f, "EXPR_CAST: {\n");
			HccExpr* unary_expr = expr - expr->unary.expr_rel_idx;
			hcc_astgen_print_expr(c, unary_expr, indent + 1, f);
			fprintf(f, "%.*s}", indent, indent_chars);
			break;
		};
		case HCC_EXPR_TYPE_STMT_IF: {
			fprintf(f, "%s: {\n", "STMT_IF");

			HccExpr* cond_expr = &expr[expr->if_.cond_expr_rel_idx];
			fprintf(f, "%.*sCONDITION_EXPR:\n", indent + 1, indent_chars);
			hcc_astgen_print_expr(c, cond_expr, indent + 2, f);

			HccExpr* true_stmt = &expr[expr->if_.true_stmt_rel_idx];
			fprintf(f, "%.*sTRUE_STMT:\n", indent + 1, indent_chars);
			hcc_astgen_print_expr(c, true_stmt, indent + 2, f);

			if (true_stmt->if_aux.false_stmt_rel_idx) {
				HccExpr* false_stmt = &true_stmt[true_stmt->if_aux.false_stmt_rel_idx];
				fprintf(f, "%.*sFALSE_STMT:\n", indent + 1, indent_chars);
				hcc_astgen_print_expr(c, false_stmt, indent + 2, f);
			}

			fprintf(f, "%.*s}", indent, indent_chars);
			break;
		};
		case HCC_EXPR_TYPE_STMT_SWITCH: {
			fprintf(f, "%s: {\n", "STMT_SWITCH");

			HccExpr* block_expr = &expr[expr->switch_.block_expr_rel_idx];
			hcc_astgen_print_expr(c, block_expr, indent + 1, f);

			fprintf(f, "%.*s}", indent, indent_chars);
			break;
		};
		case HCC_EXPR_TYPE_STMT_WHILE: {
			fprintf(f, "%s: {\n", expr->while_.cond_expr_rel_idx > expr->while_.loop_stmt_rel_idx ? "STMT_DO_WHILE" : "STMT_WHILE");

			HccExpr* cond_expr = &expr[expr->while_.cond_expr_rel_idx];
			fprintf(f, "%.*sCONDITION_EXPR:\n", indent + 1, indent_chars);
			hcc_astgen_print_expr(c, cond_expr, indent + 2, f);

			HccExpr* loop_stmt = &expr[expr->while_.loop_stmt_rel_idx];
			fprintf(f, "%.*sLOOP_STMT:\n", indent + 1, indent_chars);
			hcc_astgen_print_expr(c, loop_stmt, indent + 2, f);

			fprintf(f, "%.*s}", indent, indent_chars);
			break;
		};
		case HCC_EXPR_TYPE_STMT_FOR: {
			fprintf(f, "%s: {\n", "STMT_FOR");

			HccExpr* init_expr = &expr[expr->for_.init_expr_rel_idx];
			fprintf(f, "%.*sINIT_EXPR:\n", indent + 1, indent_chars);
			hcc_astgen_print_expr(c, init_expr, indent + 2, f);

			HccExpr* cond_expr = &expr[expr->for_.cond_expr_rel_idx];
			fprintf(f, "%.*sCONDITION_EXPR:\n", indent + 1, indent_chars);
			hcc_astgen_print_expr(c, cond_expr, indent + 2, f);

			HccExpr* inc_expr = &expr[expr->for_.inc_expr_rel_idx];
			fprintf(f, "%.*sINCREMENT_EXPR:\n", indent + 1, indent_chars);
			hcc_astgen_print_expr(c, inc_expr, indent + 2, f);

			HccExpr* loop_stmt = &expr[expr->for_.loop_stmt_rel_idx];
			fprintf(f, "%.*sLOOP_STMT:\n", indent + 1, indent_chars);
			hcc_astgen_print_expr(c, loop_stmt, indent + 2, f);

			fprintf(f, "%.*s}", indent, indent_chars);
			break;
		};
		case HCC_EXPR_TYPE_STMT_DEFAULT: {
			fprintf(f, "%s:\n", "STMT_DEFAULT");
			break;
		};
		case HCC_EXPR_TYPE_STMT_BREAK: {
			fprintf(f, "%s:\n", "STMT_BREAK");
			break;
		};
		case HCC_EXPR_TYPE_STMT_CONTINUE: {
			fprintf(f, "%s:\n", "STMT_CONTINUE");
			break;
		};
		case HCC_EXPR_TYPE_BINARY_OP(ASSIGN): expr_name = "ASSIGN"; goto BINARY;
		case HCC_EXPR_TYPE_BINARY_OP(ADD): expr_name = "ADD"; goto BINARY;
		case HCC_EXPR_TYPE_BINARY_OP(SUBTRACT): expr_name = "SUBTRACT"; goto BINARY;
		case HCC_EXPR_TYPE_BINARY_OP(MULTIPLY): expr_name = "MULTIPLY"; goto BINARY;
		case HCC_EXPR_TYPE_BINARY_OP(DIVIDE): expr_name = "DIVIDE"; goto BINARY;
		case HCC_EXPR_TYPE_BINARY_OP(MODULO): expr_name = "MODULO"; goto BINARY;
		case HCC_EXPR_TYPE_BINARY_OP(BIT_AND): expr_name = "BIT_AND"; goto BINARY;
		case HCC_EXPR_TYPE_BINARY_OP(BIT_OR): expr_name = "BIT_OR"; goto BINARY;
		case HCC_EXPR_TYPE_BINARY_OP(BIT_XOR): expr_name = "BIT_XOR"; goto BINARY;
		case HCC_EXPR_TYPE_BINARY_OP(BIT_SHIFT_LEFT): expr_name = "BIT_SHIFT_LEFT"; goto BINARY;
		case HCC_EXPR_TYPE_BINARY_OP(BIT_SHIFT_RIGHT): expr_name = "BIT_SHIFT_RIGHT"; goto BINARY;
		case HCC_EXPR_TYPE_BINARY_OP(EQUAL): expr_name = "EQUAL"; goto BINARY;
		case HCC_EXPR_TYPE_BINARY_OP(NOT_EQUAL): expr_name = "NOT_EQUAL"; goto BINARY;
		case HCC_EXPR_TYPE_BINARY_OP(LESS_THAN): expr_name = "LESS_THAN"; goto BINARY;
		case HCC_EXPR_TYPE_BINARY_OP(LESS_THAN_OR_EQUAL): expr_name = "LESS_THAN_OR_EQUAL"; goto BINARY;
		case HCC_EXPR_TYPE_BINARY_OP(GREATER_THAN): expr_name = "GREATER_THAN"; goto BINARY;
		case HCC_EXPR_TYPE_BINARY_OP(GREATER_THAN_OR_EQUAL): expr_name = "GREATER_THAN_OR_EQUAL"; goto BINARY;
		case HCC_EXPR_TYPE_BINARY_OP(LOGICAL_AND): expr_name = "LOGICAL_AND"; goto BINARY;
		case HCC_EXPR_TYPE_BINARY_OP(LOGICAL_OR): expr_name = "LOGICAL_OR"; goto BINARY;
		case HCC_EXPR_TYPE_BINARY_OP(COMMA): expr_name = "COMMA"; goto BINARY;
		case HCC_EXPR_TYPE_CALL: expr_name = "CALL"; goto BINARY;
		case HCC_EXPR_TYPE_ARRAY_SUBSCRIPT: expr_name = "ARRAY_SUBSCRIPT"; goto BINARY;
BINARY:
		{
			char* prefix = expr->binary.is_assignment ? "STMT_ASSIGN_" : "EXPR_";
			fprintf(f, "%s%s: {\n", prefix, expr_name);
			HccExpr* left_expr = expr - expr->binary.left_expr_rel_idx;
			HccExpr* right_expr = expr - expr->binary.right_expr_rel_idx;
			hcc_astgen_print_expr(c, left_expr, indent + 1, f);
			hcc_astgen_print_expr(c, right_expr, indent + 1, f);
			fprintf(f, "%.*s}", indent, indent_chars);
			break;
		};
		case HCC_EXPR_TYPE_CURLY_INITIALIZER: {
			fprintf(f, "%s: {\n", "EXPR_CURLY_INITIALIZER");

			////////////////////////////////////////////////////////////////////////////
			// skip the internal variable expression that sits at the start of the initializer_expr list
			HccExpr* initializer_expr = &expr[expr->curly_initializer.first_expr_rel_idx];
			U32 expr_rel_idx;
			////////////////////////////////////////////////////////////////////////////

			while (1) {
				expr_rel_idx = initializer_expr->next_expr_rel_idx;
				if (expr_rel_idx == 0) {
					break;
				}
				initializer_expr = &initializer_expr[expr_rel_idx];

				HccAstGenDesignatorInitializer* di = &c->astgen.curly_initializer.designated_initializers[initializer_expr->alt_next_expr_rel_idx];
				U64* elmt_indices = hcc_stack_get(c->astgen.curly_initializer.designated_initializer_elmt_indices, di->elmt_indices_start_idx);
				fprintf(f, "%.*s", indent + 1, indent_chars);
				HccDataType data_type = expr->data_type;
				if (di->elmt_indices_count) {
					for (U32 idx = 0; idx < di->elmt_indices_count; idx += 1) {
						data_type = hcc_typedef_resolve_and_strip_const_volatile(c, data_type);
						U64 entry_idx = elmt_indices[idx];
						if (HCC_DATA_TYPE_IS_ARRAY(data_type)) {
							HccArrayDataType* array_data_type = hcc_array_data_type_get(c, data_type);
							fprintf(f, "[%zu]", entry_idx);
							data_type = array_data_type->element_data_type;
						} else if (HCC_DATA_TYPE_IS_COMPOUND_TYPE(data_type)) {
							HccCompoundDataType* compound_data_type = hcc_compound_data_type_get(c, data_type);
							HccCompoundField* field = hcc_stack_get(c->astgen.compound_fields, compound_data_type->fields_start_idx + entry_idx);
							if (field->identifier_string_id.idx_plus_one) {
								HccString identifier_string = hcc_string_table_get(&c->string_table, field->identifier_string_id);
								fprintf(f, ".%.*s", (int)identifier_string.size, identifier_string.data);
							}
							data_type = field->data_type;
						}
					}
				} else {
				fprintf(f, "...");
				}
				fprintf(f, " = ");

				if (initializer_expr->designated_initializer.value_expr_rel_idx) {
					HccExpr* value_expr = initializer_expr - initializer_expr->designated_initializer.value_expr_rel_idx;
					if (value_expr->type == HCC_EXPR_TYPE_CURLY_INITIALIZER) {
						fprintf(f, "\n");
					}
					hcc_astgen_print_expr(c, value_expr, value_expr->type == HCC_EXPR_TYPE_CURLY_INITIALIZER ? indent + 2 : 0, f);
				} else {
					fprintf(f, "<ZERO>\n");
				}
			}

			fprintf(f, "%.*s}", indent, indent_chars);
			break;
		};
		case HCC_EXPR_TYPE_FIELD_ACCESS: {
			fprintf(f, "%s: {\n", "EXPR_FIELD_ACCESS");

			HccExpr* left_expr = expr - expr->binary.left_expr_rel_idx;
			U32 field_idx = expr->binary.right_expr_rel_idx;
			hcc_astgen_print_expr(c, left_expr, indent + 1, f);

			HccCompoundDataType* compound_data_type = hcc_compound_data_type_get(c, left_expr->data_type);
			HccCompoundField* field = hcc_stack_get(c->astgen.compound_fields, compound_data_type->fields_start_idx + field_idx);

			HccString field_data_type_name = hcc_data_type_string(c, field->data_type);
			if (field->identifier_string_id.idx_plus_one) {
				HccString identifier_string = hcc_string_table_get(&c->string_table, field->identifier_string_id);
				fprintf(f, "%.*sfield_idx(%u): %.*s %.*s\n", indent + 1, indent_chars, field_idx, (int)field_data_type_name.size, field_data_type_name.data, (int)identifier_string.size, identifier_string.data);
			} else {
				fprintf(f, "%.*sfield_idx(%u): %.*s\n", indent + 1, indent_chars, field_idx, (int)field_data_type_name.size, field_data_type_name.data);
			}

			fprintf(f, "%.*s}", indent, indent_chars);
			break;
		};
		case HCC_EXPR_TYPE_CALL_ARG_LIST: {
			fprintf(f, "EXPR_CALL_ARG_LIST: {\n");
			HccExpr* arg_expr = expr;
			U32 args_count = ((U8*)expr)[1];
			U8* next_arg_expr_rel_indices = &((U8*)expr)[2];
			for (U32 i = 0; i < args_count; i += 1) {
				arg_expr = &arg_expr[next_arg_expr_rel_indices[i]];
				hcc_astgen_print_expr(c, arg_expr, indent + 1, f);
			}
			fprintf(f, "%.*s}", indent, indent_chars);
			break;
		};
		case HCC_EXPR_TYPE_LOCAL_VARIABLE: {
			char buf[1024];
			HccVariable* variable = hcc_stack_get(c->astgen.function_params_and_variables, c->astgen.function->params_start_idx + expr->variable.idx);
			hcc_variable_to_string(c, variable, buf, sizeof(buf), false);
			fprintf(f, "LOCAL_VARIABLE(#%u): %s", expr->variable.idx, buf);
			break;
		};
		case HCC_EXPR_TYPE_GLOBAL_VARIABLE: {
			char buf[1024];
			HccVariable* variable = hcc_stack_get(c->astgen.global_variables, expr->variable.idx);
			hcc_variable_to_string(c, variable, buf, sizeof(buf), false);
			fprintf(f, "GLOBAL_VARIABLE(#%u): %s", expr->variable.idx, buf);
			break;
		};
		case HCC_EXPR_TYPE_BINARY_OP(TERNARY): {
			fprintf(f, "%s: {\n", "STMT_TERNARY");

			HccExpr* cond_expr = expr - expr->ternary.cond_expr_rel_idx;
			fprintf(f, "%.*sCONDITION_EXPR:\n", indent + 1, indent_chars);
			hcc_astgen_print_expr(c, cond_expr, indent + 2, f);

			HccExpr* true_stmt = expr - expr->ternary.true_expr_rel_idx;
			fprintf(f, "%.*sTRUE_STMT:\n", indent + 1, indent_chars);
			hcc_astgen_print_expr(c, true_stmt, indent + 2, f);

			HccExpr* false_stmt = expr - expr->ternary.false_expr_rel_idx;
			fprintf(f, "%.*sFALSE_STMT:\n", indent + 1, indent_chars);
			hcc_astgen_print_expr(c, false_stmt, indent + 2, f);

			fprintf(f, "%.*s}", indent, indent_chars);
			break;
		};
		default:
			HCC_ABORT("unhandled expr type %u\n", expr->type);
	}
	fprintf(f, "\n");
}

void hcc_astgen_print(HccCompiler* c, FILE* f) {
	for (U32 enum_type_idx = 0; enum_type_idx < hcc_stack_count(c->astgen.enum_data_types); enum_type_idx += 1) {
		HccEnumDataType* d = hcc_stack_get(c->astgen.enum_data_types, enum_type_idx);
		HccString name = hcc_string_lit("<anonymous>");
		if (d->identifier_string_id.idx_plus_one) {
			name = hcc_string_table_get(&c->string_table, d->identifier_string_id);
		}
		fprintf(f, "ENUM(#%u): %.*s {\n", enum_type_idx, (int)name.size, name.data);
		for (U32 value_idx = 0; value_idx < d->values_count; value_idx += 1) {
			HccEnumValue* value = hcc_stack_get(c->astgen.enum_values, d->values_start_idx + value_idx);
			HccString identifier = hcc_string_table_get_or_empty(&c->string_table, value->identifier_string_id);

			HccConstant constant = hcc_constant_table_get(c, value->value_constant_id);

			S64 v;
			HCC_DEBUG_ASSERT(hcc_constant_as_sint(c, constant, &v), "internal error: expected to be a signed int");
			fprintf(f, "\t%.*s = %ld\n", (int)identifier.size, identifier.data, v);
		}
		fprintf(f, "}\n");
	}

	for (U32 compound_type_idx = 0; compound_type_idx < hcc_stack_count(c->astgen.compound_data_types); compound_type_idx += 1) {
		HccCompoundDataType* d = hcc_stack_get(c->astgen.compound_data_types, compound_type_idx);
		HccString name = hcc_string_lit("<anonymous>");
		if (d->identifier_string_id.idx_plus_one) {
			name = hcc_string_table_get(&c->string_table, d->identifier_string_id);
		}
		char* compound_name = d->flags & HCC_COMPOUND_DATA_TYPE_FLAGS_IS_UNION ? "UNION" : "STRUCT";
		fprintf(f, "%s(#%u): %.*s {\n", compound_name, compound_type_idx, (int)name.size, name.data);
		fprintf(f, "\tsize: %zu\n", d->size);
		fprintf(f, "\talign: %zu\n", d->align);
		fprintf(f, "\tfields: {\n");
		for (U32 field_idx = 0; field_idx < d->fields_count; field_idx += 1) {
			HccCompoundField* field = hcc_stack_get(c->astgen.compound_fields, d->fields_start_idx + field_idx);
			HccString data_type_name = hcc_data_type_string(c, field->data_type);
			fprintf(f, "\t\t%.*s ", (int)data_type_name.size, data_type_name.data);
			if (field->identifier_string_id.idx_plus_one) {
				HccString identifier = hcc_string_table_get_or_empty(&c->string_table, field->identifier_string_id);
				fprintf(f, "%.*s\n", (int)identifier.size, identifier.data);
			} else {
				fprintf(f, "\n");
			}
		}
		fprintf(f, "\t}\n");
		fprintf(f, "}\n");
	}

	for (U32 array_type_idx = 0; array_type_idx < hcc_stack_count(c->astgen.array_data_types); array_type_idx += 1) {
		HccArrayDataType* d = hcc_stack_get(c->astgen.array_data_types, array_type_idx);
		HccString data_type_name = hcc_data_type_string(c, d->element_data_type);

		HccConstant constant = hcc_constant_table_get(c, d->size_constant_id);

		U64 count;
		HCC_DEBUG_ASSERT(hcc_constant_as_uint(c, constant, &count), "internal error: expected to be a unsigned int");

		fprintf(f, "ARRAY(#%u): %.*s[%zu]\n", array_type_idx, (int)data_type_name.size, data_type_name.data, count);
	}

	for (U32 typedefs_idx = 0; typedefs_idx < hcc_stack_count(c->astgen.typedefs); typedefs_idx += 1) {
		HccTypedef* d = hcc_stack_get(c->astgen.typedefs, typedefs_idx);
		HccString name = hcc_string_table_get_or_empty(&c->string_table, d->identifier_string_id);
		HccString aliased_data_type_name = hcc_data_type_string(c, d->aliased_data_type);
		fprintf(f, "typedef(#%u) %.*s %.*s\n", typedefs_idx, (int)aliased_data_type_name.size, aliased_data_type_name.data, (int)name.size, name.data);
	}

	for (U32 variable_idx = 0; variable_idx < hcc_stack_count(c->astgen.global_variables); variable_idx += 1) {
		HccVariable* variable = hcc_stack_get(c->astgen.global_variables, variable_idx);

		char buf[1024];
		hcc_variable_to_string(c, variable, buf, sizeof(buf), false);
		fprintf(f, "GLOBAL_VARIABLE(#%u): %s", variable_idx, buf);
		fprintf(f, " = ");
		hcc_constant_print(c, variable->initializer_constant_id, f);
		fprintf(f, "\n");
	}

	for (U32 function_idx = 0; function_idx < hcc_stack_count(c->astgen.functions); function_idx += 1) {
		HccFunction* function = hcc_stack_get(c->astgen.functions, function_idx);
		if (function->identifier_string_id.idx_plus_one == 0) {
			continue;
		}
		HccString name = hcc_string_table_get_or_empty(&c->string_table, function->identifier_string_id);
		HccString return_data_type_name = hcc_data_type_string(c, function->return_data_type);
		fprintf(f, "Function(#%u): %.*s {\n", function_idx, (int)name.size, name.data);
		fprintf(f, "\treturn_type: %.*s\n", (int)return_data_type_name.size, return_data_type_name.data);
		fprintf(f, "\tshader_stage: %s\n", hcc_function_shader_stage_strings[function->shader_stage]);
		fprintf(f, "\tstatic: %s\n", function->flags & HCC_FUNCTION_FLAGS_STATIC ? "true" : "false");
		fprintf(f, "\tinline: %s\n", function->flags & HCC_FUNCTION_FLAGS_INLINE ? "true" : "false");
		if (function->params_count) {
			fprintf(f, "\tparams[%u]: {\n", function->params_count);
			for (U32 param_idx = 0; param_idx < function->params_count; param_idx += 1) {
				HccVariable* param = hcc_stack_get(c->astgen.function_params_and_variables, function->params_start_idx + param_idx);
				HccString type_name = hcc_data_type_string(c, param->data_type);
				HccString param_name = hcc_string_table_get(&c->string_table, param->identifier_string_id);
				fprintf(f, "\t\t%.*s %.*s\n", (int)type_name.size, type_name.data, (int)param_name.size, param_name.data);
			}
			fprintf(f, "\t}\n");
		}
		if (function->block_expr_id.idx_plus_one) {
			c->astgen.function = function;
			c->astgen.print_variable_base_idx = function->params_count;
			HccExpr* expr = &c->astgen.exprs[function->block_expr_id.idx_plus_one - 1];
			hcc_astgen_print_expr(c, expr, 1, f);
		}
		fprintf(f, "}\n");
	}
}

// ===========================================
//
//
// IR
//
//
// ===========================================

const char* hcc_ir_op_code_strings[HCC_IR_OP_CODE_COUNT] = {
	[HCC_IR_OP_CODE_NO_OP] = "NO_OP",

	//
	// memory access
	[HCC_IR_OP_CODE_PTR_STATIC_ALLOC] = "PTR_STATIC_ALLOC",
	[HCC_IR_OP_CODE_PTR_LOAD] = "PTR_LOAD",
	[HCC_IR_OP_CODE_PTR_STORE] = "PTR_STORE",
	[HCC_IR_OP_CODE_PTR_ACCESS_CHAIN] = "PTR_ACCESS_CHAIN",
	[HCC_IR_OP_CODE_PTR_ACCESS_CHAIN_IN_BOUNDS] = "PTR_ACCESS_CHAIN_IN_BOUNDS",

	//
	// composite operations
	[HCC_IR_OP_CODE_COMPOSITE_INIT] = "COMPOSITE_INIT",
	[HCC_IR_OP_CODE_COMPOSITE_ACCESS_CHAIN_GET] = "COMPOSITE_ACCESS_CHAIN_GET",
	[HCC_IR_OP_CODE_COMPOSITE_ACCESS_CHAIN_SET] = "COMPOSITE_ACCESS_CHAIN_SET",

	//
	// branching
	[HCC_IR_OP_CODE_BASIC_BLOCK] = "BASIC_BLOCK",
	[HCC_IR_OP_CODE_SELECTION_MERGE] = "SELECTION_MERGE",
	[HCC_IR_OP_CODE_LOOP_MERGE] = "LOOP_MERGE",
	[HCC_IR_OP_CODE_BRANCH] = "BRANCH",
	[HCC_IR_OP_CODE_BRANCH_CONDITIONAL] = "BRANCH_CONDITIONAL",
	[HCC_IR_OP_CODE_SWITCH] = "SWITCH",
	[HCC_IR_OP_CODE_PHI] = "PHI",

	[HCC_IR_OP_CODE_BINARY_OP_START + HCC_BINARY_OP_ASSIGN] = "BINARY_OP_ASSIGN",
	[HCC_IR_OP_CODE_BINARY_OP_START + HCC_BINARY_OP_ADD] = "BINARY_OP_ADD",
	[HCC_IR_OP_CODE_BINARY_OP_START + HCC_BINARY_OP_SUBTRACT] = "BINARY_OP_SUBTRACT",
	[HCC_IR_OP_CODE_BINARY_OP_START + HCC_BINARY_OP_MULTIPLY] = "BINARY_OP_MULTIPLY",
	[HCC_IR_OP_CODE_BINARY_OP_START + HCC_BINARY_OP_DIVIDE] = "BINARY_OP_DIVIDE",
	[HCC_IR_OP_CODE_BINARY_OP_START + HCC_BINARY_OP_MODULO] = "BINARY_OP_MODULO",
	[HCC_IR_OP_CODE_BINARY_OP_START + HCC_BINARY_OP_BIT_AND] = "BINARY_OP_BIT_AND",
	[HCC_IR_OP_CODE_BINARY_OP_START + HCC_BINARY_OP_BIT_OR] = "BINARY_OP_BIT_OR",
	[HCC_IR_OP_CODE_BINARY_OP_START + HCC_BINARY_OP_BIT_XOR] = "BINARY_OP_BIT_XOR",
	[HCC_IR_OP_CODE_BINARY_OP_START + HCC_BINARY_OP_BIT_SHIFT_LEFT] = "BINARY_OP_BIT_SHIFT_LEFT",
	[HCC_IR_OP_CODE_BINARY_OP_START + HCC_BINARY_OP_BIT_SHIFT_RIGHT] = "BINARY_OP_BIT_SHIFT_RIGHT",
	[HCC_IR_OP_CODE_BINARY_OP_START + HCC_BINARY_OP_EQUAL] = "BINARY_OP_EQUAL",
	[HCC_IR_OP_CODE_BINARY_OP_START + HCC_BINARY_OP_NOT_EQUAL] = "BINARY_OP_NOT_EQUAL",
	[HCC_IR_OP_CODE_BINARY_OP_START + HCC_BINARY_OP_LESS_THAN] = "BINARY_OP_LESS_THAN",
	[HCC_IR_OP_CODE_BINARY_OP_START + HCC_BINARY_OP_LESS_THAN_OR_EQUAL] = "BINARY_OP_LESS_THAN_OR_EQUAL",
	[HCC_IR_OP_CODE_BINARY_OP_START + HCC_BINARY_OP_GREATER_THAN] = "BINARY_OP_GREATER_THAN",
	[HCC_IR_OP_CODE_BINARY_OP_START + HCC_BINARY_OP_GREATER_THAN_OR_EQUAL] = "BINARY_OP_GREATER_THAN_OR_EQUAL",
	[HCC_IR_OP_CODE_BINARY_OP_START + HCC_BINARY_OP_LOGICAL_AND] = "BINARY_OP_LOGICAL_AND",
	[HCC_IR_OP_CODE_BINARY_OP_START + HCC_BINARY_OP_LOGICAL_OR] = "BINARY_OP_LOGICAL_OR",
	[HCC_IR_OP_CODE_BINARY_OP_START + HCC_BINARY_OP_TERNARY] = "BINARY_OP_TERNARY",
	[HCC_IR_OP_CODE_BINARY_OP_START + HCC_BINARY_OP_COMMA] = "BINARY_OP_COMMA",

	[HCC_IR_OP_CODE_UNARY_OP_START + HCC_UNARY_OP_LOGICAL_NOT] = "UNARY_OP_LOGICAL_NOT",
	[HCC_IR_OP_CODE_UNARY_OP_START + HCC_UNARY_OP_BIT_NOT] = "UNARY_OP_BIT_NOT",
	[HCC_IR_OP_CODE_UNARY_OP_START + HCC_UNARY_OP_PLUS] = "UNARY_OP_PLUS",
	[HCC_IR_OP_CODE_UNARY_OP_START + HCC_UNARY_OP_NEGATE] = "UNARY_OP_NEGATE",
	[HCC_IR_OP_CODE_UNARY_OP_START + HCC_UNARY_OP_PRE_INCREMENT] = "UNARY_OP_PRE_INCREMENT",
	[HCC_IR_OP_CODE_UNARY_OP_START + HCC_UNARY_OP_PRE_DECREMENT] = "UNARY_OP_PRE_DECREMENT",
	[HCC_IR_OP_CODE_UNARY_OP_START + HCC_UNARY_OP_POST_INCREMENT] = "UNARY_OP_POST_INCREMENT",
	[HCC_IR_OP_CODE_UNARY_OP_START + HCC_UNARY_OP_POST_DECREMENT] = "UNARY_OP_POST_DECREMENT",
	[HCC_IR_OP_CODE_UNARY_OP_START + HCC_UNARY_OP_DEREF] = "UNARY_OP_DEREF",
	[HCC_IR_OP_CODE_UNARY_OP_START + HCC_UNARY_OP_ADDRESS_OF] = "UNARY_OP_ADDRESS_OF",

	//
	// conversion
	[HCC_IR_OP_CODE_CONVERT] = "CONVERT",
	[HCC_IR_OP_CODE_BITCAST] = "BITCAST",
	[HCC_IR_OP_CODE_BITCAST_PTR] = "BITCAST_PTR",

	[HCC_IR_OP_CODE_FUNCTION_CALL] = "FUNCTION_CALL",
	[HCC_IR_OP_CODE_FUNCTION_RETURN] = "FUNCTION_RETURN",
	[HCC_IR_OP_CODE_UNREACHABLE] = "UNREACHABLE",
	[HCC_IR_OP_CODE_SELECT] = "SELECT",
};

bool hcc_ir_op_code_has_return_value(HccIROpCode op_code) {
	if (HCC_IR_OP_CODE_BINARY_OP_START <= op_code && op_code < HCC_IR_OP_CODE_BINARY_OP_END) {
		return true;
	}

	if (HCC_IR_OP_CODE_UNARY_OP_START <= op_code && op_code < HCC_IR_OP_CODE_UNARY_OP_END) {
		return true;
	}

	switch (op_code) {
		case HCC_IR_OP_CODE_PTR_STATIC_ALLOC:
		case HCC_IR_OP_CODE_PTR_LOAD:
		case HCC_IR_OP_CODE_PTR_ACCESS_CHAIN:
		case HCC_IR_OP_CODE_PTR_ACCESS_CHAIN_IN_BOUNDS:
		case HCC_IR_OP_CODE_PHI:
		case HCC_IR_OP_CODE_CONVERT:
		case HCC_IR_OP_CODE_BITCAST:
		case HCC_IR_OP_CODE_BITCAST_PTR:
		case HCC_IR_OP_CODE_COMPOSITE_INIT:
		case HCC_IR_OP_CODE_COMPOSITE_ACCESS_CHAIN_GET:
		case HCC_IR_OP_CODE_FUNCTION_CALL:
		case HCC_IR_OP_CODE_FUNCTION_RETURN:
		case HCC_IR_OP_CODE_SELECT:
			return true;
	}

	return false;
}

HccIRInstrIter hcc_ir_instr_iter_init(HccCompiler* c, HccIRFunction* ir_function) {
	HccIRInstrIter iter;
	iter.words = hcc_stack_get(c->irgen.words, ir_function->words_start_idx);
	iter.next_word_idx = 0;
	iter.words_count = ir_function->words_count;
	return iter;
}

bool hcc_ir_instr_iter_next(HccIRInstrIter* iter, HccIRInstrEntry* entry_out) {
	if (iter->next_word_idx >= iter->words_count) {
		return false;
	}

	HccIRInstr* instr = &iter->words[iter->next_word_idx];
	entry_out->operands = hcc_irgen_instruction_operands(instr);
	entry_out->instr_word_idx = iter->next_word_idx;
	entry_out->operands_count = hcc_irgen_instruction_operands_count(instr);
	entry_out->op_code = hcc_irgen_instruction_op_code(instr);
	iter->next_word_idx += hcc_irgen_instruction_words_count(instr);
	return true;
}

HccIRInstr* hcc_ir_instr_iter_peek_next(HccIRInstrIter* iter) {
	if (iter->next_word_idx >= iter->words_count) {
		return NULL;
	}

	return &iter->words[iter->next_word_idx];
}

U32 hcc_ir_instr_iter_word_idx(HccIRInstrIter* iter) {
	return iter->next_word_idx - iter->words_count;
}

HccIRWord* hcc_ir_function_word(HccCompiler* c, HccIRFunction* ir_function, U32 word_idx) {
	return hcc_stack_get(c->irgen.words, ir_function->words_start_idx + word_idx);
}

HccIRValue* hcc_ir_function_value(HccCompiler* c, HccIRFunction* ir_function, U32 value_idx) {
	return hcc_stack_get(c->irgen.values, ir_function->values_start_idx + value_idx);
}

void hcc_ir_print_operand(HccCompiler* c, HccIROperand operand, FILE* f) {
	switch (operand & 0xff) {
		case HCC_IR_OPERAND_VALUE:
			fprintf(f, "v%u", HCC_IR_OPERAND_VALUE_IDX(operand));
			break;
		case HCC_IR_OPERAND_CONSTANT:
			fprintf(f, "c%u", HCC_IR_OPERAND_CONSTANT_ID(operand).idx_plus_one - 1);
			break;
		case HCC_IR_OPERAND_CONSTANT_IMMEDIATE_U24:
			fprintf(f, "immc(%u)", HCC_IR_OPERAND_CONSTANT_IMMEDIATE_U24(operand));
			break;
		case HCC_IR_OPERAND_GLOBAL_VARIABLE:
			fprintf(f, "gvar%u", HCC_IR_OPERAND_GLOBAL_VARIABLE_IDX(operand));
			break;
		case HCC_IR_OPERAND_FUNCTION: {
			HccFunction* function = hcc_stack_get(c->astgen.functions, HCC_IR_OPERAND_FUNCTION_IDX(operand));
			HccString ident = hcc_string_table_get(&c->string_table, function->identifier_string_id);
			fprintf(f, "function%u(%.*s)", HCC_IR_OPERAND_FUNCTION_IDX(operand), (int)ident.size, ident.data);
			break;
		};
		case HCC_IR_OPERAND_SHADER_STAGE_INPUT: {
			U32 field_idx = HCC_IR_OPERAND_SHADER_STAGE_INPUT_FIELD_IDX(operand);
			HccIntrinsicStruct* s = NULL;
			switch (c->irgen.function->shader_stage) {
				case HCC_FUNCTION_SHADER_STAGE_VERTEX: s = &hcc_intrinsic_structs[HCC_STRUCT_IDX_VERTEX_INPUT]; break;
				case HCC_FUNCTION_SHADER_STAGE_FRAGMENT: s = &hcc_intrinsic_structs[HCC_STRUCT_IDX_FRAGMENT_INPUT]; break;
				default: HCC_UNREACHABLE("unhandled shader stage input operand");
			}
			HCC_DEBUG_ASSERT(s && s->fields[field_idx].string_id.idx_plus_one, "unhandled shader stage input operand");
			HccString struct_name = hcc_string_table_get(&c->string_table, s->string_id);
			HccString field_name = hcc_string_table_get(&c->string_table, s->fields[field_idx].string_id);
			fprintf(f, "si%u(%.*s.%.*s)", HCC_IR_OPERAND_SHADER_STAGE_INPUT_FIELD_IDX(operand), (int)struct_name.size, struct_name.data, (int)field_name.size, field_name.data);
			break;
		};
		case HCC_IR_OPERAND_RASTERIZER_STATE: {
			U32 field_idx = HCC_IR_OPERAND_RASTERIZER_STATE_FIELD_IDX(operand);
			HccVariable* param = hcc_stack_get(c->astgen.function_params_and_variables, c->irgen.function->params_start_idx + 1);
			HccCompoundDataType* s = hcc_compound_data_type_get(c, hcc_typedef_resolve_and_strip_const_volatile(c, param->data_type));
			HCC_DEBUG_ASSERT(field_idx < s->fields_count, "unhandled shader stage input operand");
			HccString struct_name = hcc_string_table_get(&c->string_table, s->identifier_string_id);
			HccString field_name = hcc_string_table_get(&c->string_table, c->astgen.compound_fields[s->fields_start_idx + field_idx].identifier_string_id);
			fprintf(f, "rs%u(%.*s.%.*s)", HCC_IR_OPERAND_SHADER_STAGE_INPUT_FIELD_IDX(operand), (int)struct_name.size, struct_name.data, (int)field_name.size, field_name.data);
			break;
		};
		default: {
			HccString data_type_name = hcc_data_type_string(c, operand);
			fprintf(f, "%.*s", (int)data_type_name.size, data_type_name.data);
			break;
		};
	}
}

void hcc_ir_print(HccCompiler* c, FILE* f) {
	HccConstantTable* constant_table = &c->constant_table;
	for (U32 idx = 0; idx < constant_table->entries_count; idx += 1) {
		fprintf(f, "Constant(c%u): ", idx);
		HccConstantId constant_id = { .idx_plus_one = idx + 1 };
		hcc_constant_print(c, constant_id, stdout);
		fprintf(f, "\n");
	}

	for (U32 used_function_idx = 0; used_function_idx < hcc_stack_count(c->astgen.used_function_indices); used_function_idx += 1) {
		U32 function_idx = c->astgen.used_function_indices[used_function_idx];
		HccFunction* function = hcc_stack_get(c->astgen.functions, function_idx);
		HccIRFunction* ir_function = hcc_stack_get(c->irgen.functions, function_idx);
		char buf[1024];
		hcc_function_to_string(c, function, buf, sizeof(buf), false);
		fprintf(f, "Function(#%u): %s\n", function_idx, buf);
		U32 word_idx = 0;
		while (word_idx < ir_function->words_count) {
			HccIRInstr* instr = hcc_stack_get(c->irgen.words, ir_function->words_start_idx + word_idx);
			HccIROperand* operands = hcc_irgen_instruction_operands(instr);
			U32 operands_count = hcc_irgen_instruction_operands_count(instr);
			HccIROpCode op_code = hcc_irgen_instruction_op_code(instr);
			word_idx += hcc_irgen_instruction_words_count(instr);

			U32 operands_start_idx = 0;
			if (hcc_ir_op_code_has_return_value(op_code)) {
				fprintf(f, "\t\t");
				hcc_ir_print_operand(c, operands[0], f);
				fprintf(f, " = ");
				operands_start_idx = 1;
			}

			const char* op_code_string = hcc_ir_op_code_strings[op_code];
			HCC_DEBUG_ASSERT(op_code_string, "unhandled instruction '%u'", op_code);
			fprintf(f, "%s:", op_code_string);
			for (U32 idx = operands_start_idx; idx < operands_count; idx += 1) {
				hcc_ir_print_operand(c, operands[idx], f);
				if (idx + 1 < operands_count) {
					fprintf(f, ", ");
				}
			}
		}
	}
}

// ===========================================
//
//
// IR Generation
//
//
// ===========================================

void hcc_irgen_init(HccCompiler* c, HccCompilerSetup* setup) {
	c->irgen.functions = hcc_stack_init(HccIRFunction, setup->irgen.functions_cap, HCC_ALLOC_TAG_IRGEN_FUNCTIONS);
	c->irgen.basic_block_words_start_indices = hcc_stack_init(U32, setup->irgen.basic_blocks_cap, HCC_ALLOC_TAG_IRGEN_BASIC_BLOCKS);
	c->irgen.values = hcc_stack_init(HccIRValue, setup->irgen.values_cap, HCC_ALLOC_TAG_IRGEN_VALUES);
	c->irgen.words = hcc_stack_init(HccIRWord, setup->irgen.words_cap, HCC_ALLOC_TAG_IRGEN_WORDS);

	hcc_stack_resize(c->irgen.functions, HCC_FUNCTION_IDX_USER_START);
}

HccIROpCode hcc_irgen_instruction_op_code(HccIRInstr* instr) {
	return *instr & 0xffff;
}

U32 hcc_irgen_instruction_words_count(HccIRInstr* instr) {
	return (*instr >> 16) + 1;
}

U32 hcc_irgen_instruction_operands_count(HccIRInstr* instr) {
	return *instr >> 16;
}

HccIROperand* hcc_irgen_instruction_operands(HccIRInstr* instr) {
	return &instr[1];
}

HccIRWord* hcc_irgen_words_add(HccCompiler* c, U32 count) {
	HccIRFunction* ir_function = c->irgen.ir_function;
	ir_function->words_count += count;
	return hcc_stack_push_many(c->irgen.words, count);
}

HccIROperand hcc_irgen_value_add(HccCompiler* c, HccDataType data_type) {
	HccIRFunction* ir_function = c->irgen.ir_function;

	HccIRValue* value = hcc_stack_push(c->irgen.values);
	value->data_type = data_type;

	U16 value_idx = ir_function->values_count;
	ir_function->values_count += 1;
	return HCC_IR_OPERAND_VALUE_INIT(value_idx);
}

HccIROperand hcc_irgen_value_for_param(U32 param_idx) {
	return HCC_IR_OPERAND_VALUE_IDX(param_idx);
}

HccIROperand hcc_irgen_value_ptr_for_param_or_local_variable(HccCompiler* c, U32 local_variable_idx) {
	HccIRFunction* ir_function = c->irgen.ir_function;
	return HCC_IR_OPERAND_VALUE_IDX(ir_function->params_count + local_variable_idx);
}

HccIROperand hcc_irgen_basic_block_add(HccCompiler* c) {
	HccIRFunction* ir_function = c->irgen.ir_function;
	*hcc_stack_push(c->irgen.basic_block_words_start_indices) = ir_function->words_count;

	ir_function->words_count += 1;
	ir_function->basic_blocks_count += 1;

	HccIROperand basic_block_operand = hcc_irgen_value_add(c, HCC_DATA_TYPE_VOID);
	HccIROperand* operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_BASIC_BLOCK, 1);
	operands[0] = basic_block_operand;
	c->irgen.basic_block_operand = basic_block_operand;
	return basic_block_operand;
}

HccIROperand* hcc_irgen_instruction_add(HccCompiler* c, HccIROpCode op_code, U32 operands_count) {
	HccIRFunction* ir_function = c->irgen.ir_function;
	ir_function->instructions_count += 1;

	c->irgen.last_instruction_words_start_idx = hcc_stack_count(c->irgen.words);
	HccIRWord* words = hcc_irgen_words_add(c, operands_count + 1);
	words[0] = (operands_count << 16) | (U32)op_code;
	return &words[1];
}

void hcc_irgen_instruction_remove_last(HccCompiler* c, U32 operands_count) {
	HccIRFunction* ir_function = c->irgen.ir_function;

	U32 words_count = operands_count + 1;
	hcc_stack_pop_many(c->irgen.words, words_count);
	ir_function->words_count -= words_count;
	ir_function->instructions_count -= 1;
}

HccIRWord* hcc_irgen_instruction_get_last(HccCompiler* c) {
	return hcc_stack_get(c->irgen.words, c->irgen.last_instruction_words_start_idx);
}

HccIROpCode hcc_irgen_instruction_get_last_op_code(HccCompiler* c) {
	return hcc_irgen_instruction_op_code(hcc_irgen_instruction_get_last(c));
}

U32 hcc_irgen_instruction_get_last_operands_count(HccCompiler* c) {
	return hcc_irgen_instruction_operands_count(hcc_irgen_instruction_get_last(c));
}

void hcc_irgen_instruction_shrink_last_operands_count(HccCompiler* c, U32 new_amount) {
	HccIRFunction* ir_function = c->irgen.ir_function;

	HccIRWord* last_instr = hcc_irgen_instruction_get_last(c);
	U32 amount = *last_instr >> 16;
	HCC_DEBUG_ASSERT(amount >= new_amount, "internal error: new amount is larger than the original");
	*last_instr &= 0x0000ffff;
	*last_instr |= new_amount << 16;

	U32 shrink_by = amount - new_amount;
	hcc_stack_pop_many(c->irgen.words, shrink_by);
	ir_function->words_count -= shrink_by;
}

HccDataType hcc_irgen_operand_data_type(HccCompiler* c, HccFunction* function, HccIRFunction* ir_function, HccIROperand ir_operand) {
	switch (ir_operand & 0xff) {
		case HCC_IR_OPERAND_VALUE: {
			HccIRValue* value = hcc_stack_get(c->irgen.values, ir_function->values_start_idx + HCC_IR_OPERAND_VALUE_IDX(ir_operand));
			return value->data_type;
		};
		case HCC_IR_OPERAND_CONSTANT: {
			HccConstant constant = hcc_constant_table_get(c, HCC_IR_OPERAND_CONSTANT_ID(ir_operand));
			return constant.data_type;
		};
		case HCC_IR_OPERAND_CONSTANT_IMMEDIATE_U24:
			HCC_UNREACHABLE("not sure if we need to get the data type for an immediate constant");
		case HCC_IR_OPERAND_GLOBAL_VARIABLE: {
			HccVariable* variable = hcc_stack_get(c->astgen.global_variables, HCC_IR_OPERAND_GLOBAL_VARIABLE_IDX(ir_operand));
			return variable->data_type;
		};
		case HCC_IR_OPERAND_SHADER_STAGE_INPUT: {
			U32 field_idx = HCC_IR_OPERAND_SHADER_STAGE_INPUT_FIELD_IDX(ir_operand);
			switch (function->shader_stage) {
				case HCC_FUNCTION_SHADER_STAGE_VERTEX: {
					switch (field_idx) {
						case HCC_VERTEX_INPUT_VERTEX_INDEX: return HCC_DATA_TYPE_INT32;
						case HCC_VERTEX_INPUT_INSTANCE_INDEX: return HCC_DATA_TYPE_INT32;
					}
					break;
				};
				case HCC_FUNCTION_SHADER_STAGE_FRAGMENT: {
					switch (field_idx) {
						case HCC_FRAGMENT_INPUT_FRAG_COORD: return HCC_DATA_TYPE_VECTOR(HCC_VEC4F32);
					}

					break;
				};
			}

			HCC_UNREACHABLE("unhandled shader stage input operand");
			break;
		};
		case HCC_IR_OPERAND_RASTERIZER_STATE: {
			U32 field_idx = HCC_IR_OPERAND_RASTERIZER_STATE_FIELD_IDX(ir_operand);
			HccVariable* param = hcc_stack_get(c->astgen.function_params_and_variables, function->params_start_idx + 1);
			HccCompoundDataType* rasterizer_state_compound_data_type = hcc_compound_data_type_get(c, hcc_typedef_resolve_and_strip_const_volatile(c, param->data_type));
			HccCompoundField* field = hcc_stack_get(c->astgen.compound_fields, rasterizer_state_compound_data_type->fields_start_idx + field_idx);
			HccDataType field_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, field->data_type);
			return field_data_type;
		};
		default:
			return (HccDataType)ir_operand;
	}
}

void hcc_irgen_generate_convert_to_bool(HccCompiler* c, HccIROperand cond_operand, bool flip_bool_result) {
	HccFunction* function = c->irgen.function;
	HccIRFunction* ir_function = c->irgen.ir_function;
	HccDataType cond_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, hcc_irgen_operand_data_type(c, function, ir_function, cond_operand));
	HCC_DEBUG_ASSERT(
		!HCC_DATA_TYPE_IS_COMPOSITE_TYPE(cond_data_type),
		"a condition expression must be a non-composite type"
	);

	HccIROperand* operands = hcc_irgen_instruction_add(c, flip_bool_result ? HCC_IR_OP_CODE_BINARY_OP(EQUAL) : HCC_IR_OP_CODE_BINARY_OP(NOT_EQUAL), 3);

	operands[0] = hcc_irgen_value_add(c, HCC_DATA_TYPE_BOOL);
	operands[1] = cond_operand;
	operands[2] = HCC_IR_OPERAND_CONSTANT_INIT(hcc_constant_table_deduplicate_zero(c, cond_data_type).idx_plus_one);
	c->irgen.last_operand = operands[0];
}

void hcc_irgen_generate_condition_expr(HccCompiler* c, HccExpr* cond_expr, bool flip_bool_result) {
	hcc_irgen_generate_instructions(c, cond_expr);
	HccIROperand cond_operand = c->irgen.last_operand;
	HccFunction* function = c->irgen.function;
	HccIRFunction* ir_function = c->irgen.ir_function;
	HccDataType cond_data_type = hcc_irgen_operand_data_type(c, function, ir_function, cond_operand);
	if (cond_data_type != HCC_DATA_TYPE_BOOL) {
		hcc_irgen_generate_convert_to_bool(c, cond_operand, flip_bool_result);
	}
}

void hcc_irgen_generate_case_instructions(HccCompiler* c, HccExpr* first_stmt) {
	HccExpr* stmt = first_stmt;
	while (1) {
		hcc_irgen_generate_instructions(c, stmt);
		if (
			stmt->type == HCC_EXPR_TYPE_STMT_CASE ||
			stmt->type == HCC_EXPR_TYPE_STMT_DEFAULT
		) {
			break;
		}
		stmt = &stmt[stmt->next_expr_rel_idx];
	}
	c->irgen.branch_state.all_cases_return &= hcc_stmt_has_return(stmt);
}

void hcc_irgen_generate_ptr_load(HccCompiler* c, HccDataType data_type, HccIROperand src_operand) {
	HccIROperand* operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_PTR_LOAD, 2);
	operands[0] = hcc_irgen_value_add(c, data_type);
	operands[1] = src_operand;

	c->irgen.last_operand = operands[0];
}

void hcc_irgen_generate_ptr_store(HccCompiler* c, HccIROperand dst_operand, HccIROperand src_operand) {
	HccIROperand* operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_PTR_STORE, 2);
	operands[0] = dst_operand;
	operands[1] = src_operand;

	c->irgen.last_operand = dst_operand;
}

void hcc_irgen_generate_bitcast(HccCompiler* c, HccDataType dst_data_type, HccIROperand src_operand, bool is_ptr) {
	HccIROperand* operands = hcc_irgen_instruction_add(c, is_ptr ? HCC_IR_OP_CODE_BITCAST_PTR : HCC_IR_OP_CODE_BITCAST, 3);
	operands[0] = hcc_irgen_value_add(c, dst_data_type);
	operands[1] = dst_data_type;
	operands[2] = src_operand;

	c->irgen.last_operand = operands[0];
}

void hcc_irgen_generate_bitcast_union_field(HccCompiler* c, HccDataType union_data_type, U32 field_idx, HccIROperand src_operand) {
	HccCompoundDataType* compound_data_type = hcc_compound_data_type_get(c, union_data_type);
	HccCompoundField* field = hcc_stack_get(c->astgen.compound_fields, compound_data_type->fields_start_idx + field_idx);

	hcc_irgen_generate_bitcast(c, field->data_type, src_operand, true);
}

HccIROperand* hcc_irgen_generate_access_chain_start(HccCompiler* c, U32 count) {
	HccIROperand* operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_PTR_ACCESS_CHAIN, count + 3);
	operands[0] = hcc_irgen_value_add(c, HCC_DATA_TYPE_VOID);
	operands[1] = c->irgen.last_operand;

	c->irgen.last_operand = operands[0];
	return operands;
}

void hcc_irgen_generate_access_chain_end(HccCompiler* c, HccDataType data_type) {
	HccIRWord* last_instr = hcc_irgen_instruction_get_last(c);
	U32 operands_count = *last_instr >> 16;
	HccIROperand* operands = &last_instr[1];
	if (operands_count <= 3) {
		//
		// no accesses where generated so remove the access chain instruction and
		// return the original source of the access chain.
		hcc_irgen_instruction_remove_last(c, operands_count);
		c->irgen.last_operand = operands[1];
		return;
	}

	HccIRFunction* ir_function = c->irgen.ir_function;
	HccIRValue* value = hcc_stack_get(c->irgen.values, ir_function->values_start_idx + HCC_IR_OPERAND_VALUE_IDX(operands[0]));
	value->data_type = data_type;
	operands[2] = data_type;
}

void hcc_irgen_generate_access_chain_instruction(HccCompiler* c, HccExpr* expr, U32 count) {
	switch (expr->type) {
		case HCC_EXPR_TYPE_FIELD_ACCESS: {
			HccExpr* left_expr = expr - expr->binary.left_expr_rel_idx;
			if (
				c->irgen.function->shader_stage != HCC_FUNCTION_SHADER_STAGE_NONE &&
				left_expr->type == HCC_EXPR_TYPE_LOCAL_VARIABLE &&
				left_expr->variable.idx < c->irgen.function->params_count
			) {
#if HCC_DEBUG_ASSERTIONS
				if (c->irgen.do_not_load_variable) {
					HccString identifier_string = hcc_string_table_get(&c->string_table, c->irgen.function->identifier_string_id);
					HCC_ABORT(
						"internal error: the compiler should have stopped shader paramters from being assigned too in '%.*s'",
						(int)identifier_string.size, identifier_string.data
					);
				}
#endif // HCC_DEBUG_ASSERTIONS

				HccDataType data_type = hcc_typedef_resolve_and_strip_const_volatile(c, left_expr->data_type);
				switch (left_expr->variable.idx) {
					case 0: { // HccVertexInput, HccFragmentInput or HccComputeInput
						U32 field_idx = expr->binary.right_expr_rel_idx;
						c->irgen.last_operand = HCC_IR_OPERAND_SHADER_STAGE_INPUT_INIT(field_idx);
						break;
					};
					case 1: {
						switch (c->irgen.function->shader_stage) {
							case HCC_FUNCTION_SHADER_STAGE_FRAGMENT: {
								U32 field_idx = expr->binary.right_expr_rel_idx;
								c->irgen.last_operand = HCC_IR_OPERAND_RASTERIZER_STATE_INIT(field_idx);
								break;
							};
							default: HCC_UNREACHABLE();
						}
						break;
					};
					default: HCC_UNREACHABLE();
				}
				hcc_irgen_generate_access_chain_start(c, count);
				return;
			}

			U32 child_count = count + 1;
			HccDataType resolved_left_expr_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, left_expr->data_type);
			if (HCC_DATA_TYPE_IS_UNION(resolved_left_expr_data_type)) {
				child_count = 0;
			}
			hcc_irgen_generate_access_chain_instruction(c, left_expr, child_count);
			S32 field_idx = expr->binary.right_expr_rel_idx;

			if (HCC_DATA_TYPE_IS_UNION(resolved_left_expr_data_type)) {
				hcc_irgen_generate_access_chain_end(c, left_expr->data_type);
				hcc_irgen_generate_bitcast_union_field(c, left_expr->data_type, field_idx, c->irgen.last_operand);
				if (count != 0) {
					hcc_irgen_generate_access_chain_start(c, count);
				}
			} else {
				HccBasic basic = hcc_basic_from_sint(c, HCC_DATA_TYPE_SINT, field_idx);
				HccConstantId constant_id = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_SINT, &basic);
				*hcc_stack_get_back(c->irgen.words, count) = HCC_IR_OPERAND_CONSTANT_INIT(constant_id.idx_plus_one);
			}
			break;
		};
		case HCC_EXPR_TYPE_ARRAY_SUBSCRIPT: {
			HccExpr* right_expr = expr - expr->binary.right_expr_rel_idx;
			hcc_irgen_generate_instructions(c, right_expr);
			HccIROperand right_operand = c->irgen.last_operand;

			HccExpr* left_expr = expr - expr->binary.left_expr_rel_idx;
			hcc_irgen_generate_access_chain_instruction(c, left_expr, count + 1);

			*hcc_stack_get_back(c->irgen.words, count) = right_operand;
			break;
		};
		default: {
			c->irgen.do_not_load_variable = true;
			hcc_irgen_generate_instructions(c, expr);
			hcc_irgen_generate_access_chain_start(c, count);
			break;
		};
	}
}

void hcc_irgen_generate_instructions(HccCompiler* c, HccExpr* expr) {
	HccIROpCode op_code;
	switch (expr->type) {
		case HCC_EXPR_TYPE_STMT_BLOCK: {
			U32 stmts_count = expr->stmt_block.stmts_count;
			HccExpr* stmt = &expr[expr->stmt_block.first_expr_rel_idx];
			for (U32 i = 0; i < stmts_count; i += 1) {
				hcc_irgen_generate_instructions(c, stmt);
				stmt = &stmt[stmt->next_expr_rel_idx];
			}

			break;
		};
		case HCC_EXPR_TYPE_STMT_RETURN: {
			HccExpr* unary_expr = expr - expr->unary.expr_rel_idx;
			c->irgen.do_not_load_variable = c->irgen.function->shader_stage == HCC_FUNCTION_SHADER_STAGE_VERTEX || c->irgen.function->shader_stage == HCC_FUNCTION_SHADER_STAGE_FRAGMENT;
			hcc_irgen_generate_instructions(c, unary_expr);

			HccIROperand* operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_FUNCTION_RETURN, 1);
			operands[0] = c->irgen.last_operand;
			break;
		};
		case HCC_EXPR_TYPE_UNARY_OP(PLUS): {
			HccExpr* unary_expr = expr - expr->unary.expr_rel_idx;
			hcc_irgen_generate_instructions(c, unary_expr);
			break;
		};
		case HCC_EXPR_TYPE_UNARY_OP(LOGICAL_NOT): op_code = HCC_IR_OP_CODE_UNARY_OP(LOGICAL_NOT); goto UNARY;
		case HCC_EXPR_TYPE_UNARY_OP(BIT_NOT): op_code = HCC_IR_OP_CODE_UNARY_OP(BIT_NOT); goto UNARY;
		case HCC_EXPR_TYPE_UNARY_OP(NEGATE): op_code = HCC_IR_OP_CODE_UNARY_OP(NEGATE); goto UNARY;
UNARY:
		{
			HccExpr* unary_expr = expr - expr->unary.expr_rel_idx;
			if (op_code == HCC_IR_OP_CODE_UNARY_OP(LOGICAL_NOT) && unary_expr->data_type != HCC_DATA_TYPE_BOOL) {
				hcc_irgen_generate_condition_expr(c, unary_expr, true);
				break;
			} else {
				hcc_irgen_generate_instructions(c, unary_expr);
			}

			HccIROperand* operands = hcc_irgen_instruction_add(c, op_code, 2);
			operands[0] = hcc_irgen_value_add(c, expr->data_type);
			operands[1] = c->irgen.last_operand;

			c->irgen.last_operand = operands[0];
			break;
		};
		case HCC_EXPR_TYPE_UNARY_OP(PRE_INCREMENT):
		case HCC_EXPR_TYPE_UNARY_OP(PRE_DECREMENT):
		case HCC_EXPR_TYPE_UNARY_OP(POST_INCREMENT):
		case HCC_EXPR_TYPE_UNARY_OP(POST_DECREMENT):
		{
			HccExpr* unary_expr = expr - expr->unary.expr_rel_idx;

			c->irgen.do_not_load_variable = true;
			hcc_irgen_generate_instructions(c, unary_expr);
			HccIROperand target_operand = c->irgen.last_operand;

			hcc_irgen_generate_instructions(c, unary_expr);
			HccIROperand value_operand = c->irgen.last_operand;

			HccIROpCode op_code;
			if (expr->type == HCC_EXPR_TYPE_UNARY_OP(PRE_INCREMENT) || expr->type == HCC_EXPR_TYPE_UNARY_OP(POST_INCREMENT)) {
				op_code = HCC_IR_OP_CODE_BINARY_OP(ADD);
			} else {
				op_code = HCC_IR_OP_CODE_BINARY_OP(SUBTRACT);
			}

			HccDataType resolved_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, expr->data_type);
			HCC_DEBUG_ASSERT(HCC_DATA_TYPE_IS_BASIC(resolved_data_type), "internal error: expected basic type");

			HccIROperand* operands = hcc_irgen_instruction_add(c, op_code, 3);
			operands[0] = hcc_irgen_value_add(c, resolved_data_type);
			operands[1] = value_operand;
			operands[2] = HCC_IR_OPERAND_CONSTANT_INIT(c->basic_type_one_constant_ids[resolved_data_type].idx_plus_one);
			hcc_irgen_generate_ptr_store(c, target_operand, operands[0]);

			if (expr->type == HCC_EXPR_TYPE_UNARY_OP(PRE_INCREMENT) || expr->type == HCC_EXPR_TYPE_UNARY_OP(PRE_DECREMENT)) {
				c->irgen.last_operand = operands[0];
			} else {
				c->irgen.last_operand = value_operand;
			}

			break;
		};
		case HCC_EXPR_TYPE_STMT_IF: {
			HccExpr* cond_expr = &expr[expr->if_.cond_expr_rel_idx];
			hcc_irgen_generate_condition_expr(c, cond_expr, false);
			HccIROperand cond_operand = c->irgen.last_operand;
			HccIROperand* selection_merge_operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_SELECTION_MERGE, 1);
			HccIROperand* cond_branch_operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_BRANCH_CONDITIONAL, 3);
			cond_branch_operands[0] = cond_operand;

			HccExpr* true_stmt = &expr[expr->if_.true_stmt_rel_idx];
			bool true_needs_branch = !hcc_stmt_has_return(true_stmt);
			HccIROperand true_basic_block_operand = hcc_irgen_basic_block_add(c);
			cond_branch_operands[1] = true_basic_block_operand;
			hcc_irgen_generate_instructions(c, true_stmt);

			HccIROperand* true_branch_operands;
			if (true_needs_branch) {
				true_branch_operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_BRANCH, 1);
			}

			HccIROperand* false_branch_operands;
			bool false_needs_branch;
			if (true_stmt->if_aux.false_stmt_rel_idx) {
				HccExpr* false_stmt = &true_stmt[true_stmt->if_aux.false_stmt_rel_idx];
				false_needs_branch = !hcc_stmt_has_return(false_stmt);
				HccIROperand false_basic_block_operand = hcc_irgen_basic_block_add(c);
				cond_branch_operands[2] = false_basic_block_operand;
				hcc_irgen_generate_instructions(c, false_stmt);

				if (false_needs_branch) {
					false_branch_operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_BRANCH, 1);
				}
			}

			HccIROperand converging_basic_block_operand = hcc_irgen_basic_block_add(c);
			selection_merge_operands[0] = converging_basic_block_operand;
			if (true_needs_branch) {
				true_branch_operands[0] = converging_basic_block_operand;
			}

			if (true_stmt->if_aux.false_stmt_rel_idx) {
				if (false_needs_branch) {
					false_branch_operands[0] = converging_basic_block_operand;
				}
			} else {
				cond_branch_operands[2] = converging_basic_block_operand;
			}

			if (!true_needs_branch && !false_needs_branch) {
				hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_UNREACHABLE, 0);
			}
			break;
		};
		case HCC_EXPR_TYPE_STMT_SWITCH: {
			HccExpr* block_stmt = &expr[expr->switch_.block_expr_rel_idx];
			if (block_stmt->switch_aux.first_case_expr_rel_idx == 0) {
				break;
			}

			HccIROperand* selection_merge_operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_SELECTION_MERGE, 1);
			U32 operands_count = 2 + block_stmt->switch_aux.case_stmts_count * 2;
			HccIROperand* operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_SWITCH, operands_count);

			HccExpr* cond_expr = &expr[expr->switch_.cond_expr_rel_idx];
			hcc_irgen_generate_instructions(c, cond_expr);
			operands[0] = c->irgen.last_operand;

			HccExpr* case_expr = &block_stmt[block_stmt->switch_aux.first_case_expr_rel_idx];
			U32 case_idx = 0;

			HccIRGenBranchState prev_branch_state = c->irgen.branch_state;
			c->irgen.branch_state.all_cases_return = true;
			c->irgen.branch_state.break_branch_linked_list_head = -1;
			c->irgen.branch_state.break_branch_linked_list_tail = -1;
			c->irgen.branch_state.continue_branch_linked_list_head = -1;
			c->irgen.branch_state.continue_branch_linked_list_tail = -1;
			while (1) {
				HccIROperand basic_block_operand = hcc_irgen_basic_block_add(c);
				operands[2 + (case_idx * 2) + 0] = HCC_IR_OPERAND_CONSTANT_INIT(case_expr->constant.id);
				operands[2 + (case_idx * 2) + 1] = basic_block_operand;
				if (case_expr->next_expr_rel_idx == 0) {
					break;
				}

				HccExpr* first_stmt = &case_expr[case_expr->next_expr_rel_idx];
				hcc_irgen_generate_case_instructions(c, first_stmt);

				if (case_expr->alt_next_expr_rel_idx == 0) {
					break;
				}
				case_expr = &case_expr[case_expr->alt_next_expr_rel_idx];
				case_idx += 1;
			}

			//HccIROperand* default_branch_operands;
			if (expr->alt_next_expr_rel_idx) {
				HccExpr* default_case_expr = &expr[expr->alt_next_expr_rel_idx];

				HccIROperand default_basic_block_operand = hcc_irgen_basic_block_add(c);
				HccExpr* first_stmt = &default_case_expr[1];
				hcc_irgen_generate_case_instructions(c, first_stmt);

				/*
				default_branch_operands = hcc_irgen_add_operands_many(c, 1);
				hcc_irgen_add_instruction(c, HCC_IR_OP_CODE_BRANCH, default_branch_operands, 1);
				*/

				operands[1] = default_basic_block_operand;
			}

			HccIROperand converging_basic_block_operand = hcc_irgen_basic_block_add(c);
			selection_merge_operands[0] = converging_basic_block_operand;
			if (expr->alt_next_expr_rel_idx) {
				//default_branch_operands[1] = converging_basic_block_operand;
			} else {
				operands[1] = converging_basic_block_operand;
			}

			if (c->irgen.branch_state.all_cases_return) {
				hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_UNREACHABLE, 0);
			}

			HccIRFunction* ir_function = c->irgen.ir_function;
			while (c->irgen.branch_state.break_branch_linked_list_head != (U32)-1) {
				U32 next = *hcc_stack_get(c->irgen.words, ir_function->words_start_idx + c->irgen.branch_state.break_branch_linked_list_head);
				*hcc_stack_get(c->irgen.words, ir_function->words_start_idx + c->irgen.branch_state.break_branch_linked_list_head) = converging_basic_block_operand;
				c->irgen.branch_state.break_branch_linked_list_head = next;
			}

			c->irgen.branch_state = prev_branch_state;

			break;
		};
		case HCC_EXPR_TYPE_STMT_WHILE:
		case HCC_EXPR_TYPE_STMT_FOR: {
			HccExpr* init_expr;
			HccExpr* cond_expr;
			HccExpr* inc_expr;
			HccExpr* loop_stmt;
			bool is_do_while;
			if (expr->type == HCC_EXPR_TYPE_STMT_FOR) {
				is_do_while = false;
				init_expr = &expr[expr->for_.init_expr_rel_idx];
				cond_expr = &expr[expr->for_.cond_expr_rel_idx];
				inc_expr = &expr[expr->for_.inc_expr_rel_idx];
				loop_stmt = &expr[expr->for_.loop_stmt_rel_idx];
			} else {
				is_do_while = expr->while_.cond_expr_rel_idx > expr->while_.loop_stmt_rel_idx;
				init_expr = NULL;
				cond_expr = &expr[expr->while_.cond_expr_rel_idx];
				inc_expr = NULL;
				loop_stmt = &expr[expr->while_.loop_stmt_rel_idx];
			}

			if (init_expr) {
				hcc_irgen_generate_instructions(c, init_expr);
			}

			HccIROperand* operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_BRANCH, 1);
			HccIROperand starting_basic_block_operand = hcc_irgen_basic_block_add(c);
			operands[0] = starting_basic_block_operand;

			HccIROperand cond_operand;
			if (!is_do_while) {
				hcc_irgen_generate_condition_expr(c, cond_expr, false);
				cond_operand = c->irgen.last_operand;
			}

			HccIROperand* loop_merge_operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_LOOP_MERGE, 2);
			HccIROperand* cond_branch_operands;
			if (is_do_while) {
				cond_branch_operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_BRANCH, 1);
			} else {
				cond_branch_operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_BRANCH_CONDITIONAL, 3);
				cond_branch_operands[0] = cond_operand;
			}

			HccIRGenBranchState prev_branch_state = c->irgen.branch_state;
			c->irgen.branch_state.break_branch_linked_list_head = -1;
			c->irgen.branch_state.break_branch_linked_list_tail = -1;
			c->irgen.branch_state.continue_branch_linked_list_head = -1;
			c->irgen.branch_state.continue_branch_linked_list_tail = -1;

			HccIROperand loop_basic_block_operand = hcc_irgen_basic_block_add(c);
			hcc_irgen_generate_instructions(c, loop_stmt);
			cond_branch_operands[is_do_while ? 0 : 1] = loop_basic_block_operand;

			HccIROpCode last_op_code = hcc_irgen_instruction_get_last_op_code(c);
			HccIROperand* loop_branch_operands = NULL;
			if (last_op_code != HCC_IR_OP_CODE_BRANCH && last_op_code != HCC_IR_OP_CODE_FUNCTION_RETURN) {
				loop_merge_operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_BRANCH, 1);
			}

			HccIROperand continue_basic_block_operand = hcc_irgen_basic_block_add(c);
			if (loop_branch_operands) {
				loop_branch_operands[0] = continue_basic_block_operand;
			}
			loop_merge_operands[1] = continue_basic_block_operand;
			if (inc_expr) {
				hcc_irgen_generate_instructions(c, inc_expr);
			}

			if (is_do_while) {
				hcc_irgen_generate_condition_expr(c, cond_expr, false);
				cond_operand = c->irgen.last_operand;

				cond_branch_operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_BRANCH_CONDITIONAL, 3);
				cond_branch_operands[0] = cond_operand;
				cond_branch_operands[1] = starting_basic_block_operand;
			} else {
				operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_BRANCH, 1);
				operands[0] = starting_basic_block_operand;
			}

			HccIROperand converging_basic_block_operand = hcc_irgen_basic_block_add(c);
			cond_branch_operands[2] = converging_basic_block_operand;
			loop_merge_operands[0] = converging_basic_block_operand;

			HccIRFunction* ir_function = c->irgen.ir_function;
			while (c->irgen.branch_state.break_branch_linked_list_head != (U32)-1) {
				U32 next = *hcc_stack_get(c->irgen.words, ir_function->words_start_idx + c->irgen.branch_state.break_branch_linked_list_head);
				*hcc_stack_get(c->irgen.words, ir_function->words_start_idx + c->irgen.branch_state.break_branch_linked_list_head) = converging_basic_block_operand;
				c->irgen.branch_state.break_branch_linked_list_head = next;
			}

			while (c->irgen.branch_state.continue_branch_linked_list_head != (U32)-1) {
				U32 next = *hcc_stack_get(c->irgen.words, ir_function->words_start_idx + c->irgen.branch_state.continue_branch_linked_list_head);
				*hcc_stack_get(c->irgen.words, ir_function->words_start_idx + c->irgen.branch_state.continue_branch_linked_list_head) = continue_basic_block_operand;
				c->irgen.branch_state.continue_branch_linked_list_head = next;
			}

			c->irgen.branch_state = prev_branch_state;
			break;
		};
		case HCC_EXPR_TYPE_BINARY_OP(ASSIGN):
		{
			HccExpr* left_expr = expr - expr->binary.left_expr_rel_idx;
			HccExpr* right_expr = expr - expr->binary.right_expr_rel_idx;

			c->irgen.do_not_load_variable = true;
			hcc_irgen_generate_instructions(c, left_expr);
			HccIROperand left_operand = c->irgen.last_operand;

			HccFunction* function = c->irgen.function;
			HccIRFunction* ir_function = c->irgen.ir_function;
			c->irgen.assign_data_type = hcc_irgen_operand_data_type(c, function, ir_function, left_operand);
			hcc_irgen_generate_instructions(c, right_expr);
			HccIROperand right_operand = c->irgen.last_operand;

			hcc_irgen_generate_ptr_store(c, left_operand, right_operand);
			c->irgen.last_operand = left_operand;
			break;
		};
		case HCC_EXPR_TYPE_BINARY_OP(ADD):
		case HCC_EXPR_TYPE_BINARY_OP(SUBTRACT):
		case HCC_EXPR_TYPE_BINARY_OP(MULTIPLY):
		case HCC_EXPR_TYPE_BINARY_OP(DIVIDE):
		case HCC_EXPR_TYPE_BINARY_OP(MODULO):
		case HCC_EXPR_TYPE_BINARY_OP(BIT_AND):
		case HCC_EXPR_TYPE_BINARY_OP(BIT_OR):
		case HCC_EXPR_TYPE_BINARY_OP(BIT_XOR):
		case HCC_EXPR_TYPE_BINARY_OP(BIT_SHIFT_LEFT):
		case HCC_EXPR_TYPE_BINARY_OP(BIT_SHIFT_RIGHT):
		case HCC_EXPR_TYPE_BINARY_OP(EQUAL):
		case HCC_EXPR_TYPE_BINARY_OP(NOT_EQUAL):
		case HCC_EXPR_TYPE_BINARY_OP(LESS_THAN):
		case HCC_EXPR_TYPE_BINARY_OP(LESS_THAN_OR_EQUAL):
		case HCC_EXPR_TYPE_BINARY_OP(GREATER_THAN):
		case HCC_EXPR_TYPE_BINARY_OP(GREATER_THAN_OR_EQUAL):
		{
			HccExpr* left_expr = expr - expr->binary.left_expr_rel_idx;
			HccExpr* right_expr = expr - expr->binary.right_expr_rel_idx;
			HccIROpCode op_code = HCC_IR_OP_CODE_BINARY_OP_START + (expr->type - HCC_EXPR_TYPE_BINARY_OP_START);

			HccDataType data_type;
			if (expr->binary.is_assignment) {
				data_type = left_expr->data_type;
			} else {
				data_type = expr->data_type;
			}

			hcc_irgen_generate_instructions(c, left_expr);
			HccIROperand operand_a = c->irgen.last_operand;

			hcc_irgen_generate_instructions(c, right_expr);
			HccIROperand operand_b = c->irgen.last_operand;

			HccIROperand* operands = hcc_irgen_instruction_add(c, op_code, 3);
			operands[0] = hcc_irgen_value_add(c, data_type);
			operands[1] = operand_a;
			operands[2] = operand_b;

			if (expr->binary.is_assignment) {
				HccIROperand dst_operand;
				if (left_expr->type == HCC_EXPR_TYPE_LOCAL_VARIABLE) {
					dst_operand = hcc_irgen_value_ptr_for_param_or_local_variable(c, left_expr->variable.idx);
				} else if (left_expr->type == HCC_EXPR_TYPE_GLOBAL_VARIABLE) {
					dst_operand = HCC_IR_OPERAND_GLOBAL_VARIABLE_INIT(left_expr->variable.idx);
				} else {
					dst_operand = operands[1];
				}

				hcc_irgen_generate_ptr_store(c, dst_operand, operands[0]);
			}

			c->irgen.last_operand = operands[0];
			break;
		};
		case HCC_EXPR_TYPE_BINARY_OP(LOGICAL_AND):
		case HCC_EXPR_TYPE_BINARY_OP(LOGICAL_OR):
		{
			HccExpr* left_expr = expr - expr->binary.left_expr_rel_idx;
			HccExpr* right_expr = expr - expr->binary.right_expr_rel_idx;

			HccIROperand starting_basic_block_operand = c->irgen.basic_block_operand;

			hcc_irgen_generate_condition_expr(c, left_expr, false);
			HccIROperand cond_operand = c->irgen.last_operand;

			HccIROperand* selection_merge_operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_SELECTION_MERGE, 1);
			HccIROperand* cond_branch_operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_BRANCH_CONDITIONAL, 3);
			cond_branch_operands[0] = cond_operand;
			U32 success_idx = expr->type != HCC_EXPR_TYPE_BINARY_OP(LOGICAL_AND);
			U32 converging_idx = expr->type == HCC_EXPR_TYPE_BINARY_OP(LOGICAL_AND);

			HccIROperand success_basic_block_operand = hcc_irgen_basic_block_add(c);
			cond_branch_operands[1 + success_idx] = success_basic_block_operand;

			hcc_irgen_generate_condition_expr(c, right_expr, false);
			HccIROperand success_cond_operand = c->irgen.last_operand;

			HccIROperand* success_branch_operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_BRANCH, 1);
			HccIROperand converging_basic_block_operand = hcc_irgen_basic_block_add(c);
			selection_merge_operands[0] = converging_basic_block_operand;
			success_branch_operands[0] = converging_basic_block_operand;
			cond_branch_operands[1 + converging_idx] = converging_basic_block_operand;

			HccFunction* function = c->irgen.function;
			HccIRFunction* ir_function = c->irgen.ir_function;
			HccIROperand* phi_operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_PHI, 5);
			phi_operands[0] = hcc_irgen_value_add(c, hcc_irgen_operand_data_type(c, function, ir_function, cond_operand));
			phi_operands[1] = cond_operand;
			phi_operands[2] = starting_basic_block_operand;
			phi_operands[3] = success_cond_operand;
			phi_operands[4] = success_basic_block_operand;

			c->irgen.last_operand = phi_operands[0];
			break;
		};
		case HCC_EXPR_TYPE_BINARY_OP(COMMA): {
			HccExpr* left_expr = expr - expr->binary.left_expr_rel_idx;
			HccExpr* right_expr = expr - expr->binary.right_expr_rel_idx;
			hcc_irgen_generate_instructions(c, left_expr);
			hcc_irgen_generate_instructions(c, right_expr);
			break;
		};
		case HCC_EXPR_TYPE_CALL: {
			HccExpr* called_function_expr = expr - expr->binary.left_expr_rel_idx;
			HccExpr* call_args_expr = expr - expr->binary.right_expr_rel_idx;
			HCC_DEBUG_ASSERT(called_function_expr->type == HCC_EXPR_TYPE_FUNCTION, "expected an function expression");
			HCC_DEBUG_ASSERT(call_args_expr->type == HCC_EXPR_TYPE_CALL_ARG_LIST, "expected call argument list expression");

			HccFunction* called_function = hcc_stack_get(c->astgen.functions, called_function_expr->function.idx);
			HccExpr* arg_expr = call_args_expr;
			U32 args_count = ((U8*)call_args_expr)[1];
			U8* next_arg_expr_rel_indices = &((U8*)call_args_expr)[2];

			HccIROperand arg_operands[HCC_FUNCTION_MAX_PARAMS_COUNT];
			for (U32 arg_idx = 0; arg_idx < args_count; arg_idx += 1) {
				arg_expr = &arg_expr[next_arg_expr_rel_indices[arg_idx]];
				hcc_irgen_generate_instructions(c, arg_expr);
				arg_operands[arg_idx] = c->irgen.last_operand;
			}

			HccIROperand* operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_FUNCTION_CALL, args_count + 2);
			operands[0] = hcc_irgen_value_add(c, called_function->return_data_type);
			operands[1] = HCC_IR_OPERAND_FUNCTION_INIT(called_function_expr->function.idx); // TODO function pointer support
			for (U32 arg_idx = 0; arg_idx < args_count; arg_idx += 1) {
				operands[arg_idx + 2] = arg_operands[arg_idx];
			}

			c->irgen.last_operand = operands[0];
			break;
		};
		case HCC_EXPR_TYPE_FIELD_ACCESS:
		case HCC_EXPR_TYPE_ARRAY_SUBSCRIPT:
		{
			bool do_load = !c->irgen.do_not_load_variable;
			c->irgen.do_not_load_variable = false;

			hcc_irgen_generate_access_chain_instruction(c, expr, 0);
			if (hcc_irgen_instruction_get_last_op_code(c) == HCC_IR_OP_CODE_PTR_ACCESS_CHAIN) {
				hcc_irgen_generate_access_chain_end(c, expr->data_type);
			}

			if (do_load) {
				hcc_irgen_generate_ptr_load(c, expr->data_type, c->irgen.last_operand);
			}
			break;
		};
		case HCC_EXPR_TYPE_CURLY_INITIALIZER: {
			HccExpr* variable_expr = &expr[expr->curly_initializer.first_expr_rel_idx];
			HCC_DEBUG_ASSERT(variable_expr->type == HCC_EXPR_TYPE_LOCAL_VARIABLE, "internal error: expected the first node of the compound literal to be the hidden variable expression that we can mutate");
			HccIROperand variable_operand = hcc_irgen_value_ptr_for_param_or_local_variable(c, variable_expr->variable.idx);

			//
			// store a zeroed value in the hidden local variable where the compound data type gets constructed
			HccConstantId zeroed_constant_id = hcc_constant_table_deduplicate_zero(c, expr->data_type);
			hcc_irgen_generate_ptr_store(c, variable_operand, HCC_IR_OPERAND_CONSTANT_INIT(zeroed_constant_id.idx_plus_one));

			HccExpr* initializer_expr = variable_expr;
			while (1) {
				U32 expr_rel_idx = initializer_expr->next_expr_rel_idx;
				if (expr_rel_idx == 0) {
					break;
				}
				initializer_expr = &initializer_expr[expr_rel_idx];

				HCC_DEBUG_ASSERT(initializer_expr->type == HCC_EXPR_TYPE_DESIGNATED_INITIALIZER, "internal error: expected a designated initializer");

				c->irgen.last_operand = variable_operand;

				HccIROperand dst_operand;
				HccDataType data_type = expr->data_type;
				{
					HccAstGenDesignatorInitializer* di = &c->astgen.curly_initializer.designated_initializers[initializer_expr->alt_next_expr_rel_idx];
					U64* elmt_indices = hcc_stack_get(c->astgen.curly_initializer.designated_initializer_elmt_indices, di->elmt_indices_start_idx);

					HccIROperand* operands = hcc_irgen_generate_access_chain_start(c, di->elmt_indices_count);
					U32 operand_idx = 3;
					for (U32 elmt_indices_idx = 0; elmt_indices_idx < di->elmt_indices_count; elmt_indices_idx += 1) {
						data_type = hcc_typedef_resolve_and_strip_const_volatile(c, data_type);
						U64 entry_idx = elmt_indices[elmt_indices_idx];

						if (HCC_DATA_TYPE_IS_UNION(data_type)) {
							hcc_irgen_instruction_shrink_last_operands_count(c, operand_idx);
							hcc_irgen_generate_access_chain_end(c, data_type);
							hcc_irgen_generate_bitcast_union_field(c, data_type, entry_idx, c->irgen.last_operand);
							if (elmt_indices_idx + 1 < di->elmt_indices_count) {
								operands = hcc_irgen_generate_access_chain_start(c, di->elmt_indices_count - elmt_indices_idx);
								operand_idx = 3;
							}
						} else {
							HccBasic TODO_int_64_support_plz = hcc_basic_from_uint(c, HCC_DATA_TYPE_UINT, entry_idx);
							HccConstantId entry_constant_id = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_UINT, &TODO_int_64_support_plz);
							operands[operand_idx] = HCC_IR_OPERAND_CONSTANT_INIT(entry_constant_id.idx_plus_one);
							operand_idx += 1;
						}

						if (HCC_DATA_TYPE_IS_ARRAY(data_type)) {
							HccArrayDataType* array_data_type = hcc_array_data_type_get(c, data_type);
							data_type = array_data_type->element_data_type;
						} else if (HCC_DATA_TYPE_IS_COMPOUND_TYPE(data_type)) {
							HccCompoundDataType* compound_data_type = hcc_compound_data_type_get(c, data_type);
							HccCompoundField* field = &c->astgen.compound_fields[compound_data_type->fields_start_idx + entry_idx];
							data_type = field->data_type;
						}
					}

					if (hcc_irgen_instruction_get_last_op_code(c) == HCC_IR_OP_CODE_PTR_ACCESS_CHAIN) {
						hcc_irgen_instruction_shrink_last_operands_count(c, operand_idx);
						hcc_irgen_generate_access_chain_end(c, data_type);
					}

					dst_operand = c->irgen.last_operand;
				}


				HccIROperand value_operand;
				if (initializer_expr->designated_initializer.value_expr_rel_idx) {
					HccExpr* value_expr = initializer_expr - initializer_expr->designated_initializer.value_expr_rel_idx;
					hcc_irgen_generate_instructions(c, value_expr);
					value_operand = c->irgen.last_operand;
				} else {
					HccConstantId zeroed_constant_id = hcc_constant_table_deduplicate_zero(c, data_type);
					value_operand = HCC_IR_OPERAND_CONSTANT_INIT(zeroed_constant_id.idx_plus_one);
				}

				hcc_irgen_generate_ptr_store(c, dst_operand, value_operand);
			}

			hcc_irgen_generate_ptr_load(c, expr->data_type, variable_operand);
			break;
		};
		case HCC_EXPR_TYPE_CAST: {
			HccExpr* unary_expr = expr - expr->unary.expr_rel_idx;
			hcc_irgen_generate_instructions(c, unary_expr);

			if (hcc_data_type_is_same_underlaying_type(c, expr->data_type, unary_expr->data_type)) {
				break;
			}

			if (hcc_data_type_is_same_bitwidth_int(c, expr->data_type, unary_expr->data_type)) {
				hcc_irgen_generate_bitcast(c, expr->data_type, c->irgen.last_operand, false);
				break;
			}

			HccBasicTypeClass dst_type_class = hcc_basic_type_class(c, expr->data_type);
			if (dst_type_class == HCC_BASIC_TYPE_CLASS_BOOL) {
				hcc_irgen_generate_convert_to_bool(c, c->irgen.last_operand, false);
			} else {
				HccIROperand* operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_CONVERT, 3);
				operands[0] = hcc_irgen_value_add(c, expr->data_type);
				operands[1] = expr->data_type;
				operands[2] = c->irgen.last_operand;

				c->irgen.last_operand = operands[0];
			}
			break;
		};
		case HCC_EXPR_TYPE_CONSTANT: {
			c->irgen.last_operand = HCC_IR_OPERAND_CONSTANT_INIT(expr->constant.id);
			break;
		};
		case HCC_EXPR_TYPE_STMT_BREAK: {
			HccIROperand* operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_BRANCH, 1);
			operands[0] = -1; // the operand is initialized later by the callee

			HccIRFunction* ir_function = c->irgen.ir_function;
			if (c->irgen.branch_state.break_branch_linked_list_tail == (U32)-1) {
				c->irgen.branch_state.break_branch_linked_list_head = ir_function->words_count - 1;
			} else {
				*hcc_stack_get(c->irgen.words, ir_function->words_start_idx + c->irgen.branch_state.break_branch_linked_list_tail) = ir_function->words_count - 1;
			}
			c->irgen.branch_state.break_branch_linked_list_tail = ir_function->words_count - 1;

			if (expr->next_expr_rel_idx) {
				hcc_irgen_basic_block_add(c);
			}

			break;
		};
		case HCC_EXPR_TYPE_STMT_CONTINUE: {
			HccIROperand* operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_BRANCH, 1);
			operands[0] = -1; // the operand is initialized later by the callee

			HccIRFunction* ir_function = c->irgen.ir_function;
			if (c->irgen.branch_state.continue_branch_linked_list_tail == (U32)-1) {
				c->irgen.branch_state.continue_branch_linked_list_head = ir_function->words_count - 1;
			} else {
				*hcc_stack_get(c->irgen.words, ir_function->words_start_idx + c->irgen.branch_state.continue_branch_linked_list_tail) = ir_function->words_count - 1;
			}
			c->irgen.branch_state.continue_branch_linked_list_tail = ir_function->words_count - 1;

			if (expr->next_expr_rel_idx) {
				hcc_irgen_basic_block_add(c);
			}

			break;
		};
		case HCC_EXPR_TYPE_STMT_CASE:
		case HCC_EXPR_TYPE_STMT_DEFAULT: {
			//
			// 'case' and 'default' will get found when hcc_irgen_generate_case_instructions
			// is processing the statements of a 'case' and 'default' block.
			// they will implicitly fallthrough to this next 'case' and 'default' block
			// so make the next operand reference the next basic block index that will get made.
			HccIROperand* operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_BRANCH, 1);
			HccIRFunction* ir_function = c->irgen.ir_function;
			operands[0] = HCC_IR_OPERAND_VALUE_INIT(ir_function->values_count);
			break;
		};
		case HCC_EXPR_TYPE_LOCAL_VARIABLE: {
			if (c->irgen.do_not_load_variable) {
				c->irgen.last_operand = hcc_irgen_value_ptr_for_param_or_local_variable(c, expr->variable.idx);
				c->irgen.do_not_load_variable = false;
			} else {
				U32 function_idx = hcc_stack_count(c->irgen.functions) - 1;
				HccVariable* variable = hcc_stack_get(c->astgen.function_params_and_variables, c->irgen.function->params_start_idx + expr->variable.idx);
				if (
					c->irgen.function->shader_stage != HCC_FUNCTION_SHADER_STAGE_NONE &&
					expr->variable.idx < c->irgen.function->params_count
				) {
					//
					// this code is only for when taking a full copy of HccVertexInput, HccFragmentInput, HccComputeInput etc.
					//

					HccIROperand operand_kind;
					switch (expr->variable.idx) {
						case 0: operand_kind = HCC_IR_OPERAND_SHADER_STAGE_INPUT; break;
						case 1: {
							switch (c->irgen.function->shader_stage) {
								case HCC_FUNCTION_SHADER_STAGE_FRAGMENT:
									operand_kind = HCC_IR_OPERAND_RASTERIZER_STATE;
									break;
								default: HCC_UNREACHABLE();
							}

							break;
						};
						default: HCC_UNREACHABLE();
					}

					HccDataType data_type = hcc_typedef_resolve_and_strip_const_volatile(c, variable->data_type);
					HccCompoundDataType* compound_data_type = hcc_compound_data_type_get(c, data_type);
					HccIROperand field_operands[HCC_INTRINSIC_STRUCT_FIELDS_CAP];

					for (U32 field_idx = 0; field_idx < compound_data_type->fields_count; field_idx += 1) {
						HccCompoundField* field = &c->astgen.compound_fields[compound_data_type->fields_start_idx + field_idx];
						hcc_irgen_generate_ptr_load(c, field->data_type, HCC_IR_OPERAND_INIT(operand_kind, field_idx));
						field_operands[field_idx] = c->irgen.last_operand;
					}

					HccIROperand* operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_COMPOSITE_INIT, compound_data_type->fields_count + 1);
					operands[0] = hcc_irgen_value_add(c, data_type);
					for (U32 field_idx = 0; field_idx < compound_data_type->fields_count; field_idx += 1) {
						operands[field_idx + 1] = field_operands[field_idx];
					}

					c->irgen.last_operand = operands[0];
				} else {
					hcc_irgen_generate_ptr_load(c, variable->data_type, hcc_irgen_value_ptr_for_param_or_local_variable(c, expr->variable.idx));
				}
			}
			break;
		};
		case HCC_EXPR_TYPE_GLOBAL_VARIABLE: {
			if (c->irgen.do_not_load_variable) {
				c->irgen.last_operand = HCC_IR_OPERAND_GLOBAL_VARIABLE_INIT(expr->variable.idx);
				c->irgen.do_not_load_variable = false;
			} else {
				HccVariable* variable = &c->astgen.global_variables[expr->variable.idx];
				hcc_irgen_generate_ptr_load(c, variable->data_type, HCC_IR_OPERAND_GLOBAL_VARIABLE_INIT(expr->variable.idx));
			}
			break;
		};
		case HCC_EXPR_TYPE_BINARY_OP(TERNARY): {
			HccExpr* cond_expr = expr - expr->ternary.cond_expr_rel_idx;
			hcc_irgen_generate_condition_expr(c, cond_expr, false);
			HccIROperand cond_operand = c->irgen.last_operand;

			HccExpr* true_expr = expr - expr->ternary.true_expr_rel_idx;
			hcc_irgen_generate_instructions(c, true_expr);
			HccIROperand true_operand = c->irgen.last_operand;

			HccExpr* false_expr = expr - expr->ternary.false_expr_rel_idx;
			hcc_irgen_generate_instructions(c, false_expr);
			HccIROperand false_operand = c->irgen.last_operand;

			HccIROperand* operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_SELECT, 4);
			operands[0] = hcc_irgen_value_add(c, expr->data_type);
			operands[1] = cond_operand;
			operands[2] = true_operand;
			operands[3] = false_operand;

			c->irgen.last_operand = operands[0];
			break;
		};
		default:
			HCC_ABORT("unhandled expr type %u\n", expr->type);
	}
}

void hcc_irgen_setup_function(HccCompiler* c, HccIRFunction* ir_function, HccFunction* function) {
	ir_function->values_start_idx = hcc_stack_count(c->irgen.values);
	ir_function->values_count = 0;
	ir_function->words_start_idx = hcc_stack_count(c->irgen.words);
	ir_function->words_count = 0;
	ir_function->basic_blocks_start_idx = hcc_stack_count(c->irgen.basic_block_words_start_indices);
	ir_function->basic_blocks_count = 0;
	ir_function->params_count = function->params_count;
	ir_function->instructions_count = 0;
}

void hcc_irgen_generate_function(HccCompiler* c, U32 function_idx) {
	HccFunction* function = hcc_stack_get(c->astgen.functions, function_idx);
	HccIRFunction* ir_function = hcc_stack_get(c->irgen.functions, function_idx);
	hcc_irgen_setup_function(c, ir_function, function);
	hcc_irgen_basic_block_add(c);

	//
	// reserve the first lot of SSA values for parameters
	for (U32 param_idx = 0; param_idx < function->params_count; param_idx += 1) {
		HccVariable* param = hcc_stack_get(c->astgen.function_params_and_variables, function->params_start_idx + param_idx);
		HccDataType data_type = hcc_typedef_resolve_and_strip_const_volatile(c, param->data_type);
		hcc_irgen_value_add(c, data_type);
	}

	//
	// reserve the next lot of SSA values for pointers to local variables.
	// these help make generating IR a lot easier, we can avoid tracking variables in different blocks
	// and converging them with a PHI instruction. instead we just mutate a value at a pointer.
	// later an optimization will convert these into SSA values that use PHI instructions.
	for (U32 variable_idx = 0; variable_idx < function->variables_count; variable_idx += 1) {
		HccVariable* variable = hcc_stack_get(c->astgen.function_params_and_variables, function->params_start_idx + variable_idx);
		HccDataType data_type = hcc_typedef_resolve_and_strip_const_volatile(c, variable->data_type);
		HccIROperand* operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_PTR_STATIC_ALLOC, 2);
		operands[0] = hcc_irgen_value_add(c, data_type);
		operands[1] = data_type;
	}

	//
	// now store the parameters to the function in it's local variable counter part
	for (U32 param_idx = 0; param_idx < function->params_count; param_idx += 1) {
		HccVariable* param = hcc_stack_get(c->astgen.function_params_and_variables, function->params_start_idx + param_idx);
		HccIROperand* operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_PTR_STORE, 2);
		operands[0] = hcc_irgen_value_ptr_for_param_or_local_variable(c, param_idx);
		operands[1] = hcc_irgen_value_for_param(param_idx);
	}

	HCC_DEBUG_ASSERT(function->block_expr_id.idx_plus_one, "expected to have a function body");

	c->irgen.function = function;
	c->irgen.ir_function = ir_function;
	HccExpr* expr = hcc_stack_get(c->astgen.exprs, function->block_expr_id.idx_plus_one - 1);
	hcc_irgen_generate_instructions(c, expr);
}

void hcc_irgen_generate(HccCompiler* c) {
	hcc_stack_resize(c->irgen.functions, hcc_stack_count(c->astgen.functions));
	for (U32 used_function_idx = 0; used_function_idx < hcc_stack_count(c->astgen.used_function_indices); used_function_idx += 1) {
		U32 function_idx = c->astgen.used_function_indices[used_function_idx];
		hcc_irgen_generate_function(c, function_idx);
	}
}

// ===========================================
//
//
// IR Optimization
//
//
// ===========================================

void hcc_iropt_run(HccCompiler* c) {
	HccIRFunction* new_ir_function = &c->iropt.new_ir_function;
	c->irgen.ir_function = new_ir_function;

	for (U32 used_function_idx = 0; used_function_idx < hcc_stack_count(c->astgen.used_function_indices); used_function_idx += 1) {
		U32 function_idx = c->astgen.used_function_indices[used_function_idx];
		HccFunction* function = hcc_stack_get(c->astgen.functions, function_idx);
		HccIRFunction* ir_function = hcc_stack_get(c->irgen.functions, function_idx);
		c->irgen.function = function;
		c->irgen.ir_function = new_ir_function;
		c->iropt.ir_function = ir_function;

		for (U32 idx = 0; idx < hcc_stack_count(c->iropt.tasks); idx += 1) {
			HccIROptTaskFn task = *hcc_stack_get(c->iropt.tasks, idx);
			hcc_irgen_setup_function(c, new_ir_function, function);
			hcc_stack_clear(c->iropt.value_indices_remap);
			if (task(c)) {
				*ir_function = *new_ir_function;
			}
		}
	}
}

HccIROperand hcc_iropt_remap_value(HccCompiler* c, HccIROperand value_operand) {
	U32 value_idx = HCC_IR_OPERAND_VALUE_IDX(value_operand);
	value_idx = *hcc_stack_get(c->iropt.value_indices_remap, value_idx);
	return HCC_IR_OPERAND_VALUE_INIT(value_idx);
}

void hcc_iropt_keep_instr(HccCompiler* c, HccIRInstr* instr) {
	HccIROpCode op_code = hcc_irgen_instruction_op_code(instr);
	HccIROperand* operands = hcc_irgen_instruction_operands(instr);
	U32 operands_count = hcc_irgen_instruction_operands_count(instr);

	if (hcc_ir_op_code_has_return_value(op_code)) {
		//
		// we create a return value register here, so copy it to the
		// new ir function and create the remap entry for it.
		U32 value_idx = HCC_IR_OPERAND_VALUE_IDX(operands[0]);
		if (value_idx >= hcc_stack_count(c->iropt.value_indices_remap)) {
			hcc_stack_resize(c->iropt.value_indices_remap, value_idx);
		}
		HccIROperand value_operand = hcc_iropt_copy_value(c, c->iropt.ir_function, value_idx);
		*hcc_stack_get(c->iropt.value_indices_remap, value_idx) = HCC_IR_OPERAND_VALUE_IDX(value_operand);
	}

	//
	// copy instruction and it's operands while remap the value registers
	HccIROperand* new_operands = hcc_irgen_instruction_add(c, op_code, operands_count);
	for (U32 operand_idx = 0; operand_idx < operands_count; operand_idx += 1) {
		HccIROperand operand = operands[operand_idx];
		switch (operand & 0xff) {
			case HCC_IR_OPERAND_VALUE: {
				operand = hcc_iropt_remap_value(c, operand);
				break;
			};

		}
		new_operands[operand_idx] = operand;
	}
}

HccIROperand hcc_iropt_copy_value(HccCompiler* c, HccIRFunction* ir_function, U32 value_idx) {
	HccIRValue* value = hcc_ir_function_value(c, ir_function, value_idx);
	return hcc_irgen_value_add(c, value->data_type);
}

bool hcc_iropt_task_inline_functions(HccCompiler* c) {
	HccStack(U16) call_instr_word_indices = hcc_stack_init(U16, 16 * 1024, 0);

	//
	// find all of the function call instructions that can be inlined
	HccIRInstrEntry entry;
	HccIRInstrIter iter = hcc_ir_instr_iter_init(c, c->iropt.ir_function);
	while (hcc_ir_instr_iter_next(&iter, &entry)) {
		if (entry.op_code != HCC_IR_OP_CODE_FUNCTION_CALL) {
			continue;
		}

		U32 called_function_idx = HCC_IR_OPERAND_FUNCTION_IDX(entry.operands[1]);
		if (called_function_idx < HCC_FUNCTION_IDX_INTRINSIC_END) {
			// skip intrinsic functions as they are inlined manually in the backend
			// by swapping them out for special instructions.
			continue;
		}

		HccFunction* called_function = hcc_stack_get(c->astgen.functions, called_function_idx);
		if (!(called_function->flags & HCC_FUNCTION_FLAGS_INLINE)) {
			continue;
		}

		HccIRFunction* called_ir_function = hcc_stack_get(c->irgen.functions, called_function_idx);
		U32 call_instr_word_idx = hcc_ir_instr_iter_word_idx(&iter);
		*hcc_stack_push(call_instr_word_indices) = call_instr_word_idx;
	}

	//
	// nothing to inline so return early
	if (hcc_stack_count(call_instr_word_indices) == 0) {
		return false;
	}

	U32 next_call_instr_idx = 0;
	U32 next_call_instr_word_idx = *hcc_stack_get(call_instr_word_indices, next_call_instr_idx);
	next_call_instr_idx += 1;

	iter = hcc_ir_instr_iter_init(c, c->iropt.ir_function);
	while (hcc_ir_instr_iter_next(&iter, &entry)) {
		if (entry.instr_word_idx != next_call_instr_word_idx) {
			//
			// we are not at one of the function call instructions we want to inline,
			// so copy this instruction to the new instruction stream and do any conversion.
			hcc_iropt_keep_instr(c, &entry.operands[-1]);
			continue;
		}

		HccIRInstr* next_instr = hcc_ir_instr_iter_peek_next(&iter);
		bool needs_return_basic_block = true;
		if (next_instr && hcc_irgen_instruction_op_code(next_instr) == HCC_IR_OP_CODE_BASIC_BLOCK) {
			needs_return_basic_block = false;
		}

		U32 called_function_idx = HCC_IR_OPERAND_FUNCTION_IDX(entry.operands[1]);
		HccFunction* called_function = hcc_stack_get(c->astgen.functions, called_function_idx);
		HccIRFunction* called_ir_function = hcc_stack_get(c->irgen.functions, called_function_idx);

		HccIROperand return_variable_operand;
		HccDataType return_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, called_function->return_data_type);
		bool has_return_value = return_data_type != HCC_DATA_TYPE_VOID;
		if (has_return_value) {
			return_variable_operand = hcc_irgen_value_add(c, return_data_type);
			HccIROperand* operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_PTR_STATIC_ALLOC, 2);
			operands[0] = return_variable_operand;
			operands[1] = return_data_type;
		}

		// target the basic block that is reused or created after the called function has been inlined
		HccIRFunction* ir_function = c->iropt.ir_function;
		HccIRFunction* new_ir_function = &c->iropt.new_ir_function;

		//
		// its okay that we underflow here since it is being applied to a U32
		S32 called_operand_value_idx_offset = new_ir_function->values_count - called_ir_function->params_count;
		HccIROperand return_basic_block_operand = HCC_IR_OPERAND_VALUE_IDX(new_ir_function->values_count + called_ir_function->values_count - called_ir_function->params_count);

		//
		// copy the instructions from the function we are inlining
		HccIRInstrIter called_iter = hcc_ir_instr_iter_init(c, called_ir_function);
		HccIRInstrEntry called_entry;
		while (hcc_ir_instr_iter_next(&called_iter, &called_entry)) {
			if (called_entry.op_code == HCC_IR_OP_CODE_FUNCTION_RETURN) {
				//
				// replace return instruction with a store and a branch
				//

				if (has_return_value) {
					//
					// store the return value in the return value variable.
					HccIROperand value_operand = called_entry.operands[0];
					hcc_irgen_generate_ptr_store(c, return_variable_operand, value_operand);
				}

				//
				// branch to the end of where the function is inlined.
				HccIROperand* dst_operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_BRANCH, 1);
				*dst_operands = return_basic_block_operand;
				continue;
			}

			if (called_entry.op_code == HCC_IR_OP_CODE_BASIC_BLOCK) {
				new_ir_function->basic_blocks_count += 1;
			}

			if (hcc_ir_op_code_has_return_value(called_entry.op_code)) {
				U32 value_idx = HCC_IR_OPERAND_VALUE_IDX(called_entry.operands[0]);
				hcc_iropt_copy_value(c, called_ir_function, value_idx);
			}

			//
			// copy the instruction header
			HccIROperand* new_operands = hcc_irgen_instruction_add(c, called_entry.op_code, called_entry.operands_count);

			//
			// copy the operands of the instruction from the function we are inlining while adjusting the referenced values
			for (U32 called_operand_idx = 0; called_operand_idx < called_entry.operands_count; called_operand_idx += 1) {
				HccIROperand operand = called_entry.operands[called_operand_idx];
				switch (operand & 0xff) {
					case HCC_IR_OPERAND_VALUE: {
						U32 value_idx = HCC_IR_OPERAND_VALUE_IDX(operand);
						if (value_idx < called_ir_function->params_count) {
							// remap the parameter to the function argument value,
							// the parameter value registers are not copied over to the caller function.
							operand = entry.operands[value_idx + 2];
						} else {
							// remap all the other values
							value_idx += called_operand_value_idx_offset;
							operand = HCC_IR_OPERAND_VALUE_INIT(value_idx);
						}
						break;
					};
				}

				new_operands[called_operand_idx] = operand;
			}
		}

		if (needs_return_basic_block) {
			// because there is no immediate basic block that follows the inlined function call,
			// we are going to add the basic block that return_basic_block_operand will branch to instead of return
			hcc_irgen_basic_block_add(c);
		}

		if (has_return_value) {
			//
			// load from the return variable into the original return value operand
			// that the called function was assigning to.
			HccIROperand* dst_operands = hcc_irgen_instruction_add(c, HCC_IR_OP_CODE_PTR_LOAD, 2);
			dst_operands[0] = hcc_iropt_remap_value(c, entry.operands[0]); // return value operand;
			dst_operands[1] = return_variable_operand;
		}

		next_call_instr_word_idx = hcc_stack_get_or_value(call_instr_word_indices, next_call_instr_idx, UINT32_MAX);
		next_call_instr_idx += 1;
	}

	return true;
}

// ===========================================
//
//
// SPIR-V Generation
//
//
// ===========================================

#if 0
HccSpirvOp hcc_spirv_binary_ops[HCC_BINARY_OP_COUNT][HCC_BASIC_TYPE_CLASS_COUNT] = {
	[HCC_BINARY_OP_ADD] = {
		[HCC_BASIC_TYPE_CLASS_UINT] = HCC_SPIRV_OP_I_ADD,
		[HCC_BASIC_TYPE_CLASS_SINT] = HCC_SPIRV_OP_I_ADD,
		[HCC_BASIC_TYPE_CLASS_FLOAT] = HCC_SPIRV_OP_F_ADD,
	},
	[HCC_BINARY_OP_SUBTRACT] = {
		[HCC_BASIC_TYPE_CLASS_UINT] = HCC_SPIRV_OP_I_SUB,
		[HCC_BASIC_TYPE_CLASS_SINT] = HCC_SPIRV_OP_I_SUB,
		[HCC_BASIC_TYPE_CLASS_FLOAT] = HCC_SPIRV_OP_F_SUB,
	},
	[HCC_BINARY_OP_MULTIPLY] = {
		[HCC_BASIC_TYPE_CLASS_UINT] = HCC_SPIRV_OP_I_MUL,
		[HCC_BASIC_TYPE_CLASS_SINT] = HCC_SPIRV_OP_I_MUL,
		[HCC_BASIC_TYPE_CLASS_FLOAT] = HCC_SPIRV_OP_F_MUL,
	},
	[HCC_BINARY_OP_DIVIDE] = {
		[HCC_BASIC_TYPE_CLASS_UINT] = HCC_SPIRV_OP_U_DIV,
		[HCC_BASIC_TYPE_CLASS_SINT] = HCC_SPIRV_OP_S_DIV,
		[HCC_BASIC_TYPE_CLASS_FLOAT] = HCC_SPIRV_OP_F_DIV,
	},
	[HCC_BINARY_OP_MODULO] = {
		[HCC_BASIC_TYPE_CLASS_UINT] = HCC_SPIRV_OP_U_MOD,
		[HCC_BASIC_TYPE_CLASS_SINT] = HCC_SPIRV_OP_S_MOD,
	},
	[HCC_BINARY_OP_BIT_AND] = {
		[HCC_BASIC_TYPE_CLASS_UINT] = HCC_SPIRV_OP_BITWISE_AND,
		[HCC_BASIC_TYPE_CLASS_SINT] = HCC_SPIRV_OP_BITWISE_AND,
	},
	[HCC_BINARY_OP_BIT_OR] = {
		[HCC_BASIC_TYPE_CLASS_UINT] = HCC_SPIRV_OP_BITWISE_OR,
		[HCC_BASIC_TYPE_CLASS_SINT] = HCC_SPIRV_OP_BITWISE_OR,
	},
	[HCC_BINARY_OP_BIT_XOR] = {
		[HCC_BASIC_TYPE_CLASS_UINT] = HCC_SPIRV_OP_BITWISE_XOR,
		[HCC_BASIC_TYPE_CLASS_SINT] = HCC_SPIRV_OP_BITWISE_XOR,
	},
	[HCC_BINARY_OP_BIT_SHIFT_LEFT] = {
		[HCC_BASIC_TYPE_CLASS_UINT] = HCC_SPIRV_OP_BITWISE_SHIFT_LEFT_LOGICAL,
		[HCC_BASIC_TYPE_CLASS_SINT] = HCC_SPIRV_OP_BITWISE_SHIFT_LEFT_LOGICAL,
	},
	[HCC_BINARY_OP_BIT_SHIFT_RIGHT] = {
		[HCC_BASIC_TYPE_CLASS_UINT] = HCC_SPIRV_OP_BITWISE_SHIFT_RIGHT_LOGICAL,
		[HCC_BASIC_TYPE_CLASS_SINT] = HCC_SPIRV_OP_BITWISE_SHIFT_RIGHT_ARITHMETIC,
	},
	[HCC_BINARY_OP_EQUAL] = {
		[HCC_BASIC_TYPE_CLASS_BOOL] = HCC_SPIRV_OP_LOGICAL_EQUAL,
		[HCC_BASIC_TYPE_CLASS_UINT] = HCC_SPIRV_OP_I_EQUAL,
		[HCC_BASIC_TYPE_CLASS_SINT] = HCC_SPIRV_OP_I_EQUAL,
		[HCC_BASIC_TYPE_CLASS_FLOAT] = HCC_SPIRV_OP_F_UNORD_EQUAL,
	},
	[HCC_BINARY_OP_NOT_EQUAL] = {
		[HCC_BASIC_TYPE_CLASS_BOOL] = HCC_SPIRV_OP_LOGICAL_NOT_EQUAL,
		[HCC_BASIC_TYPE_CLASS_UINT] = HCC_SPIRV_OP_I_NOT_EQUAL,
		[HCC_BASIC_TYPE_CLASS_SINT] = HCC_SPIRV_OP_I_NOT_EQUAL,
		[HCC_BASIC_TYPE_CLASS_FLOAT] = HCC_SPIRV_OP_F_UNORD_NOT_EQUAL,
	},
	[HCC_BINARY_OP_LESS_THAN] = {
		[HCC_BASIC_TYPE_CLASS_UINT] = HCC_SPIRV_OP_U_LESS_THAN,
		[HCC_BASIC_TYPE_CLASS_SINT] = HCC_SPIRV_OP_S_LESS_THAN,
		[HCC_BASIC_TYPE_CLASS_FLOAT] = HCC_SPIRV_OP_F_UNORD_LESS_THAN,
	},
	[HCC_BINARY_OP_LESS_THAN_OR_EQUAL] = {
		[HCC_BASIC_TYPE_CLASS_UINT] = HCC_SPIRV_OP_U_LESS_THAN_EQUAL,
		[HCC_BASIC_TYPE_CLASS_SINT] = HCC_SPIRV_OP_S_LESS_THAN_EQUAL,
		[HCC_BASIC_TYPE_CLASS_FLOAT] = HCC_SPIRV_OP_F_UNORD_LESS_THAN_EQUAL,
	},
	[HCC_BINARY_OP_GREATER_THAN] = {
		[HCC_BASIC_TYPE_CLASS_UINT] = HCC_SPIRV_OP_U_GREATER_THAN,
		[HCC_BASIC_TYPE_CLASS_SINT] = HCC_SPIRV_OP_S_GREATER_THAN,
		[HCC_BASIC_TYPE_CLASS_FLOAT] = HCC_SPIRV_OP_F_UNORD_GREATER_THAN,
	},
	[HCC_BINARY_OP_GREATER_THAN_OR_EQUAL] = {
		[HCC_BASIC_TYPE_CLASS_UINT] = HCC_SPIRV_OP_U_GREATER_THAN_EQUAL,
		[HCC_BASIC_TYPE_CLASS_SINT] = HCC_SPIRV_OP_S_GREATER_THAN_EQUAL,
		[HCC_BASIC_TYPE_CLASS_FLOAT] = HCC_SPIRV_OP_F_UNORD_GREATER_THAN_EQUAL,
	},
};

HccSpirvOp hcc_spirv_unary_ops[HCC_UNARY_OP_COUNT][HCC_BASIC_TYPE_CLASS_COUNT] = {
	[HCC_UNARY_OP_LOGICAL_NOT] = {
		[HCC_BASIC_TYPE_CLASS_BOOL] = HCC_SPIRV_OP_LOGICAL_NOT,
	},
	[HCC_UNARY_OP_BIT_NOT] = {
		[HCC_BASIC_TYPE_CLASS_UINT] = HCC_SPIRV_OP_BITWISE_NOT,
		[HCC_BASIC_TYPE_CLASS_SINT] = HCC_SPIRV_OP_BITWISE_NOT,
	},
	[HCC_UNARY_OP_NEGATE] = {
		[HCC_BASIC_TYPE_CLASS_UINT] = HCC_SPIRV_OP_S_NEGATE,
		[HCC_BASIC_TYPE_CLASS_SINT] = HCC_SPIRV_OP_S_NEGATE,
		[HCC_BASIC_TYPE_CLASS_FLOAT] = HCC_SPIRV_OP_F_NEGATE,
	},
};

U32 hcc_spirv_type_table_deduplicate_function(HccCompiler* c, HccFunction* function) {
	HCC_DEBUG_ASSERT(function->shader_stage == HCC_FUNCTION_SHADER_STAGE_NONE, "internal error: shader stage functions do not belong in the function type table");
	HccSpirvTypeTable* table = &c->spirvgen.type_table;

	//
	// TODO make this a hash table look for speeeds
	for (U32 i = 0; i < hcc_stack_count(table->entries); i += 1) {
		HccSpirvTypeEntry* entry = hcc_stack_get(table->entries, i);
		U32 function_data_types_count = function->params_count + 1;
		if (entry->kind != HCC_SPIRV_TYPE_KIND_FUNCTION) {
			continue;
		}
		if (entry->data_types_count != function_data_types_count) {
			continue;
		}

		HccDataType* data_types = hcc_stack_get(table->data_types, entry->data_types_start_idx);
		if (data_types[0] != hcc_typedef_resolve_and_strip_const_volatile(c, function->return_data_type)) {
			continue;
		}

		bool is_match = true;
		HccVariable* params = &c->astgen.function_params_and_variables[function->params_start_idx];
		for (U32 j = 0; j < function->params_count; j += 1) {
			if (data_types[j + 1] != hcc_typedef_resolve_and_strip_const_volatile(c, params[j].data_type)) {
				is_match = false;
				break;
			}
		}

		if (is_match) {
			return entry->spirv_id;
		}
	}

	HccSpirvTypeEntry* entry = hcc_stack_push(table->entries);
	entry->data_types_start_idx = hcc_stack_count(table->data_types);
	entry->data_types_count = function->params_count + 1;
	entry->spirv_id = c->spirvgen.next_id;
	entry->kind = HCC_SPIRV_TYPE_KIND_FUNCTION;

	HccDataType* data_types = hcc_stack_push_many(table->data_types, entry->data_types_count);
	data_types[0] = hcc_typedef_resolve_and_strip_const_volatile(c, function->return_data_type);
	HccVariable* params = &c->astgen.function_params_and_variables[function->params_start_idx];
	for (U32 j = 0; j < entry->data_types_count; j += 1) {
		data_types[j + 1] = hcc_typedef_resolve_and_strip_const_volatile(c, params[j].data_type);
	}

	return entry->spirv_id;
}

U32 hcc_spirv_type_table_deduplicate_variable(HccCompiler* c, HccDataType data_type, HccSpirvTypeKind kind) {
	HccSpirvTypeTable* table = &c->spirvgen.type_table;
	data_type = hcc_typedef_resolve_and_strip_const_volatile(c, data_type);

	//
	// TODO make this a hash table look for speeeds
	for (U32 i = 0; i < hcc_stack_count(table->entries); i += 1) {
		HccSpirvTypeEntry* entry = hcc_stack_get(table->entries, i);
		if (entry->kind != kind) {
			continue;
		}

		if (*hcc_stack_get(table->data_types, entry->data_types_start_idx) == data_type) {
			return entry->spirv_id;
		}
	}

	HccSpirvTypeEntry* entry = hcc_stack_push(table->entries);
	entry->data_types_start_idx = hcc_stack_count(table->data_types);
	entry->data_types_count = 1;
	entry->kind = kind;
	switch (kind) {
		case HCC_SPIRV_TYPE_KIND_FUNCTION_VARIABLE_POINTER_INPUT:
			entry->spirv_id = hcc_spirvgen_pointer_type_input_id(c, data_type);
			break;
		case HCC_SPIRV_TYPE_KIND_FUNCTION_VARIABLE_POINTER_OUTPUT:
			entry->spirv_id = hcc_spirvgen_pointer_type_output_id(c, data_type);
			break;
		default:
			entry->spirv_id = c->spirvgen.next_id;
			break;
	}

	*hcc_stack_push(table->data_types) = data_type;
	return c->spirvgen.next_id;
}

void hcc_spirvgen_init(HccCompiler* c, HccCompilerSetup* setup) {
	U32 total_data_types_count
		= HCC_DATA_TYPE_COUNT
		+ setup->astgen.array_data_types_cap
		+ setup->astgen.struct_data_types_cap
		+ setup->astgen.union_data_types_cap;

	c->spirvgen.type_table.data_types = hcc_stack_init(HccDataType, total_data_types_count, HCC_ALLOC_TAG_SPIRVGEN_TYPE_TABLE_DATA_TYPES);
	c->spirvgen.type_table.entries = hcc_stack_init(HccSpirvTypeEntry, total_data_types_count, HCC_ALLOC_TAG_SPIRVGEN_TYPE_TABLE_ENTRIES);

	// zero is an invalid spirv id so start on 1
	c->spirvgen.next_id = 1;

	c->spirvgen.available_basic_types = 0xffff;
	HCC_INTRINSIC_BASIC_TYPE_MASK_UNSET(&c->spirvgen.available_basic_types, HCC_INTRINSIC_TYPE_U8);
	HCC_INTRINSIC_BASIC_TYPE_MASK_UNSET(&c->spirvgen.available_basic_types, HCC_INTRINSIC_TYPE_S8);
	HCC_INTRINSIC_BASIC_TYPE_MASK_UNSET(&c->spirvgen.available_basic_types, HCC_INTRINSIC_TYPE_U16);
	HCC_INTRINSIC_BASIC_TYPE_MASK_UNSET(&c->spirvgen.available_basic_types, HCC_INTRINSIC_TYPE_S16);
	HCC_INTRINSIC_BASIC_TYPE_MASK_UNSET(&c->spirvgen.available_basic_types, HCC_INTRINSIC_TYPE_F16);
	HCC_INTRINSIC_BASIC_TYPE_MASK_UNSET(&c->spirvgen.available_basic_types, HCC_INTRINSIC_TYPE_U64);
	HCC_INTRINSIC_BASIC_TYPE_MASK_UNSET(&c->spirvgen.available_basic_types, HCC_INTRINSIC_TYPE_S64);
	HCC_INTRINSIC_BASIC_TYPE_MASK_UNSET(&c->spirvgen.available_basic_types, HCC_INTRINSIC_TYPE_F64);

	c->spirvgen.out_capabilities = hcc_stack_init(U32, setup->spirvgen.out_capabilities_cap, HCC_ALLOC_TAG_SPIRVGEN_OUT_CAPABILITIES);
	c->spirvgen.out_entry_points = hcc_stack_init(U32, setup->spirvgen.out_entry_points_cap, HCC_ALLOC_TAG_SPIRVGEN_OUT_ENTRY_POINTS);
	c->spirvgen.out_debug_info = hcc_stack_init(U32, setup->spirvgen.out_debug_info_cap, HCC_ALLOC_TAG_SPIRVGEN_OUT_DEBUG_INFO);
	c->spirvgen.out_annotations = hcc_stack_init(U32, setup->spirvgen.out_annotations_cap, HCC_ALLOC_TAG_SPIRVGEN_OUT_ANNOTATIONS);
	c->spirvgen.out_types_variables_constants = hcc_stack_init(U32, setup->spirvgen.out_types_variables_constants_cap, HCC_ALLOC_TAG_SPIRVGEN_OUT_TYPES_VARIABLES_CONSTANTS);
	c->spirvgen.out_functions = hcc_stack_init(U32, setup->spirvgen.out_functions_cap, HCC_ALLOC_TAG_SPIRVGEN_OUT_FUNCTIONS);
}

U32 hcc_spirvgen_resolve_type_id(HccCompiler* c, HccDataType data_type) {
	data_type = hcc_typedef_resolve_and_strip_const_volatile(c, data_type);
	U32 spirv_id;
	if (HCC_DATA_TYPE_IS_INTRINSIC(data_type)) {
		HccIntrinsicType intrinsic_type = hcc_intrinsic_type_from_data_type(c, data_type);
		spirv_id = HCC_SPIRV_ID_FROM_INTRINSIC_TYPE(intrinsic_type);
	} else {
		switch (data_type & 0xff) {
			case HCC_DATA_TYPE_STRUCT:
			case HCC_DATA_TYPE_UNION:
				spirv_id = c->spirvgen.compound_type_base_id + HCC_DATA_TYPE_IDX(data_type);
				break;
			case HCC_DATA_TYPE_ARRAY:
				spirv_id = c->spirvgen.array_type_base_id + HCC_DATA_TYPE_IDX(data_type);
				break;
			default:
				HCC_ABORT("unhandled data type '%u'", data_type);
		}
	}

	return spirv_id;
}

U32 hcc_spirvgen_convert_operand(HccCompiler* c, HccIROperand ir_operand) {
	switch (ir_operand & 0xff) {
		case HCC_IR_OPERAND_VALUE: return c->spirvgen.value_base_id + HCC_IR_OPERAND_VALUE_IDX(ir_operand);
		case HCC_IR_OPERAND_CONSTANT: return c->spirvgen.constant_base_id + HCC_IR_OPERAND_CONSTANT_ID(ir_operand).idx_plus_one - 1;
		case HCC_IR_OPERAND_CONSTANT_IMMEDIATE_U24:
			HCC_UNREACHABLE("not sure if we need to convert the operand for the immediate constant");
		case HCC_IR_OPERAND_LOCAL_VARIABLE: return c->spirvgen.local_variable_base_spirv_id + HCC_IR_OPERAND_VARIABLE_IDX(ir_operand);
		case HCC_IR_OPERAND_GLOBAL_VARIABLE: return c->spirvgen.global_variable_base_spirv_id + HCC_IR_OPERAND_VARIABLE_IDX(ir_operand);
		case HCC_IR_OPERAND_FUNCTION: return c->spirvgen.function_base_spirv_id + HCC_IR_OPERAND_FUNCTION_IDX(ir_operand) - HCC_FUNCTION_IDX_USER_START;
		case HCC_IR_OPERAND_SHADER_STAGE_INPUT: {
			U32 field_idx = HCC_IR_OPERAND_SHADER_STAGE_INPUT_FIELD_IDX(ir_operand);
			switch (c->spirvgen.function->shader_stage) {
				case HCC_FUNCTION_SHADER_STAGE_VERTEX: {
					switch (field_idx) {
						case HCC_VERTEX_INPUT_VERTEX_INDEX: return c->spirvgen.vertex_index_spirv_id;
						case HCC_VERTEX_INPUT_INSTANCE_INDEX: return c->spirvgen.instance_index_spirv_id;
					}

					break;
				};
				case HCC_FUNCTION_SHADER_STAGE_FRAGMENT: {
					switch (field_idx) {
						case HCC_FRAGMENT_INPUT_FRAG_COORD: return c->spirvgen.frag_coord_spirv_id;
					}

					break;
				};
			}

			HCC_UNREACHABLE("unhandled shader stage input operand");
			break;
		};
		case HCC_IR_OPERAND_RASTERIZER_STATE: {
			U32 field_idx = HCC_IR_OPERAND_RASTERIZER_STATE_FIELD_IDX(ir_operand);
			HccCompoundDataType* s = c->spirvgen.rasterizer_state_compound_data_type;
			HCC_DEBUG_ASSERT(field_idx < s->fields_count, "unhandled shader stage input operand");
			return c->spirvgen.rasterizer_state_variable_start_spirv_id + field_idx;
		};
		default: return hcc_spirvgen_resolve_type_id(c, ir_operand);
	}
}

U32 hcc_spirvgen_pointer_type_input_id(HccCompiler* c, HccDataType data_type) {
	U32 data_type_spirv_id = hcc_spirvgen_resolve_type_id(c, data_type);
	HCC_DEBUG_ASSERT(HCC_SPIRV_ID_IS_INTRINSIC_TYPE(data_type_spirv_id), "spirv pointer type output can only be for basic, vector and matrix types");

	return c->spirvgen.pointer_type_inputs_base_id + data_type_spirv_id;
}

U32 hcc_spirvgen_pointer_type_output_id(HccCompiler* c, HccDataType data_type) {
	U32 data_type_spirv_id = hcc_spirvgen_resolve_type_id(c, data_type);
	HCC_DEBUG_ASSERT(HCC_SPIRV_ID_IS_INTRINSIC_TYPE(data_type_spirv_id), "spirv pointer type output can only be for basic, vector and matrix types");

	return c->spirvgen.pointer_type_outputs_base_id + data_type_spirv_id;
}

bool hcc_spirvgen_basic_type_is_supported(HccCompiler* c, HccIntrinsicType intrinsic_type) {
	return HCC_INTRINSIC_BASIC_TYPE_MASK_IS_SET(c->spirvgen.available_basic_types, intrinsic_type);
}

void hcc_spirvgen_instr_start(HccCompiler* c, HccSpirvOp op) {
	HCC_DEBUG_ASSERT(c->spirvgen.instr_op == HCC_SPIRV_OP_NO_OP, "internal error: hcc_spirvgen_instr_end has not be called before a new instruction was started");
	c->spirvgen.instr_op = op;
	c->spirvgen.instr_operands_count = 0;
}

void hcc_spirvgen_instr_add_operand(HccCompiler* c, U32 word) {
	HCC_DEBUG_ASSERT(c->spirvgen.instr_op != HCC_SPIRV_OP_NO_OP, "internal error: hcc_spirvgen_instr_start has not been called when making an instruction");
	HCC_DEBUG_ASSERT_ARRAY_BOUNDS(c->spirvgen.instr_operands_count, HCC_SPIRV_INSTR_OPERANDS_CAP);
	c->spirvgen.instr_operands[c->spirvgen.instr_operands_count] = word;
	c->spirvgen.instr_operands_count += 1;
}

void hcc_spirvgen_instr_add_converted_operand(HccCompiler* c, HccIROperand ir_operand) {
	U32 word = hcc_spirvgen_convert_operand(c, ir_operand);
	hcc_spirvgen_instr_add_operand(c, word);
}

void hcc_spirvgen_instr_add_result_operand(HccCompiler* c) {
	hcc_spirvgen_instr_add_operand(c, c->spirvgen.next_id);
	c->spirvgen.next_id += 1;
}

void hcc_spirvgen_instr_add_operands_string(HccCompiler* c, char* string, U32 string_size) {
	for (U32 i = 0; i < string_size; i += 4) {
		U32 word = 0;
		word |= string[i] << 0;
		if (i + 1 < string_size) word |= string[i + 1] << 8;
		if (i + 2 < string_size) word |= string[i + 2] << 16;
		if (i + 3 < string_size) word |= string[i + 3] << 24;
		hcc_spirvgen_instr_add_operand(c, word);
	}
	if (string_size % 4 == 0) {
		hcc_spirvgen_instr_add_operand(c, 0);
	}
}

void hcc_spirvgen_instr_end(HccCompiler* c) {
	HCC_DEBUG_ASSERT(c->spirvgen.instr_op != HCC_SPIRV_OP_NO_OP, "internal error: hcc_spirvgen_instr_start has not been called when making an instruction");

	U32* out;
	c->spirvgen.instr_operands_count += 1; // for the first operand that contains the op code and words count
	switch (c->spirvgen.instr_op) {
		case HCC_SPIRV_OP_CAPABILITY:
		case HCC_SPIRV_OP_EXTENSION:
			out = hcc_stack_push_many(c->spirvgen.out_capabilities, c->spirvgen.instr_operands_count);
			break;
		case HCC_SPIRV_OP_EXT_INST_IMPORT:
		case HCC_SPIRV_OP_MEMORY_MODEL:
		case HCC_SPIRV_OP_ENTRY_POINT:
		case HCC_SPIRV_OP_EXECUTION_MODE:
			out = hcc_stack_push_many(c->spirvgen.out_entry_points, c->spirvgen.instr_operands_count);
			break;
		case HCC_SPIRV_OP_DECORATE:
			out = hcc_stack_push_many(c->spirvgen.out_annotations, c->spirvgen.instr_operands_count);
			break;
		case HCC_SPIRV_OP_TYPE_VOID:
		case HCC_SPIRV_OP_TYPE_BOOL:
		case HCC_SPIRV_OP_TYPE_INT:
		case HCC_SPIRV_OP_TYPE_FLOAT:
		case HCC_SPIRV_OP_TYPE_VECTOR:
		case HCC_SPIRV_OP_TYPE_MATRIX:
		case HCC_SPIRV_OP_TYPE_ARRAY:
		case HCC_SPIRV_OP_TYPE_STRUCT:
		case HCC_SPIRV_OP_TYPE_POINTER:
		case HCC_SPIRV_OP_TYPE_FUNCTION:
		case HCC_SPIRV_OP_CONSTANT_TRUE:
		case HCC_SPIRV_OP_CONSTANT_FALSE:
		case HCC_SPIRV_OP_CONSTANT:
		case HCC_SPIRV_OP_CONSTANT_COMPOSITE:
		case HCC_SPIRV_OP_CONSTANT_NULL:
TYPES_VARIABLES_CONSTANTS:
			out = hcc_stack_push_many(c->spirvgen.out_types_variables_constants, c->spirvgen.instr_operands_count);
			break;
		case HCC_SPIRV_OP_FUNCTION:
		case HCC_SPIRV_OP_FUNCTION_PARAMETER:
		case HCC_SPIRV_OP_FUNCTION_END:
		case HCC_SPIRV_OP_FUNCTION_CALL:
		case HCC_SPIRV_OP_COMPOSITE_CONSTRUCT:
		case HCC_SPIRV_OP_TRANSPOSE:
		case HCC_SPIRV_OP_ACCESS_CHAIN:
		case HCC_SPIRV_OP_IN_BOUNDS_ACCESS_CHAIN:
		case HCC_SPIRV_OP_CONVERT_F_TO_U:
		case HCC_SPIRV_OP_CONVERT_F_TO_S:
		case HCC_SPIRV_OP_CONVERT_S_TO_F:
		case HCC_SPIRV_OP_CONVERT_U_TO_F:
		case HCC_SPIRV_OP_U_CONVERT:
		case HCC_SPIRV_OP_S_CONVERT:
		case HCC_SPIRV_OP_F_CONVERT:
		case HCC_SPIRV_OP_BITCAST:
		case HCC_SPIRV_OP_S_NEGATE:
		case HCC_SPIRV_OP_F_NEGATE:
		case HCC_SPIRV_OP_I_ADD:
		case HCC_SPIRV_OP_F_ADD:
		case HCC_SPIRV_OP_I_SUB:
		case HCC_SPIRV_OP_F_SUB:
		case HCC_SPIRV_OP_I_MUL:
		case HCC_SPIRV_OP_F_MUL:
		case HCC_SPIRV_OP_U_DIV:
		case HCC_SPIRV_OP_S_DIV:
		case HCC_SPIRV_OP_F_DIV:
		case HCC_SPIRV_OP_U_MOD:
		case HCC_SPIRV_OP_S_MOD:
		case HCC_SPIRV_OP_F_MOD:
		case HCC_SPIRV_OP_MATRIX_TIMES_SCALAR:
		case HCC_SPIRV_OP_VECTOR_TIMES_MATRIX:
		case HCC_SPIRV_OP_MATRIX_TIMES_VECTOR:
		case HCC_SPIRV_OP_MATRIX_TIMES_MATRIX:
		case HCC_SPIRV_OP_OUTER_PRODUCT:
		case HCC_SPIRV_OP_DOT:
		case HCC_SPIRV_OP_ANY:
		case HCC_SPIRV_OP_ALL:
		case HCC_SPIRV_OP_ISNAN:
		case HCC_SPIRV_OP_ISINF:
		case HCC_SPIRV_OP_LOGICAL_EQUAL:
		case HCC_SPIRV_OP_LOGICAL_NOT_EQUAL:
		case HCC_SPIRV_OP_LOGICAL_OR:
		case HCC_SPIRV_OP_LOGICAL_AND:
		case HCC_SPIRV_OP_LOGICAL_NOT:
		case HCC_SPIRV_OP_SELECT:
		case HCC_SPIRV_OP_I_EQUAL:
		case HCC_SPIRV_OP_I_NOT_EQUAL:
		case HCC_SPIRV_OP_U_GREATER_THAN:
		case HCC_SPIRV_OP_S_GREATER_THAN:
		case HCC_SPIRV_OP_U_GREATER_THAN_EQUAL:
		case HCC_SPIRV_OP_S_GREATER_THAN_EQUAL:
		case HCC_SPIRV_OP_U_LESS_THAN:
		case HCC_SPIRV_OP_S_LESS_THAN:
		case HCC_SPIRV_OP_U_LESS_THAN_EQUAL:
		case HCC_SPIRV_OP_S_LESS_THAN_EQUAL:
		case HCC_SPIRV_OP_F_UNORD_EQUAL:
		case HCC_SPIRV_OP_F_UNORD_NOT_EQUAL:
		case HCC_SPIRV_OP_F_UNORD_LESS_THAN:
		case HCC_SPIRV_OP_F_UNORD_GREATER_THAN:
		case HCC_SPIRV_OP_F_UNORD_LESS_THAN_EQUAL:
		case HCC_SPIRV_OP_F_UNORD_GREATER_THAN_EQUAL:
		case HCC_SPIRV_OP_BITWISE_SHIFT_RIGHT_LOGICAL:
		case HCC_SPIRV_OP_BITWISE_SHIFT_RIGHT_ARITHMETIC:
		case HCC_SPIRV_OP_BITWISE_SHIFT_LEFT_LOGICAL:
		case HCC_SPIRV_OP_BITWISE_OR:
		case HCC_SPIRV_OP_BITWISE_XOR:
		case HCC_SPIRV_OP_BITWISE_AND:
		case HCC_SPIRV_OP_BITWISE_NOT:
		case HCC_SPIRV_OP_PHI:
		case HCC_SPIRV_OP_LOOP_MERGE:
		case HCC_SPIRV_OP_SELECTION_MERGE:
		case HCC_SPIRV_OP_LABEL:
		case HCC_SPIRV_OP_BRANCH:
		case HCC_SPIRV_OP_BRANCH_CONDITIONAL:
		case HCC_SPIRV_OP_SWITCH:
		case HCC_SPIRV_OP_RETURN:
		case HCC_SPIRV_OP_RETURN_VALUE:
		case HCC_SPIRV_OP_UNREACHABLE:
		case HCC_SPIRV_OP_LOAD:
		case HCC_SPIRV_OP_STORE:
		case HCC_SPIRV_OP_EXT_INST:
FUNCTIONS:
			out = hcc_stack_push_many(c->spirvgen.out_functions, c->spirvgen.instr_operands_count);
			break;
		case HCC_SPIRV_OP_VARIABLE: {
			U32 storage_class = c->spirvgen.instr_operands[2];
			if (storage_class == HCC_SPIRV_STORAGE_CLASS_FUNCTION) {
				goto FUNCTIONS;
			} else {
				goto TYPES_VARIABLES_CONSTANTS;
			}
			break;
		};
		default:
			HCC_ABORT("unhandled spirv instruction op");
	}

	out[0] = (((c->spirvgen.instr_operands_count) & 0xffff) << 16) | (c->spirvgen.instr_op & 0xffff);
	for (U32 i = 0; i < c->spirvgen.instr_operands_count - 1; i += 1) {
		out[i + 1] = c->spirvgen.instr_operands[i];
	}

	printf("INSTRUCTION(%u): ", c->spirvgen.instr_op);
	for (U32 i = 0; i < c->spirvgen.instr_operands_count; i += 1) {
		printf("%u, ", out[i]);
	}
	printf("\n");

	c->spirvgen.instr_op = HCC_SPIRV_OP_NO_OP;
}

U32 hcc_spirvgen_generate_variable_type(HccCompiler* c, HccDataType data_type, HccSpirvTypeKind type_kind) {
	data_type = HCC_DATA_TYPE_STRIP_CONST(data_type);
	U32 type_id = hcc_spirv_type_table_deduplicate_variable(c, data_type, type_kind);
	if (type_id == c->spirvgen.next_id) {
		U32 storage_class;
		switch (type_kind) {
			case HCC_SPIRV_TYPE_KIND_FUNCTION_VARIABLE_POINTER_INPUT:
				storage_class = HCC_SPIRV_STORAGE_CLASS_INPUT;
				type_id = hcc_spirvgen_pointer_type_input_id(c, data_type);
				break;
			case HCC_SPIRV_TYPE_KIND_FUNCTION_VARIABLE_POINTER_OUTPUT:
				storage_class = HCC_SPIRV_STORAGE_CLASS_OUTPUT;
				type_id = hcc_spirvgen_pointer_type_output_id(c, data_type);
				break;
			case HCC_SPIRV_TYPE_KIND_FUNCTION_VARIABLE:
				storage_class = HCC_SPIRV_STORAGE_CLASS_FUNCTION;
				c->spirvgen.next_id += 1;
				break;
			case HCC_SPIRV_TYPE_KIND_STATIC_VARIABLE:
				storage_class = HCC_SPIRV_STORAGE_CLASS_PRIVATE;
				c->spirvgen.next_id += 1;
				break;
		}
		hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_TYPE_POINTER);
		hcc_spirvgen_instr_add_operand(c, type_id);
		hcc_spirvgen_instr_add_operand(c, storage_class);
		hcc_spirvgen_instr_add_operand(c, hcc_spirvgen_resolve_type_id(c, data_type));
		hcc_spirvgen_instr_end(c);
	}

	return type_id;
}

U32 hcc_spirvgen_generate_function_type(HccCompiler* c, HccFunction* function) {
	if (function->shader_stage != HCC_FUNCTION_SHADER_STAGE_NONE) {
		static HccFunction void_function = {0};
		function = &void_function;
	}

	U32 function_type_id = hcc_spirv_type_table_deduplicate_function(c, function);

	if (function_type_id == c->spirvgen.next_id) {
		c->spirvgen.next_id += 1;

		//
		// prebuild any function variable types
		HccVariable* params = hcc_stack_get(c->astgen.function_params_and_variables, function->params_start_idx);
		for (U32 i = 0; i < function->params_count; i += 1) {
			hcc_spirvgen_generate_variable_type(c, params[i].data_type, HCC_SPIRV_TYPE_KIND_FUNCTION_VARIABLE);
		}

		hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_TYPE_FUNCTION);
		hcc_spirvgen_instr_add_operand(c, function_type_id);
		hcc_spirvgen_instr_add_operand(c, hcc_spirvgen_resolve_type_id(c, function->return_data_type));
		for (U32 i = 0; i < function->params_count; i += 1) {
			U32 type_id = hcc_spirvgen_generate_variable_type(c, params[i].data_type, HCC_SPIRV_TYPE_KIND_FUNCTION_VARIABLE);
			hcc_spirvgen_instr_add_operand(c, type_id);
		}
		hcc_spirvgen_instr_end(c);
	}

	return function_type_id;
}

void hcc_spirvgen_generate_select(HccCompiler* c, U32 result_spirv_operand, HccDataType dst_type, U32 cond_value_spirv_operand, U32 a_spirv_operand, U32 b_spirv_operand) {
	hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_SELECT);
	hcc_spirvgen_instr_add_operand(c, hcc_spirvgen_resolve_type_id(c, dst_type));
	hcc_spirvgen_instr_add_operand(c, result_spirv_operand);
	hcc_spirvgen_instr_add_operand(c, cond_value_spirv_operand);
	hcc_spirvgen_instr_add_operand(c, a_spirv_operand);
	hcc_spirvgen_instr_add_operand(c, b_spirv_operand);
	hcc_spirvgen_instr_end(c);
}

void hcc_spirvgen_generate_convert(HccCompiler* c, HccSpirvOp spirv_convert_op, U32 result_spirv_operand, HccDataType dst_type, U32 value_spirv_operand) {
	hcc_spirvgen_instr_start(c, spirv_convert_op);
	hcc_spirvgen_instr_add_operand(c, hcc_spirvgen_resolve_type_id(c, dst_type));
	hcc_spirvgen_instr_add_operand(c, result_spirv_operand);
	hcc_spirvgen_instr_add_operand(c, value_spirv_operand);
	hcc_spirvgen_instr_end(c);
}

void hcc_spirvgen_generate_entry_point_used_global_variable_spirv_ids(HccCompiler* c, HccFunction* function) {
	for (U32 idx = function->used_static_variables_start_idx; idx < function->used_static_variables_start_idx + function->used_static_variables_count; idx += 1) {
		HccDecl decl = c->astgen.function_used_static_variables[idx];
		U32 spirv_base_id = HCC_DECL_IS_LOCAL_VARIABLE(decl)
			? c->spirvgen.local_variable_base_spirv_id
			: c->spirvgen.global_variable_base_spirv_id;
		hcc_spirvgen_instr_add_operand(c, spirv_base_id + HCC_DECL_IDX(decl));
	}
}

void hcc_spirvgen_generate_instr(HccCompiler* c, HccSpirvOp op, HccDataType return_data_type, HccIROperand* operands, U32 operands_count) {
	hcc_spirvgen_instr_start(c, op);
	hcc_spirvgen_instr_add_operand(c, hcc_spirvgen_resolve_type_id(c, return_data_type));
	hcc_spirvgen_instr_add_converted_operand(c, operands[0]);
	for (U32 operand_idx = 2; operand_idx < operands_count; operand_idx += 1) {
		hcc_spirvgen_instr_add_converted_operand(c, operands[operand_idx]);
	}
	hcc_spirvgen_instr_end(c);
}

void hcc_spirvgen_generate_ext_instr(HccCompiler* c, HccSpirvGLSLSTD450Op op, HccDataType return_data_type, HccIROperand* operands, U32 operands_count) {
	hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_EXT_INST);
	hcc_spirvgen_instr_add_operand(c, hcc_spirvgen_resolve_type_id(c, return_data_type));
	hcc_spirvgen_instr_add_converted_operand(c, operands[0]);
	hcc_spirvgen_instr_add_operand(c, c->spirvgen.ext_inst_glsl_std_450_spirv_id);
	hcc_spirvgen_instr_add_operand(c, op);
	for (U32 operand_idx = 2; operand_idx < operands_count; operand_idx += 1) {
		hcc_spirvgen_instr_add_converted_operand(c, operands[operand_idx]);
	}
	hcc_spirvgen_instr_end(c);
}

void hcc_spirvgen_generate_intrinsic_function(HccCompiler* c, HccFunction* caller_function, HccIRFunction* caller_ir_function, U32 function_idx, HccDataType return_data_type, HccIROperand* operands, U32 operands_count) {
	if (HCC_FUNCTION_IDX_IS_VECTOR_BINARY_OP(function_idx)) {
		HccBinaryOp binary_op = HCC_FUNCTION_IDX_VECTOR_BINARY_OP_TO_BINARY_OP(function_idx);
		HccDataType scalar_type = hcc_vector_data_type_scalar(c, return_data_type);
		HccBasicTypeClass scalar_type_class = hcc_basic_type_class(c, scalar_type);
		HccSpirvOp spirv_op = hcc_spirv_binary_ops[binary_op][scalar_type_class];
		HCC_DEBUG_ASSERT(spirv_op != HCC_SPIRV_OP_NO_OP, "internal error: invalid configuration for a binary op");
		hcc_spirvgen_generate_instr(c, spirv_op, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_VECTOR_BINARY_CMP_OP(function_idx)) {
		HccBinaryOp binary_op = HCC_FUNCTION_IDX_VECTOR_BINARY_CMP_OP_TO_BINARY_OP(function_idx);
		HccDataType v_data_type = hcc_irgen_operand_data_type(c, caller_function, caller_ir_function, operands[2]);
		HccDataType scalar_type = hcc_vector_data_type_scalar(c, v_data_type);
		HccBasicTypeClass scalar_type_class = hcc_basic_type_class(c, scalar_type);
		HccSpirvOp spirv_op = hcc_spirv_binary_ops[binary_op][scalar_type_class];
		HCC_DEBUG_ASSERT(spirv_op != HCC_SPIRV_OP_NO_OP, "internal error: invalid configuration for a binary op");
		hcc_spirvgen_generate_instr(c, spirv_op, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_VECTOR_BINARY_BITWISE_OP(function_idx)) {
		HccBinaryOp binary_op = HCC_FUNCTION_IDX_VECTOR_BINARY_BITWISE_OP_TO_BINARY_OP(function_idx);
		HccDataType scalar_type = hcc_vector_data_type_scalar(c, return_data_type);
		HccBasicTypeClass scalar_type_class = hcc_basic_type_class(c, scalar_type);
		HccSpirvOp spirv_op = hcc_spirv_binary_ops[binary_op][scalar_type_class];
		HCC_DEBUG_ASSERT(spirv_op != HCC_SPIRV_OP_NO_OP, "internal error: invalid configuration for a binary op");
		hcc_spirvgen_generate_instr(c, spirv_op, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_VECTOR_ANY_OR_ALL(function_idx)) {
		// %0 = v == 0
		U32 equal_result_spirv_id = c->spirvgen.next_id;
		HccDataType v_data_type = hcc_irgen_operand_data_type(c, caller_function, caller_ir_function, operands[2]);
		HccDataType scalar_type = hcc_vector_data_type_scalar(c, v_data_type);
		HccBasicTypeClass scalar_type_class = hcc_basic_type_class(c, scalar_type);
		HccSpirvOp spirv_op = hcc_spirv_binary_ops[HCC_BINARY_OP_NOT_EQUAL][scalar_type_class];
		HCC_DEBUG_ASSERT(spirv_op != HCC_SPIRV_OP_NO_OP, "internal error: invalid configuration for a binary op");
		hcc_spirvgen_instr_start(c, spirv_op);
		hcc_spirvgen_instr_add_operand(c, hcc_spirvgen_resolve_type_id(c, hcc_vector_data_type_to_vector_bool(v_data_type)));
		hcc_spirvgen_instr_add_result_operand(c);
		hcc_spirvgen_instr_add_converted_operand(c, operands[2]); // 'v' argument
		hcc_spirvgen_instr_add_converted_operand(c, HCC_IR_OPERAND_CONSTANT_INIT(c->basic_type_zero_constant_ids[return_data_type].idx_plus_one));
		hcc_spirvgen_instr_end(c);

		// %1 = any(%0)
		hcc_spirvgen_instr_start(c, function_idx <= HCC_FUNCTION_IDX_ANYV4U64 ? HCC_SPIRV_OP_ANY : HCC_SPIRV_OP_ALL);
		hcc_spirvgen_instr_add_operand(c, HCC_SPIRV_ID_FROM_INTRINSIC_TYPE(HCC_INTRINSIC_TYPE_BOOL));
		hcc_spirvgen_instr_add_converted_operand(c, operands[0]); // 'return value register
		hcc_spirvgen_instr_add_converted_operand(c, equal_result_spirv_id);
		hcc_spirvgen_instr_end(c);
	} else if (HCC_FUNCTION_IDX_IS_VECTOR_ANY_OR_ALL_BOOL(function_idx)) {
		hcc_spirvgen_generate_instr(c, function_idx <= HCC_FUNCTION_IDX_ANYV4BOOL ? HCC_SPIRV_OP_ANY : HCC_SPIRV_OP_ALL, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_VECTOR_SWIZZLE(function_idx)) {
		HCC_ABORT("TODO swizzle");
	} else if (HCC_FUNCTION_IDX_IS_VECTOR_PACK(function_idx)) {
		HCC_ABORT("TODO pack");
	} else if (HCC_FUNCTION_IDX_IS_VECTOR_UNPACK(function_idx)) {
		HCC_ABORT("TODO unpack");
	} else if (HCC_FUNCTION_IDX_IS_VECTOR_UNARY_OP(function_idx)) {
		HccUnaryOp unary_op = function_idx <= HCC_FUNCTION_IDX_NOTV4BOOL
			? HCC_UNARY_OP_LOGICAL_NOT
			: (function_idx <= HCC_FUNCTION_IDX_NEGV4U64
					? HCC_UNARY_OP_NEGATE
					: HCC_UNARY_OP_BIT_NOT);
		U32 equal_result_spirv_id = c->spirvgen.next_id;
		HccDataType v_data_type = hcc_irgen_operand_data_type(c, caller_function, caller_ir_function, operands[2]);
		HccDataType scalar_type = hcc_vector_data_type_scalar(c, v_data_type);
		HccBasicTypeClass scalar_type_class = hcc_basic_type_class(c, scalar_type);
		HccSpirvOp spirv_op = hcc_spirv_unary_ops[unary_op][scalar_type_class];
		HCC_DEBUG_ASSERT(spirv_op != HCC_SPIRV_OP_NO_OP, "internal error: invalid configuration for a unary op");
		hcc_spirvgen_instr_start(c, spirv_op);
		hcc_spirvgen_instr_add_operand(c, return_data_type);
		hcc_spirvgen_instr_add_converted_operand(c, operands[0]); // return value register
		hcc_spirvgen_instr_add_converted_operand(c, operands[2]); // 'v' argument
		hcc_spirvgen_instr_add_converted_operand(c, HCC_IR_OPERAND_CONSTANT_INIT(c->basic_type_zero_constant_ids[return_data_type].idx_plus_one));
		hcc_spirvgen_instr_end(c);
	} else if (HCC_FUNCTION_IDX_IS_VECTOR_NOT(function_idx)) {
		U32 equal_result_spirv_id = c->spirvgen.next_id;
		HccDataType v_data_type = hcc_irgen_operand_data_type(c, caller_function, caller_ir_function, operands[2]);
		HccDataType scalar_type = hcc_vector_data_type_scalar(c, v_data_type);
		HccBasicTypeClass scalar_type_class = hcc_basic_type_class(c, scalar_type);
		HccSpirvOp spirv_op = hcc_spirv_binary_ops[HCC_BINARY_OP_NOT_EQUAL][scalar_type_class];
		hcc_spirvgen_instr_start(c, spirv_op);
		hcc_spirvgen_instr_add_operand(c, return_data_type);
		hcc_spirvgen_instr_add_converted_operand(c, operands[0]); // return value register
		hcc_spirvgen_instr_add_converted_operand(c, operands[2]); // 'v' argument
		hcc_spirvgen_instr_add_converted_operand(c, HCC_IR_OPERAND_CONSTANT_INIT(c->basic_type_zero_constant_ids[return_data_type].idx_plus_one));
		hcc_spirvgen_instr_end(c);
	} else if (HCC_FUNCTION_IDX_IS_MIN(function_idx)) {
		HccSpirvGLSLSTD450Op op = function_idx <= HCC_FUNCTION_IDX_MINV4F64
			? HCC_SPIRV_GLSL_STD_450_OP_FMIN
			: (function_idx <= HCC_FUNCTION_IDX_MINV4I64)
				? HCC_SPIRV_GLSL_STD_450_OP_SMIN
				: HCC_SPIRV_GLSL_STD_450_OP_UMIN;
		hcc_spirvgen_generate_ext_instr(c, op, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_MAX(function_idx)) {
		HccSpirvGLSLSTD450Op op = function_idx <= HCC_FUNCTION_IDX_MAXV4F64
			? HCC_SPIRV_GLSL_STD_450_OP_FMAX
			: (function_idx <= HCC_FUNCTION_IDX_MAXV4I64)
				? HCC_SPIRV_GLSL_STD_450_OP_SMAX
				: HCC_SPIRV_GLSL_STD_450_OP_UMAX;
		hcc_spirvgen_generate_ext_instr(c, op, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_CLAMP(function_idx)) {
		HccSpirvGLSLSTD450Op op = function_idx <= HCC_FUNCTION_IDX_CLAMPV4F64
			? HCC_SPIRV_GLSL_STD_450_OP_FCLAMP
			: (function_idx <= HCC_FUNCTION_IDX_CLAMPV4I64)
				? HCC_SPIRV_GLSL_STD_450_OP_SCLAMP
				: HCC_SPIRV_GLSL_STD_450_OP_UCLAMP;
		hcc_spirvgen_generate_ext_instr(c, op, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_SIGN(function_idx)) {
		HccSpirvGLSLSTD450Op op = function_idx <= HCC_FUNCTION_IDX_SIGNV4F64
			? HCC_SPIRV_GLSL_STD_450_OP_FSIGN
			: HCC_SPIRV_GLSL_STD_450_OP_SSIGN;
		hcc_spirvgen_generate_ext_instr(c, op, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_ABS(function_idx)) {
		HccSpirvGLSLSTD450Op op = function_idx <= HCC_FUNCTION_IDX_ABSV4F64
			? HCC_SPIRV_GLSL_STD_450_OP_FABS
			: HCC_SPIRV_GLSL_STD_450_OP_SABS;
		hcc_spirvgen_generate_ext_instr(c, op, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_FMA(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_FMA, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_FLOOR(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_FLOOR, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_CEIL(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_CEIL, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_ROUND(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_ROUND, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_TRUNC(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_TRUNC, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_FRACT(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_FRACT, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_RADIANS(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_RADIANS, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_DEGREES(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_DEGREES, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_STEP(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_STEP, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_SMOOTHSTEP(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_SMOOTHSTEP, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_BITSTOFROM(function_idx)) {
		hcc_spirvgen_generate_convert(c, HCC_SPIRV_OP_BITCAST, operands[0], return_data_type, operands[2]);
	} else if (HCC_FUNCTION_IDX_IS_SIN(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_SIN, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_COS(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_COS, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_TAN(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_TAN, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_ASIN(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_ASIN, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_ACOS(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_ACOS, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_ATAN(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_ATAN, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_SINH(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_SINH, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_COSH(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_COSH, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_TANH(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_TANH, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_ASINH(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_ASINH, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_ACOSH(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_ACOSH, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_ATANH(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_ATANH, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_ATAN2(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_ATAN2, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_POW(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_POW, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_EXP(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_EXP, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_LOG(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_LOG, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_EXP2(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_EXP2, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_LOG2(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_LOG2, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_SQRT(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_SQRT, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_RSQRT(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_INVERSE_SQRT, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_ISINF(function_idx)) {
		hcc_spirvgen_generate_instr(c, HCC_SPIRV_OP_ISINF, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_ISNAN(function_idx)) {
		hcc_spirvgen_generate_instr(c, HCC_SPIRV_OP_ISNAN, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_LERP(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_FMIX, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_VECTOR_DOT(function_idx)) {
		hcc_spirvgen_generate_instr(c, HCC_SPIRV_OP_DOT, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_VECTOR_LEN(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_LENGTH, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_VECTOR_NORM(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_NORMALIZE, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_VECTOR_REFLECT(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_REFLECT, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_VECTOR_REFRACT(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_REFRACT, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_MATRIX_MUL(function_idx)) {
		hcc_spirvgen_generate_instr(c, HCC_SPIRV_OP_MATRIX_TIMES_MATRIX, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_MATRIX_MUL_SCALAR(function_idx)) {
		hcc_spirvgen_generate_instr(c, HCC_SPIRV_OP_MATRIX_TIMES_SCALAR, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_MATRIX_MUL_VECTOR(function_idx)) {
		hcc_spirvgen_generate_instr(c, HCC_SPIRV_OP_MATRIX_TIMES_VECTOR, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_VECTOR_MUL_MATRIX(function_idx)) {
		hcc_spirvgen_generate_instr(c, HCC_SPIRV_OP_VECTOR_TIMES_MATRIX, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_MATRIX_TRANSPOSE(function_idx)) {
		hcc_spirvgen_generate_instr(c, HCC_SPIRV_OP_TRANSPOSE, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_MATRIX_OUTER_PRODUCT(function_idx)) {
		hcc_spirvgen_generate_instr(c, HCC_SPIRV_OP_OUTER_PRODUCT, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_MATRIX_DETERMINANT(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_DETERMINANT, return_data_type, operands, operands_count);
	} else if (HCC_FUNCTION_IDX_IS_MATRIX_INVERSE(function_idx)) {
		hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_MATRIX_INVERSE, return_data_type, operands, operands_count);
	} else {
		switch (function_idx) {
			case HCC_FUNCTION_IDX_FMODF:
			case HCC_FUNCTION_IDX_FMOD:
			case HCC_FUNCTION_IDX_MODF16:
				hcc_spirvgen_generate_instr(c, HCC_SPIRV_OP_F_MOD, return_data_type, operands, operands_count);
				break;

			case HCC_FUNCTION_IDX_F16TOF32:
				hcc_spirvgen_generate_convert(c, HCC_SPIRV_OP_F_CONVERT,
					hcc_spirvgen_convert_operand(c, operands[0]),
					HCC_SPIRV_ID_FROM_INTRINSIC_TYPE(HCC_INTRINSIC_TYPE_F32),
					hcc_spirvgen_convert_operand(c, operands[2])
				);
				break;
			case HCC_FUNCTION_IDX_F16TOF64:
				hcc_spirvgen_generate_convert(c, HCC_SPIRV_OP_F_CONVERT,
					hcc_spirvgen_convert_operand(c, operands[0]),
					HCC_SPIRV_ID_FROM_INTRINSIC_TYPE(HCC_INTRINSIC_TYPE_F64),
					hcc_spirvgen_convert_operand(c, operands[2])
				);
				break;
			case HCC_FUNCTION_IDX_F32TOF16:
				hcc_spirvgen_generate_convert(c, HCC_SPIRV_OP_F_CONVERT,
					hcc_spirvgen_convert_operand(c, operands[0]),
					HCC_SPIRV_ID_FROM_INTRINSIC_TYPE(HCC_INTRINSIC_TYPE_F16),
					hcc_spirvgen_convert_operand(c, operands[2])
				);
				break;
			case HCC_FUNCTION_IDX_F64TOF16:
				hcc_spirvgen_generate_convert(c, HCC_SPIRV_OP_F_CONVERT,
					hcc_spirvgen_convert_operand(c, operands[0]),
					HCC_SPIRV_ID_FROM_INTRINSIC_TYPE(HCC_INTRINSIC_TYPE_F16),
					hcc_spirvgen_convert_operand(c, operands[2])
				);
				break;
			case HCC_FUNCTION_IDX_ADDF16:
				hcc_spirvgen_generate_instr(c, HCC_SPIRV_OP_F_ADD, return_data_type, operands, operands_count);
				break;
			case HCC_FUNCTION_IDX_SUBF16:
				hcc_spirvgen_generate_instr(c, HCC_SPIRV_OP_F_SUB, return_data_type, operands, operands_count);
				break;
			case HCC_FUNCTION_IDX_MULF16:
				hcc_spirvgen_generate_instr(c, HCC_SPIRV_OP_F_MUL, return_data_type, operands, operands_count);
				break;
			case HCC_FUNCTION_IDX_DIVF16:
				hcc_spirvgen_generate_instr(c, HCC_SPIRV_OP_F_DIV, return_data_type, operands, operands_count);
				break;
			case HCC_FUNCTION_IDX_EQF16:
				hcc_spirvgen_generate_instr(c, HCC_SPIRV_OP_F_UNORD_EQUAL, return_data_type, operands, operands_count);
				break;
			case HCC_FUNCTION_IDX_NEQF16:
				hcc_spirvgen_generate_instr(c, HCC_SPIRV_OP_F_UNORD_NOT_EQUAL, return_data_type, operands, operands_count);
				break;
			case HCC_FUNCTION_IDX_LTF16:
				hcc_spirvgen_generate_instr(c, HCC_SPIRV_OP_F_UNORD_LESS_THAN, return_data_type, operands, operands_count);
				break;
			case HCC_FUNCTION_IDX_LTEQF16:
				hcc_spirvgen_generate_instr(c, HCC_SPIRV_OP_F_UNORD_LESS_THAN_EQUAL, return_data_type, operands, operands_count);
				break;
			case HCC_FUNCTION_IDX_GTF16:
				hcc_spirvgen_generate_instr(c, HCC_SPIRV_OP_F_UNORD_GREATER_THAN, return_data_type, operands, operands_count);
				break;
			case HCC_FUNCTION_IDX_GTEQF16:
				hcc_spirvgen_generate_instr(c, HCC_SPIRV_OP_F_UNORD_GREATER_THAN_EQUAL, return_data_type, operands, operands_count);
				break;
			case HCC_FUNCTION_IDX_NOTF16: {
				hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_F_UNORD_EQUAL);
				hcc_spirvgen_instr_add_operand(c, HCC_SPIRV_ID_FROM_INTRINSIC_TYPE(HCC_INTRINSIC_TYPE_BOOL));
				hcc_spirvgen_instr_add_converted_operand(c, operands[0]); // return value register
				hcc_spirvgen_instr_add_converted_operand(c, operands[2]); // 'v' argument
				hcc_spirvgen_instr_add_converted_operand(c, HCC_IR_OPERAND_CONSTANT_INIT(c->basic_type_zero_constant_ids[return_data_type].idx_plus_one));
				hcc_spirvgen_instr_end(c);
				break;
			};
			case HCC_FUNCTION_IDX_NEGF16:
				hcc_spirvgen_generate_instr(c, HCC_SPIRV_OP_F_NEGATE, return_data_type, operands, operands_count);
				break;

			case HCC_FUNCTION_IDX_PACKF16X2V2F32:
				hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_PACK_HALF2X16, return_data_type, operands, operands_count);
				break;
			case HCC_FUNCTION_IDX_UNPACKF16X2V2F32:
				hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_UNPACK_HALF2X16, return_data_type, operands, operands_count);
				break;
			case HCC_FUNCTION_IDX_PACKU16X2V2F32:
				hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_PACK_UNORM2X16, return_data_type, operands, operands_count);
				break;
			case HCC_FUNCTION_IDX_UNPACKU16X2V2F32:
				hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_UNPACK_UNORM2X16, return_data_type, operands, operands_count);
				break;
			case HCC_FUNCTION_IDX_PACKS16X2V2F32:
				hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_PACK_SNORM2X16, return_data_type, operands, operands_count);
				break;
			case HCC_FUNCTION_IDX_UNPACKS16X2V2F32:
				hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_UNPACK_SNORM2X16, return_data_type, operands, operands_count);
				break;
			case HCC_FUNCTION_IDX_PACKU8X4V4F32:
				hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_PACK_UNORM4X8, return_data_type, operands, operands_count);
				break;
			case HCC_FUNCTION_IDX_UNPACKU8X4V4F32:
				hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_UNPACK_UNORM4X8, return_data_type, operands, operands_count);
				break;
			case HCC_FUNCTION_IDX_PACKS8X4V4F32:
				hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_PACK_SNORM4X8, return_data_type, operands, operands_count);
				break;
			case HCC_FUNCTION_IDX_UNPACKS8X4V4F32:
				hcc_spirvgen_generate_ext_instr(c, HCC_SPIRV_GLSL_STD_450_OP_UNPACK_SNORM4X8, return_data_type, operands, operands_count);
				break;

			default:
				HCC_ABORT("internal error: unhandled intrinsic function idx '%s' in spirvgen", hcc_intrinsic_function_strings[function_idx]);
		}
	}
}

void hcc_spirvgen_generate_function(HccCompiler* c, U32 function_idx) {
	HccFunction* function = hcc_stack_get(c->astgen.functions, function_idx);
	HccIRFunction* ir_function = hcc_stack_get(c->irgen.functions, function_idx);
	c->spirvgen.function = function;
	c->spirvgen.ir_function = ir_function;

	HccDataType return_data_type = function->return_data_type;
	switch (function->shader_stage) {
		case HCC_FUNCTION_SHADER_STAGE_VERTEX:
			return_data_type = HCC_DATA_TYPE_VOID;
			break;
		case HCC_FUNCTION_SHADER_STAGE_FRAGMENT:
			return_data_type = HCC_DATA_TYPE_VOID;
			break;
		case HCC_FUNCTION_SHADER_STAGE_NONE:
			break;
		default: HCC_ABORT("unhandled shader stage");
	}

	U32 function_type_id = hcc_spirvgen_generate_function_type(c, function);
	HccString ident = hcc_string_table_get(&c->string_table, function->identifier_string_id);

	U32 function_ctrl = HCC_SPIRV_FUNCTION_CTRL_NONE;
	if (function->flags & HCC_FUNCTION_FLAGS_INLINE) {
		function_ctrl |= HCC_SPIRV_FUNCTION_CTRL_INLINE;
	}

	U32 function_spirv_id = c->spirvgen.function_base_spirv_id + function_idx - HCC_FUNCTION_IDX_USER_START;
	hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_FUNCTION);
	hcc_spirvgen_instr_add_operand(c, hcc_spirvgen_resolve_type_id(c, return_data_type));
	hcc_spirvgen_instr_add_operand(c, function_spirv_id);
	hcc_spirvgen_instr_add_operand(c, function_ctrl);
	hcc_spirvgen_instr_add_operand(c, function_type_id);
	hcc_spirvgen_instr_end(c);

	c->spirvgen.local_variable_base_spirv_id = c->spirvgen.next_id;
	c->spirvgen.next_id += function->params_count + function->variables_count;

	U32 position_spirv_id;
	HccCompoundDataType* fragment_state_compound_data_type;
	U32 fragment_state_variable_start_spirv_id;
	switch (function->shader_stage) {
		case HCC_FUNCTION_SHADER_STAGE_VERTEX: {
			{
				c->spirvgen.vertex_index_spirv_id = c->spirvgen.next_id;
				hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_VARIABLE);
				hcc_spirvgen_instr_add_operand(c, hcc_spirvgen_pointer_type_input_id(c, HCC_DATA_TYPE_INT32));
				hcc_spirvgen_instr_add_result_operand(c);
				hcc_spirvgen_instr_add_operand(c, HCC_SPIRV_STORAGE_CLASS_INPUT);
				hcc_spirvgen_instr_end(c);

				hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_DECORATE);
				hcc_spirvgen_instr_add_operand(c, c->spirvgen.vertex_index_spirv_id);
				hcc_spirvgen_instr_add_operand(c, HCC_SPRIV_DECORATION_BUILTIN);
				hcc_spirvgen_instr_add_operand(c, HCC_SPIRV_BUILTIN_VERTEX_INDEX);
				hcc_spirvgen_instr_end(c);
			}

			{
				c->spirvgen.instance_index_spirv_id = c->spirvgen.next_id;
				hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_VARIABLE);
				hcc_spirvgen_instr_add_operand(c, hcc_spirvgen_pointer_type_input_id(c, HCC_DATA_TYPE_INT32));
				hcc_spirvgen_instr_add_result_operand(c);
				hcc_spirvgen_instr_add_operand(c, HCC_SPIRV_STORAGE_CLASS_INPUT);
				hcc_spirvgen_instr_end(c);

				hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_DECORATE);
				hcc_spirvgen_instr_add_operand(c, c->spirvgen.instance_index_spirv_id);
				hcc_spirvgen_instr_add_operand(c, HCC_SPRIV_DECORATION_BUILTIN);
				hcc_spirvgen_instr_add_operand(c, HCC_SPIRV_BUILTIN_INSTANCE_INDEX);
				hcc_spirvgen_instr_end(c);
			}

			{
				position_spirv_id = c->spirvgen.next_id;
				hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_VARIABLE);
				hcc_spirvgen_instr_add_operand(c, hcc_spirvgen_pointer_type_output_id(c, HCC_DATA_TYPE_VECTOR(HCC_VEC4F32)));
				hcc_spirvgen_instr_add_result_operand(c);
				hcc_spirvgen_instr_add_operand(c, HCC_SPIRV_STORAGE_CLASS_OUTPUT);
				hcc_spirvgen_instr_end(c);

				hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_DECORATE);
				hcc_spirvgen_instr_add_operand(c, position_spirv_id);
				hcc_spirvgen_instr_add_operand(c, HCC_SPRIV_DECORATION_BUILTIN);
				hcc_spirvgen_instr_add_operand(c, HCC_SPIRV_BUILTIN_POSITION);
				hcc_spirvgen_instr_end(c);
			}

			c->spirvgen.rasterizer_state_compound_data_type = hcc_compound_data_type_get(c, function->return_data_type);
			c->spirvgen.rasterizer_state_variable_start_spirv_id = c->spirvgen.next_id;
			for (U32 field_idx = 0; field_idx < c->spirvgen.rasterizer_state_compound_data_type->fields_count; field_idx += 1) {
				HccCompoundField* field = hcc_stack_get(c->astgen.compound_fields, c->spirvgen.rasterizer_state_compound_data_type->fields_start_idx + field_idx);
				HccDataType field_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, field->data_type);

				U32 variable_spirv_id = c->spirvgen.next_id;
				hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_VARIABLE);
				hcc_spirvgen_instr_add_operand(c, hcc_spirvgen_pointer_type_output_id(c, field_data_type));
				hcc_spirvgen_instr_add_operand(c, variable_spirv_id);
				hcc_spirvgen_instr_add_operand(c, HCC_SPIRV_STORAGE_CLASS_OUTPUT);
				hcc_spirvgen_instr_end(c);

				hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_DECORATE);
				hcc_spirvgen_instr_add_operand(c, variable_spirv_id);
				hcc_spirvgen_instr_add_operand(c, HCC_SPRIV_DECORATION_LOCATION);
				hcc_spirvgen_instr_add_operand(c, field_idx);
				hcc_spirvgen_instr_end(c);

				if (field->rasterizer_state_field_kind == HCC_RASTERIZER_STATE_FIELD_KIND_NOINTERP) {
					hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_DECORATE);
					hcc_spirvgen_instr_add_operand(c, variable_spirv_id);
					hcc_spirvgen_instr_add_operand(c, HCC_SPRIV_DECORATION_FLAT);
					hcc_spirvgen_instr_end(c);
				}

				c->spirvgen.next_id += 1;
			}

			hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_ENTRY_POINT);
			hcc_spirvgen_instr_add_operand(c, HCC_SPIRV_EXECUTION_MODEL_VERTEX);
			hcc_spirvgen_instr_add_operand(c, function_spirv_id);
			HccString name = hcc_string_table_get(&c->string_table, function->identifier_string_id);
			hcc_spirvgen_instr_add_operands_string(c, (char*)name.data, name.size);
			hcc_spirvgen_instr_add_operand(c, c->spirvgen.vertex_index_spirv_id);
			hcc_spirvgen_instr_add_operand(c, c->spirvgen.instance_index_spirv_id);
			hcc_spirvgen_instr_add_operand(c, position_spirv_id);
			for (U32 field_idx = 0; field_idx < c->spirvgen.rasterizer_state_compound_data_type->fields_count; field_idx += 1) {
				HccCompoundField* field = hcc_stack_get(c->astgen.compound_fields, c->spirvgen.rasterizer_state_compound_data_type->fields_start_idx + field_idx);
				hcc_spirvgen_instr_add_operand(c, c->spirvgen.rasterizer_state_variable_start_spirv_id + field_idx);
			}

			hcc_spirvgen_generate_entry_point_used_global_variable_spirv_ids(c, function);

			hcc_spirvgen_instr_end(c);
			break;
		};
		case HCC_FUNCTION_SHADER_STAGE_FRAGMENT:
			{
				c->spirvgen.frag_coord_spirv_id = c->spirvgen.next_id;
				hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_VARIABLE);
				hcc_spirvgen_instr_add_operand(c, hcc_spirvgen_pointer_type_input_id(c, HCC_DATA_TYPE_VECTOR(HCC_VEC4F32)));
				hcc_spirvgen_instr_add_result_operand(c);
				hcc_spirvgen_instr_add_operand(c, HCC_SPIRV_STORAGE_CLASS_INPUT);
				hcc_spirvgen_instr_end(c);

				hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_DECORATE);
				hcc_spirvgen_instr_add_operand(c, c->spirvgen.frag_coord_spirv_id);
				hcc_spirvgen_instr_add_operand(c, HCC_SPRIV_DECORATION_BUILTIN);
				hcc_spirvgen_instr_add_operand(c, HCC_SPIRV_BUILTIN_FRAG_COORD);
				hcc_spirvgen_instr_end(c);
			}

			fragment_state_compound_data_type = hcc_compound_data_type_get(c, function->return_data_type);
			fragment_state_variable_start_spirv_id = c->spirvgen.next_id;
			for (U32 field_idx = 0; field_idx < fragment_state_compound_data_type->fields_count; field_idx += 1) {
				HccCompoundField* field = hcc_stack_get(c->astgen.compound_fields, fragment_state_compound_data_type->fields_start_idx + field_idx);
				HccDataType field_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, field->data_type);

				U32 variable_spirv_id = c->spirvgen.next_id;
				hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_VARIABLE);
				hcc_spirvgen_instr_add_operand(c, hcc_spirvgen_pointer_type_output_id(c, field_data_type));
				hcc_spirvgen_instr_add_operand(c, variable_spirv_id);
				hcc_spirvgen_instr_add_operand(c, HCC_SPIRV_STORAGE_CLASS_OUTPUT);
				hcc_spirvgen_instr_end(c);

				hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_DECORATE);
				hcc_spirvgen_instr_add_operand(c, variable_spirv_id);
				hcc_spirvgen_instr_add_operand(c, HCC_SPRIV_DECORATION_LOCATION);
				hcc_spirvgen_instr_add_operand(c, field_idx);
				hcc_spirvgen_instr_end(c);

				c->spirvgen.next_id += 1;
			}

			HccVariable* v = hcc_stack_get(c->astgen.function_params_and_variables, function->params_start_idx + 1);
			c->spirvgen.rasterizer_state_compound_data_type = hcc_compound_data_type_get(c, hcc_typedef_resolve_and_strip_const_volatile(c, v->data_type));
			c->spirvgen.rasterizer_state_variable_start_spirv_id = c->spirvgen.next_id;
			for (U32 field_idx = 0; field_idx < c->spirvgen.rasterizer_state_compound_data_type->fields_count; field_idx += 1) {
				HccCompoundField* field = hcc_stack_get(c->astgen.compound_fields, c->spirvgen.rasterizer_state_compound_data_type->fields_start_idx + field_idx);
				HccDataType field_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, field->data_type);

				U32 variable_spirv_id = c->spirvgen.next_id;
				hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_VARIABLE);
				hcc_spirvgen_instr_add_operand(c, hcc_spirvgen_pointer_type_input_id(c, field_data_type));
				hcc_spirvgen_instr_add_operand(c, variable_spirv_id);
				hcc_spirvgen_instr_add_operand(c, HCC_SPIRV_STORAGE_CLASS_INPUT);
				hcc_spirvgen_instr_end(c);

				hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_DECORATE);
				hcc_spirvgen_instr_add_operand(c, variable_spirv_id);
				hcc_spirvgen_instr_add_operand(c, HCC_SPRIV_DECORATION_LOCATION);
				hcc_spirvgen_instr_add_operand(c, field_idx);
				hcc_spirvgen_instr_end(c);

				if (field->rasterizer_state_field_kind == HCC_RASTERIZER_STATE_FIELD_KIND_NOINTERP) {
					hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_DECORATE);
					hcc_spirvgen_instr_add_operand(c, variable_spirv_id);
					hcc_spirvgen_instr_add_operand(c, HCC_SPRIV_DECORATION_FLAT);
					hcc_spirvgen_instr_end(c);
				}

				c->spirvgen.next_id += 1;
			}

			hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_ENTRY_POINT);
			hcc_spirvgen_instr_add_operand(c, HCC_SPIRV_EXECUTION_MODEL_FRAGMENT);
			hcc_spirvgen_instr_add_operand(c, function_spirv_id);
			HccString name = hcc_string_table_get(&c->string_table, function->identifier_string_id);
			hcc_spirvgen_instr_add_operands_string(c, (char*)name.data, name.size);
			hcc_spirvgen_instr_add_operand(c, c->spirvgen.frag_coord_spirv_id);
			for (U32 field_idx = 0; field_idx < fragment_state_compound_data_type->fields_count; field_idx += 1) {
				HccCompoundField* field = hcc_stack_get(c->astgen.compound_fields, fragment_state_compound_data_type->fields_start_idx + field_idx);
				hcc_spirvgen_instr_add_operand(c, fragment_state_variable_start_spirv_id + field_idx);
			}
			for (U32 field_idx = 0; field_idx < c->spirvgen.rasterizer_state_compound_data_type->fields_count; field_idx += 1) {
				HccCompoundField* field = hcc_stack_get(c->astgen.compound_fields, c->spirvgen.rasterizer_state_compound_data_type->fields_start_idx + field_idx);
				hcc_spirvgen_instr_add_operand(c, c->spirvgen.rasterizer_state_variable_start_spirv_id + field_idx);
			}

			hcc_spirvgen_generate_entry_point_used_global_variable_spirv_ids(c, function);

			hcc_spirvgen_instr_end(c);

			hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_EXECUTION_MODE);
			hcc_spirvgen_instr_add_operand(c, function_spirv_id);
			hcc_spirvgen_instr_add_operand(c, HCC_SPIRV_EXECUTION_MODE_ORIGIN_UPPER_LEFT);
			hcc_spirvgen_instr_end(c);

			break;
		case HCC_FUNCTION_SHADER_STAGE_NONE:
			break;
		default: HCC_ABORT("unhandled shader stage");
	}

	c->spirvgen.value_base_id = c->spirvgen.next_id;
	c->spirvgen.next_id += ir_function->values_count;

	U32 call_params_base_spirv_id = c->spirvgen.next_id;
	c->spirvgen.next_id += ir_function->call_param_data_types_count;

	//
	// generate the local variable types before we make the local variables and the global variables have a linear spirv id range
	{
		if (function->shader_stage == HCC_FUNCTION_SHADER_STAGE_NONE) {
			//
			// function parameters
			for (U32 variable_idx = 0; variable_idx < function->params_count; variable_idx += 1) {
				HccVariable* variable = &c->astgen.function_params_and_variables[function->params_start_idx + variable_idx];
				hcc_spirvgen_generate_variable_type(c, variable->data_type, HCC_SPIRV_TYPE_KIND_FUNCTION_VARIABLE);
			}
		}

		//
		// local variables
		for (U32 variable_idx = function->params_count; variable_idx < function->variables_count; variable_idx += 1) {
			HccVariable* variable = &c->astgen.function_params_and_variables[function->params_start_idx + variable_idx];
			hcc_spirvgen_generate_variable_type(c, variable->data_type, variable->is_static ? HCC_SPIRV_TYPE_KIND_STATIC_VARIABLE : HCC_SPIRV_TYPE_KIND_FUNCTION_VARIABLE);
		}

		//
		// local variables for every function call argument.
		HccDataType* function_call_param_data_types = hcc_stack_get_or_null(c->irgen.function_call_param_data_types, ir_function->call_param_data_types_start_idx);
		for (U32 variable_idx = 0; variable_idx < ir_function->call_param_data_types_count; variable_idx += 1) {
			hcc_spirvgen_generate_variable_type(c, function_call_param_data_types[variable_idx], HCC_SPIRV_TYPE_KIND_FUNCTION_VARIABLE);
		}
	}

	for (U32 basic_block_idx = ir_function->basic_blocks_start_idx; basic_block_idx < ir_function->basic_blocks_start_idx + (U32)ir_function->basic_blocks_count; basic_block_idx += 1) {
		HccIRBasicBlock* basic_block = hcc_stack_get(c->irgen.basic_blocks, basic_block_idx);

		if (basic_block_idx == ir_function->basic_blocks_start_idx) {
			//
			// function params
			for (U32 variable_idx = 0; variable_idx < function->params_count; variable_idx += 1) {
				if (function->shader_stage == HCC_FUNCTION_SHADER_STAGE_NONE) {
					HccVariable* variable = &c->astgen.function_params_and_variables[function->params_start_idx + variable_idx];
					U32 type_spirv_id = hcc_spirvgen_generate_variable_type(c, variable->data_type, HCC_SPIRV_TYPE_KIND_FUNCTION_VARIABLE);
					hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_FUNCTION_PARAMETER);
					hcc_spirvgen_instr_add_operand(c, type_spirv_id);
					hcc_spirvgen_instr_add_operand(c, c->spirvgen.local_variable_base_spirv_id + variable_idx);
					hcc_spirvgen_instr_end(c);
				}
			}
		}

		hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_LABEL);
		hcc_spirvgen_instr_add_operand(c, c->spirvgen.basic_block_base_spirv_id + (basic_block_idx - ir_function->basic_blocks_start_idx));
		hcc_spirvgen_instr_end(c);

		if (basic_block_idx == ir_function->basic_blocks_start_idx) {
			//
			// local variables
			for (U32 variable_idx = function->params_count; variable_idx < function->variables_count; variable_idx += 1) {
				HccVariable* variable = hcc_stack_get(c->astgen.function_params_and_variables, function->params_start_idx + variable_idx);
				U32 type_spirv_id = hcc_spirvgen_generate_variable_type(c, variable->data_type, variable->is_static ? HCC_SPIRV_TYPE_KIND_STATIC_VARIABLE : HCC_SPIRV_TYPE_KIND_FUNCTION_VARIABLE);
				hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_VARIABLE);
				hcc_spirvgen_instr_add_operand(c, type_spirv_id);
				hcc_spirvgen_instr_add_operand(c, c->spirvgen.local_variable_base_spirv_id + variable_idx);
				if (variable->is_static) {
					hcc_spirvgen_instr_add_operand(c, HCC_SPIRV_STORAGE_CLASS_PRIVATE);
					hcc_spirvgen_instr_add_converted_operand(c, HCC_IR_OPERAND_CONSTANT_INIT(variable->initializer_constant_id.idx_plus_one));
				} else {
					hcc_spirvgen_instr_add_operand(c, HCC_SPIRV_STORAGE_CLASS_FUNCTION);
				}
				hcc_spirvgen_instr_end(c);
			}

			//
			// these are the local variables for every function call argument so that the value can be stored in here
			// before the call to the function. it has to be done this way so that the argument has the same data type
			// as the function param which is a 'pointer' to the actual data type.
			HccDataType* function_call_param_data_types = hcc_stack_get_or_null(c->irgen.function_call_param_data_types, ir_function->call_param_data_types_start_idx);
			for (U32 idx = 0; idx < ir_function->call_param_data_types_count; idx += 1) {
				U32 type_spirv_id = hcc_spirvgen_generate_variable_type(c, function_call_param_data_types[idx], HCC_SPIRV_TYPE_KIND_FUNCTION_VARIABLE);
				hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_VARIABLE);
				hcc_spirvgen_instr_add_operand(c, type_spirv_id);
				hcc_spirvgen_instr_add_operand(c, call_params_base_spirv_id + idx);
				hcc_spirvgen_instr_add_operand(c, HCC_SPIRV_STORAGE_CLASS_FUNCTION);
				hcc_spirvgen_instr_end(c);
			}
		}

		for (U32 instruction_idx = basic_block->instructions_start_idx; instruction_idx < basic_block->instructions_start_idx + (U32)basic_block->instructions_count; instruction_idx += 1) {
			HccIRInstr* instruction = hcc_stack_get(c->irgen.instructions, ir_function->instructions_start_idx + instruction_idx);
			HccIROperand* operands = hcc_stack_get(c->irgen.operands, ir_function->operands_start_idx + (U32)instruction->operands_start_idx);
			switch (instruction->op_code) {
				case HCC_IR_OP_CODE_PTR_LOAD: {
					U32 type_spirv_id = hcc_spirvgen_resolve_type_id(c, hcc_irgen_operand_data_type(c, function, ir_function, operands[0]));
					U32 src_operand_spirv_id = hcc_spirvgen_convert_operand(c, operands[1]);
					hcc_spirvgen_generate_load(c, type_spirv_id, hcc_spirvgen_convert_operand(c, operands[0]), src_operand_spirv_id);
					break;
				};
				case HCC_IR_OP_CODE_PTR_STORE: {
					U32 dst_spirv_id = hcc_spirvgen_convert_operand(c, operands[0]);
					U32 src_spirv_id = hcc_spirvgen_convert_operand(c, operands[1]);
					hcc_spirvgen_generate_store(c, dst_spirv_id, src_spirv_id);
					break;
				};
				case HCC_IR_OP_CODE_COMPOSITE_INIT: {
					hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_COMPOSITE_CONSTRUCT);
					U32 return_value_idx = HCC_IR_OPERAND_VALUE_IDX(operands[0]);
					HccIRValue* return_value = hcc_stack_get(c->irgen.values, ir_function->values_start_idx + return_value_idx);

					hcc_spirvgen_instr_add_operand(c, hcc_spirvgen_resolve_type_id(c, return_value->data_type));

					for (U32 i = 0; i < instruction->operands_count; i += 1) {
						hcc_spirvgen_instr_add_converted_operand(c, operands[i]);
					}

					U32 fields_count = hcc_data_type_composite_fields_count(c, return_value->data_type);
					for (U32 i = instruction->operands_count; i < fields_count + 1; i += 1) {
						hcc_spirvgen_instr_add_converted_operand(c, operands[instruction->operands_count - 1]);
					}

					hcc_spirvgen_instr_end(c);
					break;
				};
				case HCC_IR_OP_CODE_PTR_ACCESS_CHAIN: {
					U32 data_type_spirv_id = hcc_spirvgen_generate_variable_type(c, operands[2], HCC_SPIRV_TYPE_KIND_FUNCTION_VARIABLE);

					hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_IN_BOUNDS_ACCESS_CHAIN);
					hcc_spirvgen_instr_add_operand(c, data_type_spirv_id);
					hcc_spirvgen_instr_add_converted_operand(c, operands[0]);
					hcc_spirvgen_instr_add_converted_operand(c, operands[1]);
					for (U32 i = 3; i < instruction->operands_count; i += 1) {
						hcc_spirvgen_instr_add_converted_operand(c, operands[i]);
					}
					hcc_spirvgen_instr_end(c);
					break;
				};
				case HCC_IR_OP_CODE_FUNCTION_RETURN: {
					switch (function->shader_stage) {
						case HCC_FUNCTION_SHADER_STAGE_VERTEX: {
							HccDataType data_type = hcc_irgen_operand_data_type(c, function, ir_function, operands[0]);
							data_type = hcc_typedef_resolve_and_strip_const_volatile(c, data_type);

							U32 var_spirv_id = hcc_spirvgen_convert_operand(c, operands[0]);
							for (U32 field_idx = 0; field_idx < c->spirvgen.rasterizer_state_compound_data_type->fields_count; field_idx += 1) {
								HccCompoundField* field = hcc_stack_get(c->astgen.compound_fields, c->spirvgen.rasterizer_state_compound_data_type->fields_start_idx + field_idx);
								HccDataType field_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, field->data_type);
								U32 field_spirv_id = hcc_spirvgen_generate_access_chain_single_field(c, var_spirv_id, field_data_type, field_idx);
								U32 src_spirv_id = c->spirvgen.next_id;
								c->spirvgen.next_id += 1;
								hcc_spirvgen_generate_load(c, hcc_spirvgen_resolve_type_id(c, field_data_type), src_spirv_id, field_spirv_id);
								if (field->rasterizer_state_field_kind == HCC_RASTERIZER_STATE_FIELD_KIND_POSITION) {
									hcc_spirvgen_generate_store(c, position_spirv_id, src_spirv_id);
								}

								hcc_spirvgen_generate_store(c, c->spirvgen.rasterizer_state_variable_start_spirv_id + field_idx, src_spirv_id);
							}
							break;
						};
						case HCC_FUNCTION_SHADER_STAGE_FRAGMENT: {
							HccDataType data_type = hcc_irgen_operand_data_type(c, function, ir_function, operands[0]);
							data_type = hcc_typedef_resolve_and_strip_const_volatile(c, data_type);

							U32 var_spirv_id = hcc_spirvgen_convert_operand(c, operands[0]);
							for (U32 field_idx = 0; field_idx < fragment_state_compound_data_type->fields_count; field_idx += 1) {
								HccCompoundField* field = hcc_stack_get(c->astgen.compound_fields, fragment_state_compound_data_type->fields_start_idx + field_idx);
								HccDataType field_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, field->data_type);
								U32 field_spirv_id = hcc_spirvgen_generate_access_chain_single_field(c, var_spirv_id, field_data_type, field_idx);
								U32 src_spirv_id = c->spirvgen.next_id;
								c->spirvgen.next_id += 1;
								hcc_spirvgen_generate_load(c, hcc_spirvgen_resolve_type_id(c, field_data_type), src_spirv_id, field_spirv_id);
								hcc_spirvgen_generate_store(c, fragment_state_variable_start_spirv_id + field_idx, src_spirv_id);
							}
							break;
						};
					}

					if (return_data_type == HCC_DATA_TYPE_VOID) {
						hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_RETURN);
						hcc_spirvgen_instr_end(c);
					} else {
						hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_RETURN_VALUE);
						hcc_spirvgen_instr_add_converted_operand(c, operands[0]);
						hcc_spirvgen_instr_end(c);
					}

					break;
				};
				case HCC_IR_OP_CODE_LOOP_MERGE: {
					hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_LOOP_MERGE);
					hcc_spirvgen_instr_add_converted_operand(c, operands[0]);
					hcc_spirvgen_instr_add_converted_operand(c, operands[1]);
					hcc_spirvgen_instr_add_operand(c, HCC_SPIRV_LOOP_CONTROL_NONE);
					hcc_spirvgen_instr_end(c);
					break;
				};
				case HCC_IR_OP_CODE_SELECTION_MERGE: {
					hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_SELECTION_MERGE);
					hcc_spirvgen_instr_add_converted_operand(c, operands[0]);
					hcc_spirvgen_instr_add_operand(c, HCC_SPIRV_SELECTION_CONTROL_NONE);
					hcc_spirvgen_instr_end(c);
					break;
				};
				case HCC_IR_OP_CODE_BINARY_OP(ADD):
				case HCC_IR_OP_CODE_BINARY_OP(SUBTRACT):
				case HCC_IR_OP_CODE_BINARY_OP(MULTIPLY):
				case HCC_IR_OP_CODE_BINARY_OP(DIVIDE):
				case HCC_IR_OP_CODE_BINARY_OP(MODULO):
				case HCC_IR_OP_CODE_BINARY_OP(BIT_AND):
				case HCC_IR_OP_CODE_BINARY_OP(BIT_OR):
				case HCC_IR_OP_CODE_BINARY_OP(BIT_XOR):
				case HCC_IR_OP_CODE_BINARY_OP(BIT_SHIFT_LEFT):
				case HCC_IR_OP_CODE_BINARY_OP(BIT_SHIFT_RIGHT):
				case HCC_IR_OP_CODE_BINARY_OP(EQUAL):
				case HCC_IR_OP_CODE_BINARY_OP(NOT_EQUAL):
				case HCC_IR_OP_CODE_BINARY_OP(LESS_THAN):
				case HCC_IR_OP_CODE_BINARY_OP(LESS_THAN_OR_EQUAL):
				case HCC_IR_OP_CODE_BINARY_OP(GREATER_THAN):
				case HCC_IR_OP_CODE_BINARY_OP(GREATER_THAN_OR_EQUAL):
				{
					U32 return_value_idx = HCC_IR_OPERAND_VALUE_IDX(operands[0]);
					HccIRValue* return_value = hcc_stack_get(c->irgen.values, ir_function->values_start_idx + return_value_idx);

					HccBinaryOp binary_op = instruction->op_code - HCC_IR_OP_CODE_BINARY_OP_START;
					HccDataType resolved_data_type = hcc_irgen_operand_data_type(c, function, ir_function, operands[1]);
					resolved_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, resolved_data_type);
					HccBasicTypeClass type_class = hcc_basic_type_class(c, resolved_data_type);
					HccSpirvOp spirv_op = hcc_spirv_binary_ops[binary_op][type_class];
					HCC_DEBUG_ASSERT(spirv_op != HCC_SPIRV_OP_NO_OP, "internal error: invalid configuration for a binary op");

					hcc_spirvgen_instr_start(c, spirv_op);
					hcc_spirvgen_instr_add_operand(c, hcc_spirvgen_resolve_type_id(c, return_value->data_type));
					hcc_spirvgen_instr_add_converted_operand(c, operands[0]);
					hcc_spirvgen_instr_add_converted_operand(c, operands[1]);
					hcc_spirvgen_instr_add_converted_operand(c, operands[2]);
					hcc_spirvgen_instr_end(c);
					break;
				};
				case HCC_IR_OP_CODE_UNARY_OP(LOGICAL_NOT):
				case HCC_IR_OP_CODE_UNARY_OP(BIT_NOT):
				case HCC_IR_OP_CODE_UNARY_OP(NEGATE):
				{
					U32 return_value_idx = HCC_IR_OPERAND_VALUE_IDX(operands[0]);
					HccIRValue* return_value = hcc_stack_get(c->irgen.values, ir_function->values_start_idx + return_value_idx);

					HccDataType data_type = hcc_irgen_operand_data_type(c, function, ir_function, operands[1]);
					HccBasicTypeClass type_class = hcc_basic_type_class(c, data_type);

					HccUnaryOp unary_op = instruction->op_code - HCC_IR_OP_CODE_UNARY_OP_START;
					HccSpirvOp spirv_op = hcc_spirv_unary_ops[unary_op][type_class];
					HCC_DEBUG_ASSERT(spirv_op != HCC_SPIRV_OP_NO_OP, "internal error: invalid configuration for a unary op");

					hcc_spirvgen_instr_start(c, spirv_op);
					hcc_spirvgen_instr_add_operand(c, hcc_spirvgen_resolve_type_id(c, return_value->data_type));
					hcc_spirvgen_instr_add_converted_operand(c, operands[0]);
					hcc_spirvgen_instr_add_converted_operand(c, operands[1]);
					hcc_spirvgen_instr_end(c);
					break;
				};
				case HCC_IR_OP_CODE_BRANCH: {
					hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_BRANCH);
					hcc_spirvgen_instr_add_converted_operand(c, operands[0]);
					hcc_spirvgen_instr_end(c);
					break;
				};
				case HCC_IR_OP_CODE_BRANCH_CONDITIONAL: {
					hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_BRANCH_CONDITIONAL);
					hcc_spirvgen_instr_add_converted_operand(c, operands[0]);
					hcc_spirvgen_instr_add_converted_operand(c, operands[1]);
					hcc_spirvgen_instr_add_converted_operand(c, operands[2]);
					hcc_spirvgen_instr_end(c);
					break;
				};
				case HCC_IR_OP_CODE_SWITCH: {
					hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_SWITCH);
					hcc_spirvgen_instr_add_converted_operand(c, operands[0]);
					hcc_spirvgen_instr_add_converted_operand(c, operands[1]);
					for (U32 idx = 2; idx < instruction->operands_count; idx += 2) {
						HccConstant constant = hcc_constant_table_get(c, HCC_IR_OPERAND_CONSTANT_ID(operands[idx + 0]));

						switch (c->basic_type_size_and_aligns[constant.data_type]) {
							case sizeof(U8):
								hcc_spirvgen_instr_add_operand(c, *(U8*)constant.data);
								break;
							case sizeof(U16):
								hcc_spirvgen_instr_add_operand(c, *(U16*)constant.data);
								break;
							case sizeof(U32):
								hcc_spirvgen_instr_add_operand(c, *(U32*)constant.data);
								break;
							case sizeof(U64):
								hcc_spirvgen_instr_add_operand(c, ((U32*)constant.data)[0]);
								hcc_spirvgen_instr_add_operand(c, ((U32*)constant.data)[1]);
								break;
							default:
								HCC_UNREACHABLE("internal error: unhandled data type %u", constant.data_type);
						}

						hcc_spirvgen_instr_add_converted_operand(c, operands[idx + 1]);
					}
					hcc_spirvgen_instr_end(c);
					break;
				};
				case HCC_IR_OP_CODE_CONVERT: {
					HccDataType dst_type = operands[1];
					HccDataType src_type = hcc_irgen_operand_data_type(c, function, ir_function, operands[2]);
					dst_type = hcc_typedef_resolve_and_strip_const_volatile(c, dst_type);
					src_type = hcc_typedef_resolve_and_strip_const_volatile(c, src_type);
					HccBasicTypeClass dst_type_class = hcc_basic_type_class(c, dst_type);
					HccBasicTypeClass src_type_class = hcc_basic_type_class(c, src_type);

					U32 result_spirv_operand = hcc_spirvgen_convert_operand(c, operands[0]);
					U32 src_spirv_operand = hcc_spirvgen_convert_operand(c, operands[2]);
					switch (dst_type_class) {
						///////////////////////////////////////
						// case HCC_BASIC_TYPE_CLASS_BOOL:
						// ^^ this is handled in the HccIRGen, see hcc_irgen_generate_convert_to_bool
						///////////////////////////////////////

						case HCC_BASIC_TYPE_CLASS_UINT:
							switch (src_type_class) {
								case HCC_BASIC_TYPE_CLASS_BOOL: {
									U32 true_spirv_operand = c->spirvgen.constant_base_id + c->basic_type_one_constant_ids[dst_type].idx_plus_one - 1;
									U32 false_spirv_operand = c->spirvgen.constant_base_id + c->basic_type_zero_constant_ids[dst_type].idx_plus_one - 1;
									hcc_spirvgen_generate_select(c, result_spirv_operand, dst_type, src_spirv_operand, true_spirv_operand, false_spirv_operand);
									break;
								};
								case HCC_BASIC_TYPE_CLASS_UINT:
									hcc_spirvgen_generate_convert(c, HCC_SPIRV_OP_U_CONVERT, result_spirv_operand, dst_type, src_spirv_operand);
									break;
								case HCC_BASIC_TYPE_CLASS_SINT: {
									HccDataType signed_dst_type = hcc_data_type_unsigned_to_signed(c, dst_type);
									if (signed_dst_type != src_type) {
										hcc_spirvgen_generate_convert(c, HCC_SPIRV_OP_S_CONVERT, c->spirvgen.next_id, signed_dst_type, src_spirv_operand);
										src_spirv_operand = c->spirvgen.next_id;
										c->spirvgen.next_id += 1;
									}
									hcc_spirvgen_generate_convert(c, HCC_SPIRV_OP_BITCAST, result_spirv_operand, dst_type, src_spirv_operand);
									break;
								};
								case HCC_BASIC_TYPE_CLASS_FLOAT:
									hcc_spirvgen_generate_convert(c, HCC_SPIRV_OP_CONVERT_F_TO_U, result_spirv_operand, dst_type, src_spirv_operand);
									break;
								default:
									HCC_UNREACHABLE();
							}
							break;
						case HCC_BASIC_TYPE_CLASS_SINT:
							switch (src_type_class) {
								case HCC_BASIC_TYPE_CLASS_BOOL: {
									U32 true_spirv_operand = c->spirvgen.constant_base_id + c->basic_type_one_constant_ids[dst_type].idx_plus_one - 1;
									U32 false_spirv_operand = c->spirvgen.constant_base_id + c->basic_type_zero_constant_ids[dst_type].idx_plus_one - 1;
									hcc_spirvgen_generate_select(c, result_spirv_operand, dst_type, src_spirv_operand, true_spirv_operand, false_spirv_operand);
									break;
								};
								case HCC_BASIC_TYPE_CLASS_UINT: {
									HccDataType unsigned_dst_type = hcc_data_type_signed_to_unsigned(c, dst_type);
									if (unsigned_dst_type != src_type) {
										hcc_spirvgen_generate_convert(c, HCC_SPIRV_OP_U_CONVERT, c->spirvgen.next_id, unsigned_dst_type, src_spirv_operand);
										src_spirv_operand = c->spirvgen.next_id;
										c->spirvgen.next_id += 1;
									}
									hcc_spirvgen_generate_convert(c, HCC_SPIRV_OP_BITCAST, result_spirv_operand, dst_type, src_spirv_operand);
									break;
								};
								case HCC_BASIC_TYPE_CLASS_SINT: {
									hcc_spirvgen_generate_convert(c, HCC_SPIRV_OP_S_CONVERT, result_spirv_operand, dst_type, src_spirv_operand);
									break;
								};
								case HCC_BASIC_TYPE_CLASS_FLOAT:
									hcc_spirvgen_generate_convert(c, HCC_SPIRV_OP_CONVERT_F_TO_S, result_spirv_operand, dst_type, src_spirv_operand);
									break;
								default:
									HCC_UNREACHABLE();
							}
							break;
						case HCC_BASIC_TYPE_CLASS_FLOAT:
							switch (src_type_class) {
								case HCC_BASIC_TYPE_CLASS_BOOL: {
									U32 true_spirv_operand = c->spirvgen.constant_base_id + c->basic_type_one_constant_ids[dst_type].idx_plus_one - 1;
									U32 false_spirv_operand = c->spirvgen.constant_base_id + c->basic_type_zero_constant_ids[dst_type].idx_plus_one - 1;
									hcc_spirvgen_generate_select(c, result_spirv_operand, dst_type, src_spirv_operand, true_spirv_operand, false_spirv_operand);
									break;
								};
								case HCC_BASIC_TYPE_CLASS_UINT:
									hcc_spirvgen_generate_convert(c, HCC_SPIRV_OP_CONVERT_U_TO_F, result_spirv_operand, dst_type, src_spirv_operand);
									break;
								case HCC_BASIC_TYPE_CLASS_SINT: {
									hcc_spirvgen_generate_convert(c, HCC_SPIRV_OP_CONVERT_S_TO_F, result_spirv_operand, dst_type, src_spirv_operand);
									break;
								};
								case HCC_BASIC_TYPE_CLASS_FLOAT:
									hcc_spirvgen_generate_convert(c, HCC_SPIRV_OP_F_CONVERT, result_spirv_operand, dst_type, src_spirv_operand);
									break;
								default:
									HCC_UNREACHABLE();
							}
							break;
						default:
							HCC_UNREACHABLE();
					}

					break;
				};
				case HCC_IR_OP_CODE_BITCAST: {
					U32 type_spirv_id = hcc_spirvgen_resolve_type_id(c, operands[1]);
					hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_BITCAST);
					hcc_spirvgen_instr_add_operand(c, type_spirv_id);
					hcc_spirvgen_instr_add_converted_operand(c, operands[0]);
					hcc_spirvgen_instr_add_converted_operand(c, operands[2]);
					hcc_spirvgen_instr_end(c);
					break;
				};
				case HCC_IR_OP_CODE_BITCAST_PTR: {
					U32 type_spirv_id = hcc_spirvgen_generate_variable_type(c, operands[1], HCC_SPIRV_TYPE_KIND_FUNCTION_VARIABLE);
					hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_BITCAST);
					hcc_spirvgen_instr_add_operand(c, type_spirv_id);
					hcc_spirvgen_instr_add_converted_operand(c, operands[0]);
					hcc_spirvgen_instr_add_converted_operand(c, operands[2]);
					hcc_spirvgen_instr_end(c);
					break;
				};
				case HCC_IR_OP_CODE_PHI: {
					hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_PHI);
					HccDataType data_type = hcc_irgen_operand_data_type(c, function, ir_function, operands[1]);
					hcc_spirvgen_instr_add_operand(c, hcc_spirvgen_resolve_type_id(c, data_type));
					for (U32 idx = 0; idx < instruction->operands_count; idx += 1) {
						hcc_spirvgen_instr_add_converted_operand(c, operands[idx]);
					}
					hcc_spirvgen_instr_end(c);
					break;
				};
				case HCC_IR_OP_CODE_UNREACHABLE:
					hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_UNREACHABLE);
					hcc_spirvgen_instr_end(c);
					break;
				case HCC_IR_OP_CODE_SELECT: {
					U32 return_value_idx = HCC_IR_OPERAND_VALUE_IDX(operands[0]);
					HccIRValue* return_value = hcc_stack_get(c->irgen.values, ir_function->values_start_idx + return_value_idx);

					hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_SELECT);
					hcc_spirvgen_instr_add_converted_operand(c, return_value->data_type);
					hcc_spirvgen_instr_add_converted_operand(c, operands[0]);
					hcc_spirvgen_instr_add_converted_operand(c, operands[1]);
					hcc_spirvgen_instr_add_converted_operand(c, operands[2]);
					hcc_spirvgen_instr_add_converted_operand(c, operands[3]);
					hcc_spirvgen_instr_end(c);
					break;
				};
				case HCC_IR_OP_CODE_FUNCTION_CALL: {
					U32 return_value_idx = HCC_IR_OPERAND_VALUE_IDX(operands[0]);
					HccIRValue* return_value = hcc_stack_get(c->irgen.values, ir_function->values_start_idx + return_value_idx);

					U32 function_idx = HCC_IR_OPERAND_FUNCTION_IDX(operands[1]);
					if (function_idx < HCC_FUNCTION_IDX_USER_START) {
						HccDataType return_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, return_value->data_type);
						hcc_spirvgen_generate_intrinsic_function(c, function, ir_function, function_idx, return_data_type, operands, instruction->operands_count);
						break;
					}

					//
					// store the arguments inside the local variabes that were made at the
					// beginning of the function.
					for (U32 idx = 2; idx < instruction->operands_count; idx += 1) {
						U32 src_spirv_id = hcc_spirvgen_convert_operand(c, operands[idx]);
						hcc_spirvgen_generate_store(c, call_params_base_spirv_id + idx - 2, src_spirv_id);
					}

					hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_FUNCTION_CALL);
					hcc_spirvgen_instr_add_converted_operand(c, return_value->data_type);
					hcc_spirvgen_instr_add_converted_operand(c, operands[0]);
					hcc_spirvgen_instr_add_converted_operand(c, operands[1]);

					for (U32 idx = 2; idx < instruction->operands_count; idx += 1) {
						hcc_spirvgen_instr_add_operand(c, call_params_base_spirv_id + idx - 2);
					}

					hcc_spirvgen_instr_end(c);

					call_params_base_spirv_id += instruction->operands_count - 2;
					break;
				};
				default:
					HCC_ABORT("unhandled instruction '%u'", instruction->op_code);
			}
		}
	}

	hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_FUNCTION_END);
	hcc_spirvgen_instr_end(c);
}

void hcc_spirvgen_generate_intrinsic_types(HccCompiler* c) {
	//
	// HCC_INTRINSIC_TYPE_VOID
	hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_TYPE_VOID);
	hcc_spirvgen_instr_add_result_operand(c);
	hcc_spirvgen_instr_end(c);

	//
	// HCC_INTRINSIC_TYPE_BOOL
	hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_TYPE_BOOL);
	hcc_spirvgen_instr_add_result_operand(c);
	hcc_spirvgen_instr_end(c);

	//
	// HCC_INTRINSIC_TYPE_S8 - HCC_INTRINSIC_TYPE_S64
	for (U32 i = 3; i < 7; i += 1) {
		HccIntrinsicType intrinsic_type = HCC_INTRINSIC_TYPE_S8 + i - 3;
		if (!hcc_spirvgen_basic_type_is_supported(c, intrinsic_type)) {
			c->spirvgen.next_id += 1;
			continue;
		}

		hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_TYPE_INT);
		hcc_spirvgen_instr_add_result_operand(c);
		hcc_spirvgen_instr_add_operand(c, 1 << i);
		hcc_spirvgen_instr_add_operand(c, 1);
		hcc_spirvgen_instr_end(c);
	}

	//
	// HCC_INTRINSIC_TYPE_U8 - HCC_INTRINSIC_TYPE_U64
	for (U32 i = 3; i < 7; i += 1) {
		HccDataType data_type = c->spirvgen.next_id - 1;
		HccIntrinsicType intrinsic_type = HCC_INTRINSIC_TYPE_U8 + i - 3;
		if (!hcc_spirvgen_basic_type_is_supported(c, intrinsic_type)) {
			c->spirvgen.next_id += 1;
			continue;
		}

		hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_TYPE_INT);
		hcc_spirvgen_instr_add_result_operand(c);
		hcc_spirvgen_instr_add_operand(c, 1 << i);
		hcc_spirvgen_instr_add_operand(c, 0);
		hcc_spirvgen_instr_end(c);
	}

	//
	// HCC_INTRINSIC_TYPE_F16 - HCC_INTRINSIC_TYPE_F64
	for (U32 i = 4; i < 7; i += 1) {
		HccDataType data_type = c->spirvgen.next_id - 1;
		HccIntrinsicType intrinsic_type = HCC_INTRINSIC_TYPE_F16 + i - 4;
		if (!hcc_spirvgen_basic_type_is_supported(c, intrinsic_type)) {
			c->spirvgen.next_id += 1;
			continue;
		}

		hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_TYPE_FLOAT);
		hcc_spirvgen_instr_add_result_operand(c);
		hcc_spirvgen_instr_add_operand(c, 1 << i);
		hcc_spirvgen_instr_end(c);
	}

	//
	// HCC_INTRINSIC_TYPE_VECTOR_START - HCC_INTRINSIC_TYPE_VECTOR_END
	for (U32 num_comps = 2; num_comps < 5; num_comps += 1) {
		for (HccIntrinsicType scalar_intrinsic_type = HCC_INTRINSIC_TYPE_BOOL; scalar_intrinsic_type < HCC_INTRINSIC_TYPE_VECTOR_START; scalar_intrinsic_type += 1) {
			if (!hcc_spirvgen_basic_type_is_supported(c, scalar_intrinsic_type)) {
				c->spirvgen.next_id += 1;
				continue;
			}

			hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_TYPE_VECTOR);
			hcc_spirvgen_instr_add_result_operand(c);
			hcc_spirvgen_instr_add_operand(c, HCC_SPIRV_ID_FROM_INTRINSIC_TYPE(scalar_intrinsic_type));
			hcc_spirvgen_instr_add_operand(c, num_comps);
			hcc_spirvgen_instr_end(c);
		}
	}

	//
	// HCC_INTRINSIC_TYPE_MATRIX_START - HCC_INTRINSIC_TYPE_MATRIX_END
	for (U32 columns_count = 2; columns_count < 5; columns_count += 1) {
		for (U32 rows_count = 2; rows_count < 5; rows_count += 1) {
			for (HccIntrinsicType scalar_intrinsic_type = HCC_INTRINSIC_TYPE_F32; scalar_intrinsic_type <= HCC_INTRINSIC_TYPE_F64; scalar_intrinsic_type += 1) {
				if (!hcc_spirvgen_basic_type_is_supported(c, scalar_intrinsic_type)) {
					c->spirvgen.next_id += 1;
					continue;
				}

				HccVec column_vec = ((rows_count - 2) * 12) + scalar_intrinsic_type - 1;
				HccDataType column_vector_data_type = HCC_DATA_TYPE_VECTOR(column_vec);
				U32 column_vector_spirv_id = hcc_spirvgen_resolve_type_id(c, column_vector_data_type);

				hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_TYPE_MATRIX);
				hcc_spirvgen_instr_add_result_operand(c);
				hcc_spirvgen_instr_add_operand(c, column_vector_spirv_id);
				hcc_spirvgen_instr_add_operand(c, columns_count);
				hcc_spirvgen_instr_end(c);
			}
		}
	}

	c->spirvgen.pointer_type_inputs_base_id = c->spirvgen.next_id;
	c->spirvgen.next_id += HCC_INTRINSIC_TYPE_COUNT;

	c->spirvgen.pointer_type_outputs_base_id = c->spirvgen.next_id;
	c->spirvgen.next_id += HCC_INTRINSIC_TYPE_COUNT;
}

void hcc_spirvgen_generate_basic_type_constants(HccCompiler* c) {
	HccConstantTable* constant_table = &c->constant_table;
	for (U32 idx = 0; idx < constant_table->entries_count; idx += 1) {
		HccConstantEntry* entry = &constant_table->entries[idx];
		if (!HCC_DATA_TYPE_IS_BASIC(entry->data_type)) {
			continue;
		}

		U32 data_type_spirv_id = hcc_spirvgen_resolve_type_id(c, entry->data_type);
		if (
			HCC_SPIRV_ID_IS_INTRINSIC_TYPE(data_type_spirv_id) &&
			!hcc_spirvgen_basic_type_is_supported(c, HCC_SPIRV_ID_TO_INTRINSIC_TYPE(data_type_spirv_id))
		) {
			continue;
		}

		if (entry->size == 0) {
			hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_CONSTANT_NULL);
			hcc_spirvgen_instr_add_operand(c, data_type_spirv_id);
			hcc_spirvgen_instr_add_operand(c, c->spirvgen.constant_base_id + idx);
			hcc_spirvgen_instr_end(c);
		} else if (entry->data_type == HCC_DATA_TYPE_BOOL) {
			bool is_true = c->basic_type_one_constant_ids[HCC_DATA_TYPE_BOOL].idx_plus_one == idx + 1;
			hcc_spirvgen_instr_start(c, is_true ? HCC_SPIRV_OP_CONSTANT_TRUE : HCC_SPIRV_OP_CONSTANT_FALSE);
			hcc_spirvgen_instr_add_operand(c, hcc_spirvgen_resolve_type_id(c, HCC_DATA_TYPE_BOOL));
			hcc_spirvgen_instr_add_operand(c, c->spirvgen.constant_base_id + idx);
			hcc_spirvgen_instr_end(c);
		} else if (HCC_DATA_TYPE_IS_BASIC(entry->data_type)) {
			hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_CONSTANT);
			hcc_spirvgen_instr_add_operand(c, hcc_spirvgen_resolve_type_id(c, entry->data_type));
			hcc_spirvgen_instr_add_operand(c, c->spirvgen.constant_base_id + idx);

			void* data = HCC_PTR_ADD(constant_table->data, entry->start_idx);
			switch (c->basic_type_size_and_aligns[entry->data_type]) {
				case sizeof(U64):
					// TODO: big endian might need a manual swap here?
					hcc_spirvgen_instr_add_operand(c, ((U32*)data)[0]);
					hcc_spirvgen_instr_add_operand(c, ((U32*)data)[1]);
					break;
				case sizeof(U32): hcc_spirvgen_instr_add_operand(c, *(U32*)data); break;
				case sizeof(U16): hcc_spirvgen_instr_add_operand(c, *(U16*)data); break;
				case sizeof(U8): hcc_spirvgen_instr_add_operand(c, *(U8*)data); break;
			}

			hcc_spirvgen_instr_end(c);
		}
	}
}

void hcc_spirvgen_generate_non_basic_type_constants(HccCompiler* c) {
	HccConstantTable* constant_table = &c->constant_table;
	for (U32 idx = 0; idx < constant_table->entries_count; idx += 1) {
		HccConstantEntry* entry = &constant_table->entries[idx];
		if (HCC_DATA_TYPE_IS_BASIC(entry->data_type)) {
			continue;
		}

		if (entry->size == 0) {
			hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_CONSTANT_NULL);
			hcc_spirvgen_instr_add_operand(c, hcc_spirvgen_resolve_type_id(c, entry->data_type));
			hcc_spirvgen_instr_add_operand(c, c->spirvgen.constant_base_id + idx);
			hcc_spirvgen_instr_end(c);
		} else {
			hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_CONSTANT_COMPOSITE);
			hcc_spirvgen_instr_add_operand(c, hcc_spirvgen_resolve_type_id(c, entry->data_type));
			hcc_spirvgen_instr_add_operand(c, c->spirvgen.constant_base_id + idx);

			HccConstantId* constants = HCC_PTR_ADD(constant_table->data, entry->start_idx);
			for (U32 i = 0; i < entry->size / sizeof(HccConstantId); i += 1) {
				hcc_spirvgen_instr_add_operand(c, c->spirvgen.constant_base_id + (constants[i].idx_plus_one - 1));
			}

			hcc_spirvgen_instr_end(c);
		}
	}
}

void hcc_spirvgen_generate_load(HccCompiler* c, U32 type_spirv_id, U32 result_id, U32 src_spirv_id) {
	hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_LOAD);
	hcc_spirvgen_instr_add_operand(c, type_spirv_id);
	hcc_spirvgen_instr_add_operand(c, result_id);
	hcc_spirvgen_instr_add_operand(c, src_spirv_id);
	hcc_spirvgen_instr_end(c);
}

void hcc_spirvgen_generate_store(HccCompiler* c, U32 dst_spirv_id, U32 src_spirv_id) {
	hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_STORE);
	hcc_spirvgen_instr_add_operand(c, dst_spirv_id);
	hcc_spirvgen_instr_add_operand(c, src_spirv_id);
	hcc_spirvgen_instr_end(c);
}

U32 hcc_spirvgen_generate_access_chain_single_field(HccCompiler* c, U32 base_spirv_id, HccDataType field_data_type, U32 field_idx) {
	U32 data_type_spirv_id = hcc_spirvgen_generate_variable_type(c, field_data_type, HCC_SPIRV_TYPE_KIND_FUNCTION_VARIABLE);

	U32 spirv_id = c->spirvgen.next_id;
	hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_IN_BOUNDS_ACCESS_CHAIN);
	hcc_spirvgen_instr_add_operand(c, data_type_spirv_id);
	hcc_spirvgen_instr_add_result_operand(c);
	hcc_spirvgen_instr_add_operand(c, base_spirv_id);
	HccBasic basic = hcc_basic_from_uint(c, HCC_DATA_TYPE_UINT, field_idx);
	HccConstantId constant_id = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_UINT, &basic);
	hcc_spirvgen_instr_add_operand(c, c->spirvgen.constant_base_id + constant_id.idx_plus_one - 1);
	hcc_spirvgen_instr_end(c);
	return spirv_id;
}

void hcc_spirvgen_write_word_many(FILE* f, U32* words, U32 words_count, char* path) {
	U32 size = words_count * sizeof(U32);
	U32 written_size = fwrite(words, 1, size, f);
	HCC_ASSERT(size == written_size, "error writing file '%s'", path);
}

void hcc_spirvgen_write_word(FILE* f, U32 word, char* path) {
	U32 written_size = fwrite(&word, 1, sizeof(U32), f);
	HCC_ASSERT(sizeof(U32) == written_size, "error writing file '%s'", path);
}

void hcc_spirvgen_generate_binary(HccCompiler* c) {
	char* path = "test.spv";
	FILE* f = fopen(path, "wb");
	HCC_ASSERT(f, "error opening file for write '%s'");

	U32 magic_number = 0x07230203;
	hcc_spirvgen_write_word(f, magic_number, path);

	U32 major_version = 1;
	U32 minor_version = 5;
	U32 version = (major_version << 16) | (minor_version << 8);
	hcc_spirvgen_write_word(f, version, path);

	U32 generator_number = 0; // TODO: when we are feeling ballsy enough, register with the khronos folks and get a number for the lang.
	hcc_spirvgen_write_word(f, generator_number, path);

	hcc_spirvgen_write_word(f, c->spirvgen.next_id, path);

	U32 reserved_instruction_schema = 0;
	hcc_spirvgen_write_word(f, reserved_instruction_schema, path);

	hcc_spirvgen_write_word_many(f, c->spirvgen.out_capabilities, hcc_stack_count(c->spirvgen.out_capabilities), path);
	hcc_spirvgen_write_word_many(f, c->spirvgen.out_entry_points, hcc_stack_count(c->spirvgen.out_entry_points), path);
	hcc_spirvgen_write_word_many(f, c->spirvgen.out_debug_info, hcc_stack_count(c->spirvgen.out_debug_info), path);
	hcc_spirvgen_write_word_many(f, c->spirvgen.out_annotations, hcc_stack_count(c->spirvgen.out_annotations), path);
	hcc_spirvgen_write_word_many(f, c->spirvgen.out_types_variables_constants, hcc_stack_count(c->spirvgen.out_types_variables_constants), path);
	hcc_spirvgen_write_word_many(f, c->spirvgen.out_functions, hcc_stack_count(c->spirvgen.out_functions), path);

	fclose(f);
}

void hcc_spirvgen_generate_intrinsic_input_variable(HccCompiler* c, U32 intrinsic_idx) {
	HccCompoundDataType* d = hcc_stack_get(c->astgen.compound_data_types, intrinsic_idx);
	for (U32 field_idx = 0; field_idx < d->fields_count; field_idx += 1) {
		HccCompoundField* field = hcc_stack_get(c->astgen.compound_fields, d->fields_start_idx + field_idx);
		HccDataType field_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, field->data_type);
		hcc_spirvgen_generate_variable_type(c, field_data_type, HCC_SPIRV_TYPE_KIND_FUNCTION_VARIABLE_POINTER_INPUT);
	}
}

void hcc_spirvgen_generate(HccCompiler* c) {
	hcc_spirvgen_generate_intrinsic_types(c);

	//
	// make sure we have constants for rasterizer state field indices
	// when we make access chains to them.
	for (U32 field_idx = 0; field_idx < 16; field_idx += 1) {
		HccBasic basic = hcc_basic_from_uint(c, HCC_DATA_TYPE_UINT, field_idx);
		hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_UINT, (HccBasic*)&field_idx);
	}

	// generates the basic type constant before we make the array types (that use the constants)
	c->spirvgen.constant_base_id = c->spirvgen.next_id;
	c->spirvgen.next_id += c->constant_table.entries_count;
	hcc_spirvgen_generate_basic_type_constants(c);

	{
		c->spirvgen.array_type_base_id = c->spirvgen.next_id;
		c->spirvgen.next_id += hcc_stack_count(c->astgen.array_data_types);

		c->spirvgen.compound_type_base_id = c->spirvgen.next_id;
		c->spirvgen.next_id += hcc_stack_count(c->astgen.compound_data_types);

		for (U32 i = 0; i < hcc_stack_count(c->astgen.ordered_data_types); i += 1) {
			HccDataType data_type = c->astgen.ordered_data_types[i];
			if (data_type == HCC_DATA_TYPE_HALF && !hcc_spirvgen_basic_type_is_supported(c, HCC_INTRINSIC_TYPE_U16)) {
				// skip emitting the userland structure when U16 support is not available
				continue;
			}

			if (hcc_data_type_has_intrinsic_basic_types(c, data_type) & ~c->spirvgen.available_basic_types) {
				// skip emitting the data types when they contain intrinsic basic data types that are not supported
				continue;
			}

			switch (data_type & 0xff) {
				case HCC_DATA_TYPE_STRUCT:
				case HCC_DATA_TYPE_UNION: {
					HccCompoundDataType* d = hcc_compound_data_type_get(c, data_type);

					hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_TYPE_STRUCT);
					hcc_spirvgen_instr_add_operand(c, c->spirvgen.compound_type_base_id + HCC_DATA_TYPE_IDX(data_type));
					if (HCC_DATA_TYPE_IS_UNION(data_type)) {
						HccCompoundField* largest_sized_field = hcc_stack_get(c->astgen.compound_fields, d->fields_start_idx + d->largest_sized_field_idx);
						hcc_spirvgen_instr_add_operand(c, hcc_spirvgen_resolve_type_id(c, largest_sized_field->data_type));
					} else {
						for (U32 field_idx = 0; field_idx < d->fields_count; field_idx += 1) {
							HccCompoundField* field = hcc_stack_get(c->astgen.compound_fields, d->fields_start_idx + field_idx);
							hcc_spirvgen_instr_add_operand(c, hcc_spirvgen_resolve_type_id(c, field->data_type));
						}
					}

					hcc_spirvgen_instr_end(c);
					switch (d->kind) {
						case HCC_COMPOUND_DATA_TYPE_KIND_RASTERIZER_STATE:
							for (U32 field_idx = 0; field_idx < d->fields_count; field_idx += 1) {
								HccCompoundField* field = hcc_stack_get(c->astgen.compound_fields, d->fields_start_idx + field_idx);
								HccDataType field_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, field->data_type);
								hcc_spirvgen_generate_variable_type(c, field_data_type, HCC_SPIRV_TYPE_KIND_FUNCTION_VARIABLE_POINTER_INPUT);
								hcc_spirvgen_generate_variable_type(c, field_data_type, HCC_SPIRV_TYPE_KIND_FUNCTION_VARIABLE_POINTER_OUTPUT);
							}
							break;
						case HCC_COMPOUND_DATA_TYPE_KIND_FRAGMENT_STATE:
							for (U32 field_idx = 0; field_idx < d->fields_count; field_idx += 1) {
								HccCompoundField* field = hcc_stack_get(c->astgen.compound_fields, d->fields_start_idx + field_idx);
								HccDataType field_data_type = hcc_typedef_resolve_and_strip_const_volatile(c, field->data_type);
								hcc_spirvgen_generate_variable_type(c, field_data_type, HCC_SPIRV_TYPE_KIND_FUNCTION_VARIABLE_POINTER_OUTPUT);
							}
							break;
					}
					break;
				};
				case HCC_DATA_TYPE_ARRAY: {
					HccArrayDataType* d = hcc_array_data_type_get(c, data_type);

					hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_TYPE_ARRAY);
					hcc_spirvgen_instr_add_operand(c, c->spirvgen.array_type_base_id + HCC_DATA_TYPE_IDX(data_type));
					hcc_spirvgen_instr_add_operand(c, hcc_spirvgen_resolve_type_id(c, d->element_data_type));
					hcc_spirvgen_instr_add_operand(c, c->spirvgen.constant_base_id + d->size_constant_id.idx_plus_one - 1);
					hcc_spirvgen_instr_end(c);
					break;
				};
			}
		}
	}

	hcc_spirvgen_generate_intrinsic_input_variable(c, HCC_STRUCT_IDX_VERTEX_INPUT);
	hcc_spirvgen_generate_intrinsic_input_variable(c, HCC_STRUCT_IDX_FRAGMENT_INPUT);

	hcc_spirvgen_generate_non_basic_type_constants(c);

	c->spirvgen.ext_inst_glsl_std_450_spirv_id = c->spirvgen.next_id;
	hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_EXT_INST_IMPORT);
	hcc_spirvgen_instr_add_result_operand(c);
	hcc_spirvgen_instr_add_operands_string_lit(c, "GLSL.std.450");
	hcc_spirvgen_instr_end(c);

	hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_MEMORY_MODEL);
	hcc_spirvgen_instr_add_operand(c, HCC_SPIRV_ADDRESS_MODEL_PHYSICAL_STORAGE_BUFFER_64);
	hcc_spirvgen_instr_add_operand(c, HCC_SPIRV_MEMORY_MODEL_VULKAN);
	hcc_spirvgen_instr_end(c);

	hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_CAPABILITY);
	hcc_spirvgen_instr_add_operand(c, HCC_SPIRV_CAPABILITY_SHADER);
	hcc_spirvgen_instr_end(c);

	hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_CAPABILITY);
	hcc_spirvgen_instr_add_operand(c, HCC_SPIRV_CAPABILITY_VULKAN_MEMORY_MODEL);
	hcc_spirvgen_instr_end(c);

	// TODO: i don't know if we can support unions if we don't use this.
	// this allows us to bitcast a pointer, so we can bitcast a union to it's field type.
	// this is the SPIRV side to VK_KHR_buffer_device_address.
	hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_CAPABILITY);
	hcc_spirvgen_instr_add_operand(c, HCC_SPIRV_CAPABILITY_PHYSICAL_STORAGE_BUFFER);
	hcc_spirvgen_instr_end(c);

	//
	// generate the global variable types before we make the global variables as the global variables have a linear spirv id range
	for (U32 global_variable_idx = 0; global_variable_idx < hcc_stack_count(c->astgen.global_variables); global_variable_idx += 1) {
		HccVariable* variable = hcc_stack_get(c->astgen.global_variables, global_variable_idx);
		hcc_spirvgen_generate_variable_type(c, variable->data_type, HCC_SPIRV_TYPE_KIND_STATIC_VARIABLE);
	}

	c->spirvgen.global_variable_base_spirv_id = c->spirvgen.next_id;
	c->spirvgen.next_id += hcc_stack_count(c->astgen.global_variables);
	for (U32 global_variable_idx = 0; global_variable_idx < hcc_stack_count(c->astgen.global_variables); global_variable_idx += 1) {
		HccVariable* variable = hcc_stack_get(c->astgen.global_variables, global_variable_idx);
		U32 type_spirv_id = hcc_spirvgen_generate_variable_type(c, variable->data_type, HCC_SPIRV_TYPE_KIND_STATIC_VARIABLE);
		hcc_spirvgen_instr_start(c, HCC_SPIRV_OP_VARIABLE);
		hcc_spirvgen_instr_add_operand(c, type_spirv_id);
		hcc_spirvgen_instr_add_operand(c, c->spirvgen.global_variable_base_spirv_id + global_variable_idx);
		hcc_spirvgen_instr_add_operand(c, HCC_SPIRV_STORAGE_CLASS_PRIVATE);
		hcc_spirvgen_instr_add_converted_operand(c, HCC_IR_OPERAND_CONSTANT_INIT(variable->initializer_constant_id.idx_plus_one));
		hcc_spirvgen_instr_end(c);
	}

	c->spirvgen.function_base_spirv_id = c->spirvgen.next_id;
	c->spirvgen.next_id += hcc_stack_count(c->astgen.functions) - HCC_FUNCTION_IDX_USER_START;
	for (U32 used_function_idx = 0; used_function_idx < hcc_stack_count(c->astgen.used_function_indices); used_function_idx += 1) {
		U32 function_idx = c->astgen.used_function_indices[used_function_idx];
		hcc_spirvgen_generate_function(c, function_idx);
	}

	hcc_spirvgen_generate_binary(c);
}

#endif

// ===========================================
//
//
// Constant Table
//
//
// ===========================================

void hcc_constant_table_init(HccCompiler* c, uint32_t data_cap, uint32_t entries_cap) {
	c->constant_table.data = HCC_ALLOC_ARRAY(char, HCC_ALLOC_TAG_CONSTANT_TABLE_DATA, data_cap);
	if (c->constant_table.data == NULL) {
		hcc_compiler_bail_allocation_failure(_hcc_compiler_ptr, HCC_ALLOC_TAG_CONSTANT_TABLE_DATA);
	}

	c->constant_table.entries = HCC_ALLOC_ARRAY(HccConstantEntry, HCC_ALLOC_TAG_CONSTANT_TABLE_ENTRIES, entries_cap);
	if (c->constant_table.entries == NULL) {
		hcc_compiler_bail_allocation_failure(_hcc_compiler_ptr, HCC_ALLOC_TAG_CONSTANT_TABLE_ENTRIES);
	}

	HCC_ASSERT(c->constant_table.entries, "out of memory");
	c->constant_table.data_cap = data_cap;
	c->constant_table.entries_cap = entries_cap;
}

HccConstantId hcc_constant_table_deduplicate_basic(HccCompiler* c, HccDataType data_type, HccBasic* basic) {
	HCC_DEBUG_ASSERT(HCC_DATA_TYPE_IS_BASIC(data_type), "internal error: expected a basic type but got '%s'", hcc_data_type_string(c, data_type));
	HCC_DEBUG_ASSERT(c->constant_table.fields_cap == 0, "internal error: starting to deduplicate a constant before ending another");

	U64 size;
	U64 align;
	hcc_data_type_size_align(c, data_type, &size, &align);

	c->constant_table.data_write_ptr = NULL;
	HccStringId debug_string_id = {0};
	return _hcc_constant_table_deduplicate_end(c, data_type, basic, size, align, debug_string_id);
}

void hcc_constant_table_deduplicate_composite_start(HccCompiler* c, HccDataType data_type) {
	HCC_DEBUG_ASSERT(!HCC_DATA_TYPE_IS_BASIC(data_type), "internal error: expected a non basic type but got '%s'", hcc_data_type_string(c, data_type));
	HCC_DEBUG_ASSERT(c->constant_table.fields_cap == 0, "internal error: starting to deduplicate a constant before ending another");

	U32 fields_count;
	fields_count = hcc_data_type_composite_fields_count(c, data_type);

	c->constant_table.data_type = data_type;
	c->constant_table.fields_count = 0;
	c->constant_table.fields_cap = fields_count;
	c->constant_table.data_write_ptr = HCC_PTR_ROUND_UP_ALIGN(HCC_PTR_ADD(c->constant_table.data, c->constant_table.data_used_size), alignof(HccConstantId));
}

void hcc_constant_table_deduplicate_composite_add(HccCompiler* c, HccConstantId constant_id) {
	HCC_DEBUG_ASSERT(c->constant_table.fields_cap, "internal error: cannot add data when deduplication of constant has not started");
	HCC_DEBUG_ASSERT(c->constant_table.fields_count < c->constant_table.fields_cap, "internal error: the expected constant with '%u' fields has been exceeded", c->constant_table.fields_cap);

	c->constant_table.data_write_ptr[c->constant_table.fields_count] = constant_id;
	c->constant_table.fields_count += 1;
}

HccConstantId hcc_constant_table_deduplicate_composite_end(HccCompiler* c) {
	HCC_DEBUG_ASSERT(c->constant_table.fields_count == c->constant_table.fields_cap, "internal error: the composite constant for deduplication is incomplete, expected to be '%u' fields but got '%u'", c->constant_table.fields_count, c->constant_table.fields_cap);
	c->constant_table.fields_cap = 0;

	HccStringId debug_string_id = {0};
	return _hcc_constant_table_deduplicate_end(c, c->constant_table.data_type, c->constant_table.data_write_ptr, c->constant_table.fields_count * sizeof(HccConstantId), alignof(HccConstantId), debug_string_id);
}

HccConstantId hcc_constant_table_deduplicate_zero(HccCompiler* c, HccDataType data_type) {
	if (HCC_DATA_TYPE_IS_BASIC(data_type)) {
		//
		// basic type's need to store their zero data into the consant table. this is so that
		// when the spirv code is generated it will generate OpConstant instructions for the consants instead of OpConstantNull.
		// this will allow them to be used as indices in OpAccessChain.
		HccBasic zero = {0};
		return hcc_constant_table_deduplicate_basic(c, data_type, &zero);
	} else {
		HCC_DEBUG_ASSERT(c->constant_table.fields_cap == 0, "internal error: starting to deduplicate a constant before ending another");
		HccStringId debug_string_id = {0};
		return _hcc_constant_table_deduplicate_end(c, data_type, NULL, 0, 0, debug_string_id);
	}
}

HccConstantId _hcc_constant_table_deduplicate_end(HccCompiler* c, HccDataType data_type, void* data, U32 data_size, U32 data_align, HccStringId debug_string_id) {
	//
	// TODO: make this a hash table look up
	for (uint32_t entry_idx = 0; entry_idx < c->constant_table.entries_count; entry_idx += 1) {
		HccConstantEntry* entry = &c->constant_table.entries[entry_idx];
		if (entry->data_type == data_type && data_size == entry->size && memcmp(HCC_PTR_ADD(c->constant_table.data, entry->start_idx), data, data_size) == 0) {
			return (HccConstantId) { .idx_plus_one = entry_idx + 1 };
		}
	}

	if (c->constant_table.entries_count >= c->constant_table.entries_cap) {
		HCC_ABORT("constant tables entries capacity exceeded TODO make this error message proper");
	}

	if (c->constant_table.data_used_size + data_size > c->constant_table.data_cap) {
		HCC_ABORT("constant tables entries capacity exceeded TODO make this error message proper");
	}

	uint32_t new_entry_idx = c->constant_table.entries_count;
	c->constant_table.entries_count += 1;
	HccConstantEntry* entry = &c->constant_table.entries[new_entry_idx];
	entry->size = data_size;
	entry->data_type = data_type;
	entry->debug_string_id = debug_string_id;

	if (data_align) {
		c->constant_table.data_used_size = HCC_INT_ROUND_UP_ALIGN(c->constant_table.data_used_size, data_align);
		entry->start_idx = c->constant_table.data_used_size;
		c->constant_table.data_used_size += data_size;
	}

	if (c->constant_table.data_write_ptr != data && data_size) {
		memcpy(HCC_PTR_ADD(c->constant_table.data, entry->start_idx), data, data_size);
	}

	return (HccConstantId) { .idx_plus_one = new_entry_idx + 1 };
}

HccConstant hcc_constant_table_get(HccCompiler* c, HccConstantId id) {
	HCC_DEBUG_ASSERT(id.idx_plus_one, "constant id is null");

	HccConstantEntry* entry = &c->constant_table.entries[id.idx_plus_one - 1];

	HccConstant constant;
	constant.data_type = entry->data_type;
	constant.data = HCC_PTR_ADD(c->constant_table.data, entry->start_idx);
	constant.size = entry->size;
	return constant;
}

void hcc_constant_print(HccCompiler* c, HccConstantId constant_id, FILE* f) {
	HccConstant constant = hcc_constant_table_get(c, constant_id);
	if (constant.size == 0) {
		HccString data_type_name = hcc_data_type_string(c, constant.data_type);
		fprintf(f, "%.*s: <ZERO>", (int)data_type_name.size, data_type_name.data);
		return;
	}

	if (constant.data_type < HCC_DATA_TYPE_BASIC_END) {
		hcc_data_type_print_basic(c, constant.data_type, constant.data, f);
	} else {
		HCC_ABORT("unhandled type '%u'", constant.data_type);
	}
}

bool hcc_constant_as_uint(HccCompiler* c, HccConstant constant, U64* out) {
	if (!HCC_DATA_TYPE_IS_BASIC(constant.data_type)) {
		return false;
	}

	switch (c->basic_type_size_and_aligns[constant.data_type]) {
		case sizeof(U8): *out = *(U8*)constant.data; break;
		case sizeof(U16): *out = *(U16*)constant.data; break;
		case sizeof(U32): *out = *(U32*)constant.data; break;
		case sizeof(U64): *out = *(U64*)constant.data; break;
	}

	if (HCC_DATA_TYPE_IS_SINT(c, constant.data_type)) {
		if ((S64)*out < 0) {
			return false;
		}
	}

	return true;
}

bool hcc_constant_as_sint(HccCompiler* c, HccConstant constant, S64* out) {
	if (!HCC_DATA_TYPE_IS_BASIC(constant.data_type)) {
		return false;
	}

	switch (c->basic_type_size_and_aligns[constant.data_type]) {
		case sizeof(U8): *out = *(U8*)constant.data; break;
		case sizeof(U16): *out = *(U16*)constant.data; break;
		case sizeof(U32): *out = *(U32*)constant.data; break;
		case sizeof(U64): *out = *(U64*)constant.data; break;
	}

	if (
		HCC_DATA_TYPE_IS_UINT(c, constant.data_type) &&
		c->basic_type_size_and_aligns[constant.data_type] == sizeof(U64)
	) {
		if ((U64)*out > INT64_MAX) {
			return false;
		}
	}

	return true;
}

bool hcc_constant_as_sint32(HccCompiler* c, HccConstant constant, S32* out) {
	if (!HCC_DATA_TYPE_IS_BASIC(constant.data_type)) {
		return false;
	}

	S64 value;
	switch (c->basic_type_size_and_aligns[constant.data_type]) {
		case sizeof(U8): value = *(S8*)constant.data; break;
		case sizeof(U16): value = *(S16*)constant.data; break;
		case sizeof(U32): value = *(S32*)constant.data; break;
		case sizeof(U64): value = *(S64*)constant.data; break;
	}

	if (value < INT32_MIN || value > INT32_MAX) {
		return false;
	}

	*out = value;
	return true;
}

bool hcc_constant_as_float(HccCompiler* c, HccConstant constant, F64* out) {
	if (!HCC_DATA_TYPE_IS_BASIC(constant.data_type)) {
		return false;
	}

	switch (constant.data_type) {
		case HCC_DATA_TYPE_FLOAT: *out = *(F32*)constant.data; return true;
		case HCC_DATA_TYPE_DOUBLE: *out = *(F64*)constant.data; return true;
		default:
			if (HCC_DATA_TYPE_IS_UINT(c, constant.data_type)) {
				switch (c->basic_type_size_and_aligns[constant.data_type]) {
					case sizeof(U8): *out = *(U8*)constant.data; return true;
					case sizeof(U16): *out = *(U16*)constant.data; return true;
					case sizeof(U32): *out = *(U32*)constant.data; return true;
					case sizeof(U64): *out = *(U64*)constant.data; return true;
				}
			} else if (HCC_DATA_TYPE_IS_SINT(c, constant.data_type)) {
				switch (c->basic_type_size_and_aligns[constant.data_type]) {
					case sizeof(U8): *out = *(S8*)constant.data; return true;
					case sizeof(U16): *out = *(S16*)constant.data; return true;
					case sizeof(U32): *out = *(S32*)constant.data; return true;
					case sizeof(U64): *out = *(S64*)constant.data; return true;
				}
			}
			break;
	}

	return false;
}

// ===========================================
//
//
// String Table
//
//
// ===========================================

void hcc_string_table_init(HccStringTable* string_table, U32 data_cap, U32 entries_cap) {
	string_table->data = HCC_ALLOC_ARRAY(char, HCC_ALLOC_TAG_STRING_TABLE_DATA, data_cap);
	if (string_table->data == NULL) {
		hcc_compiler_bail_allocation_failure(_hcc_compiler_ptr, HCC_ALLOC_TAG_STRING_TABLE_DATA);
	}

	string_table->entries = HCC_ALLOC_ARRAY(HccStringEntry, HCC_ALLOC_TAG_STRING_TABLE_ENTRIES, entries_cap);
	if (string_table->entries == NULL) {
		hcc_compiler_bail_allocation_failure(_hcc_compiler_ptr, HCC_ALLOC_TAG_STRING_TABLE_ENTRIES);
	}

	string_table->data_cap = data_cap;
	string_table->entries_cap = entries_cap;
}

HccStringId hcc_string_table_deduplicate(HccStringTable* string_table, const char* string, U32 string_size) {
	//
	// TODO: make this a hash table look up
	for (U32 entry_idx = 0; entry_idx < string_table->entries_count; entry_idx += 1) {
		HccStringEntry* entry = &string_table->entries[entry_idx];

		if (string_size == entry->size && memcmp(string_table->data + entry->start_idx, string, string_size) == 0) {
			return (HccStringId) { .idx_plus_one = entry_idx + 1 };
		}
	}

	if (string_table->entries_count >= string_table->entries_cap) {
		HCC_ABORT("string tables entries capacity exceeded TODO make this error message proper");
	}

	if (string_table->data_used_size + string_size >= string_table->data_cap) {
		HCC_ABORT("string tables entries capacity exceeded TODO make this error message proper");
	}


	U32 new_entry_idx = string_table->entries_count;
	string_table->entries_count += 1;
	HccStringEntry* entry = &string_table->entries[new_entry_idx];
	entry->start_idx = string_table->data_used_size;
	entry->size = string_size;

	memcpy(string_table->data + string_table->data_used_size, string, string_size);
	string_table->data_used_size += string_size;

	return (HccStringId) { .idx_plus_one = new_entry_idx + 1 };
}

HccString hcc_string_table_get(HccStringTable* string_table, HccStringId id) {
	HCC_DEBUG_ASSERT(id.idx_plus_one, "string id is null");
	U32 idx = id.idx_plus_one - 1;
	HCC_DEBUG_ASSERT_ARRAY_BOUNDS(idx, string_table->entries_count);

	HccStringEntry* entry = &string_table->entries[idx];

	HccString string;
	string.data = string_table->data + entry->start_idx;
	string.size = entry->size;
	return string;
}

HccString hcc_string_table_get_or_empty(HccStringTable* string_table, HccStringId id) {
	if (id.idx_plus_one - 1 < string_table->entries_count) {
		return hcc_string_table_get(string_table, id);
	}

	return hcc_string_lit("");
}

char* hcc_string_intrinsic_param_names[HCC_STRING_ID_INTRINSIC_PARAM_NAMES_END] = {
	[HCC_STRING_ID_UINT8_T] = "uint8_t",
	[HCC_STRING_ID_UINT16_T] = "uint16_t",
	[HCC_STRING_ID_UINT32_T] = "uint32_t",
	[HCC_STRING_ID_UINT64_T] = "uint64_t",
	[HCC_STRING_ID_UINTPTR_T] = "uintptr_t",
	[HCC_STRING_ID_INT8_T] = "int8_t",
	[HCC_STRING_ID_INT16_T] = "int16_t",
	[HCC_STRING_ID_INT32_T] = "int32_t",
	[HCC_STRING_ID_INT64_T] = "int64_t",
	[HCC_STRING_ID_INTPTR_T] = "intptr_t",
	[HCC_STRING_ID_HCC_VERTEX_INPUT] = "HccVertexInput",
	[HCC_STRING_ID_VERTEX_IDX] = "vertex_idx",
	[HCC_STRING_ID_INSTANCE_IDX] = "instance_idx",
	[HCC_STRING_ID_HCC_FRAGMENT_INPUT] = "HccFragmentInput",
	[HCC_STRING_ID_FRAG_COORD] = "frag_coord",
	[HCC_STRING_ID_HALF] = "half",
	[HCC_STRING_ID__BITS] = "_bits",
	[HCC_STRING_ID_PVEC_START + HCC_VEC2BOOL] = "pvec2bool",
	[HCC_STRING_ID_PVEC_START + HCC_VEC2U8] = "pvec2u8",
	[HCC_STRING_ID_PVEC_START + HCC_VEC2U16] = "pvec2u16",
	[HCC_STRING_ID_PVEC_START + HCC_VEC2U32] = "pvec2u32",
	[HCC_STRING_ID_PVEC_START + HCC_VEC2U64] = "pvec2u64",
	[HCC_STRING_ID_PVEC_START + HCC_VEC2I8] = "pvec2i8",
	[HCC_STRING_ID_PVEC_START + HCC_VEC2I16] = "pvec2i16",
	[HCC_STRING_ID_PVEC_START + HCC_VEC2I32] = "pvec2i32",
	[HCC_STRING_ID_PVEC_START + HCC_VEC2I64] = "pvec2i64",
	[HCC_STRING_ID_PVEC_START + HCC_VEC2F16] = "pvec2f16",
	[HCC_STRING_ID_PVEC_START + HCC_VEC2F32] = "pvec2f32",
	[HCC_STRING_ID_PVEC_START + HCC_VEC2F64] = "pvec2f64",
	[HCC_STRING_ID_PVEC_START + HCC_VEC3BOOL] = "pvec3bool",
	[HCC_STRING_ID_PVEC_START + HCC_VEC3U8] = "pvec3u8",
	[HCC_STRING_ID_PVEC_START + HCC_VEC3U16] = "pvec3u16",
	[HCC_STRING_ID_PVEC_START + HCC_VEC3U32] = "pvec3u32",
	[HCC_STRING_ID_PVEC_START + HCC_VEC3U64] = "pvec3u64",
	[HCC_STRING_ID_PVEC_START + HCC_VEC3I8] = "pvec3i8",
	[HCC_STRING_ID_PVEC_START + HCC_VEC3I16] = "pvec3i16",
	[HCC_STRING_ID_PVEC_START + HCC_VEC3I32] = "pvec3i32",
	[HCC_STRING_ID_PVEC_START + HCC_VEC3I64] = "pvec3i64",
	[HCC_STRING_ID_PVEC_START + HCC_VEC3F16] = "pvec3f16",
	[HCC_STRING_ID_PVEC_START + HCC_VEC3F32] = "pvec3f32",
	[HCC_STRING_ID_PVEC_START + HCC_VEC3F64] = "pvec3f64",
	[HCC_STRING_ID_PVEC_START + HCC_VEC4BOOL] = "pvec4bool",
	[HCC_STRING_ID_PVEC_START + HCC_VEC4U8] = "pvec4u8",
	[HCC_STRING_ID_PVEC_START + HCC_VEC4U16] = "pvec4u16",
	[HCC_STRING_ID_PVEC_START + HCC_VEC4U32] = "pvec4u32",
	[HCC_STRING_ID_PVEC_START + HCC_VEC4U64] = "pvec4u64",
	[HCC_STRING_ID_PVEC_START + HCC_VEC4I8] = "pvec4i8",
	[HCC_STRING_ID_PVEC_START + HCC_VEC4I16] = "pvec4i16",
	[HCC_STRING_ID_PVEC_START + HCC_VEC4I32] = "pvec4i32",
	[HCC_STRING_ID_PVEC_START + HCC_VEC4I64] = "pvec4i64",
	[HCC_STRING_ID_PVEC_START + HCC_VEC4F16] = "pvec4f16",
	[HCC_STRING_ID_PVEC_START + HCC_VEC4F32] = "pvec4f32",
	[HCC_STRING_ID_PVEC_START + HCC_VEC4F64] = "pvec4f64",
	[HCC_STRING_ID_VEC_START + HCC_VEC2BOOL] = "vec2bool",
	[HCC_STRING_ID_VEC_START + HCC_VEC2U8] = "vec2u8",
	[HCC_STRING_ID_VEC_START + HCC_VEC2U16] = "vec2u16",
	[HCC_STRING_ID_VEC_START + HCC_VEC2U32] = "vec2u32",
	[HCC_STRING_ID_VEC_START + HCC_VEC2U64] = "vec2u64",
	[HCC_STRING_ID_VEC_START + HCC_VEC2I8] = "vec2i8",
	[HCC_STRING_ID_VEC_START + HCC_VEC2I16] = "vec2i16",
	[HCC_STRING_ID_VEC_START + HCC_VEC2I32] = "vec2i32",
	[HCC_STRING_ID_VEC_START + HCC_VEC2I64] = "vec2i64",
	[HCC_STRING_ID_VEC_START + HCC_VEC2F16] = "vec2f16",
	[HCC_STRING_ID_VEC_START + HCC_VEC2F32] = "vec2f32",
	[HCC_STRING_ID_VEC_START + HCC_VEC2F64] = "vec2f64",
	[HCC_STRING_ID_VEC_START + HCC_VEC3BOOL] = "vec3bool",
	[HCC_STRING_ID_VEC_START + HCC_VEC3U8] = "vec3u8",
	[HCC_STRING_ID_VEC_START + HCC_VEC3U16] = "vec3u16",
	[HCC_STRING_ID_VEC_START + HCC_VEC3U32] = "vec3u32",
	[HCC_STRING_ID_VEC_START + HCC_VEC3U64] = "vec3u64",
	[HCC_STRING_ID_VEC_START + HCC_VEC3I8] = "vec3i8",
	[HCC_STRING_ID_VEC_START + HCC_VEC3I16] = "vec3i16",
	[HCC_STRING_ID_VEC_START + HCC_VEC3I32] = "vec3i32",
	[HCC_STRING_ID_VEC_START + HCC_VEC3I64] = "vec3i64",
	[HCC_STRING_ID_VEC_START + HCC_VEC3F16] = "vec3f16",
	[HCC_STRING_ID_VEC_START + HCC_VEC3F32] = "vec3f32",
	[HCC_STRING_ID_VEC_START + HCC_VEC3F64] = "vec3f64",
	[HCC_STRING_ID_VEC_START + HCC_VEC4BOOL] = "vec4bool",
	[HCC_STRING_ID_VEC_START + HCC_VEC4U8] = "vec4u8",
	[HCC_STRING_ID_VEC_START + HCC_VEC4U16] = "vec4u16",
	[HCC_STRING_ID_VEC_START + HCC_VEC4U32] = "vec4u32",
	[HCC_STRING_ID_VEC_START + HCC_VEC4U64] = "vec4u64",
	[HCC_STRING_ID_VEC_START + HCC_VEC4I8] = "vec4i8",
	[HCC_STRING_ID_VEC_START + HCC_VEC4I16] = "vec4i16",
	[HCC_STRING_ID_VEC_START + HCC_VEC4I32] = "vec4i32",
	[HCC_STRING_ID_VEC_START + HCC_VEC4I64] = "vec4i64",
	[HCC_STRING_ID_VEC_START + HCC_VEC4F16] = "vec4f16",
	[HCC_STRING_ID_VEC_START + HCC_VEC4F32] = "vec4f32",
	[HCC_STRING_ID_VEC_START + HCC_VEC4F64] = "vec4f64",
	[HCC_STRING_ID_PMAT_START + HCC_MAT22F32] = "pmat22f32",
	[HCC_STRING_ID_PMAT_START + HCC_MAT22F64] = "pmat22f64",
	[HCC_STRING_ID_PMAT_START + HCC_MAT23F32] = "pmat23f32",
	[HCC_STRING_ID_PMAT_START + HCC_MAT23F64] = "pmat23f64",
	[HCC_STRING_ID_PMAT_START + HCC_MAT24F32] = "pmat24f32",
	[HCC_STRING_ID_PMAT_START + HCC_MAT24F64] = "pmat24f64",
	[HCC_STRING_ID_PMAT_START + HCC_MAT32F32] = "pmat32f32",
	[HCC_STRING_ID_PMAT_START + HCC_MAT32F64] = "pmat32f64",
	[HCC_STRING_ID_PMAT_START + HCC_MAT33F32] = "pmat33f32",
	[HCC_STRING_ID_PMAT_START + HCC_MAT33F64] = "pmat33f64",
	[HCC_STRING_ID_PMAT_START + HCC_MAT34F32] = "pmat34f32",
	[HCC_STRING_ID_PMAT_START + HCC_MAT34F64] = "pmat34f64",
	[HCC_STRING_ID_PMAT_START + HCC_MAT42F32] = "pmat42f32",
	[HCC_STRING_ID_PMAT_START + HCC_MAT42F64] = "pmat42f64",
	[HCC_STRING_ID_PMAT_START + HCC_MAT43F32] = "pmat43f32",
	[HCC_STRING_ID_PMAT_START + HCC_MAT43F64] = "pmat43f64",
	[HCC_STRING_ID_PMAT_START + HCC_MAT44F32] = "pmat44f32",
	[HCC_STRING_ID_PMAT_START + HCC_MAT44F64] = "pmat44f64",
	[HCC_STRING_ID_MAT_START + HCC_MAT22F32] = "mat22f32",
	[HCC_STRING_ID_MAT_START + HCC_MAT22F64] = "mat22f64",
	[HCC_STRING_ID_MAT_START + HCC_MAT23F32] = "mat23f32",
	[HCC_STRING_ID_MAT_START + HCC_MAT23F64] = "mat23f64",
	[HCC_STRING_ID_MAT_START + HCC_MAT24F32] = "mat24f32",
	[HCC_STRING_ID_MAT_START + HCC_MAT24F64] = "mat24f64",
	[HCC_STRING_ID_MAT_START + HCC_MAT32F32] = "mat32f32",
	[HCC_STRING_ID_MAT_START + HCC_MAT32F64] = "mat32f64",
	[HCC_STRING_ID_MAT_START + HCC_MAT33F32] = "mat33f32",
	[HCC_STRING_ID_MAT_START + HCC_MAT33F64] = "mat33f64",
	[HCC_STRING_ID_MAT_START + HCC_MAT34F32] = "mat34f32",
	[HCC_STRING_ID_MAT_START + HCC_MAT34F64] = "mat34f64",
	[HCC_STRING_ID_MAT_START + HCC_MAT42F32] = "mat42f32",
	[HCC_STRING_ID_MAT_START + HCC_MAT42F64] = "mat42f64",
	[HCC_STRING_ID_MAT_START + HCC_MAT43F32] = "mat43f32",
	[HCC_STRING_ID_MAT_START + HCC_MAT43F64] = "mat43f64",
	[HCC_STRING_ID_MAT_START + HCC_MAT44F32] = "mat44f32",
	[HCC_STRING_ID_MAT_START + HCC_MAT44F64] = "mat44f64",
};

// ===========================================
//
//
// Compiler
//
//
// ===========================================

HccCompilerSetup hcc_compiler_setup_default = {
	.pp = {
		.macro_tokens_cap = 64 * 1024,
		.macro_token_values_cap = 64 * 1024,
		.macros_cap = 64 * 1024,
		.macro_params_cap = 64 * 1024,
		.macro_args_stack_cap = 64 * 1024,
		.expand_stack_cap = 64 * 1024,
		.stringify_buffer_cap = 64 * 1024,
		.if_stack_cap = 64 * 1024,
	},
	.tokengen = {
		.tokens_cap = 256 * 1024,
		.token_values_cap = 64 * 1024,
		.token_locations_cap = 256 * 1024,
		.paused_file_stack_cap = 64 * 1024,
		.open_bracket_stack_cap = 64 * 1024,
	},
	.astgen = {
		.function_params_and_variables_cap = 64 * 1024,
		.functions_cap = 64 * 1024,
		.exprs_cap = 64 * 1024,
		.expr_locations_cap = 64 * 1024,
		.global_variables_cap = 64 * 1024,
		.function_used_function_indices_cap = 64 * 1024,
		.function_used_static_variables_cap = 64 * 1024,
		.entry_point_function_indices_cap = 64 * 1024,
		.used_function_indices_cap = 64 * 1024,
		.recursive_function_indices_stack_cap = 64 * 1024,
		.array_data_types_cap = 64 * 1024,
		.struct_data_types_cap = 64 * 1024,
		.union_data_types_cap = 64 * 1024,
		.compound_fields_cap = 64 * 1024,
		.compound_type_fields_cap = 64 * 1024,
		.typedefs_cap = 64 * 1024,
		.enum_data_types_cap = 64 * 1024,
		.enum_values_cap = 64 * 1024,
		.ordered_data_types_cap = 64 * 1024,
		.compound_type_find_fields_cap = 64 * 1024,
		.curly_initializer_nested_cap = 64 * 1024,
		.curly_initializer_nested_curlys_cap = 64 * 1024,
		.curly_initializer_nested_elmts_cap = 64 * 1024,
		.curly_initializer_designator_initializers_cap = 64 * 1024,
		.curly_initializer_designator_initializer_elmt_indices_cap = 64 * 1024,
		.variable_stack_cap = 64 * 1024,
	},
	.irgen = {
		.functions_cap = 64 * 1024,
		.basic_blocks_cap = 64 * 1024,
		.values_cap = 64 * 1024,
		.words_cap = 64 * 1024,
		.function_call_param_data_types_cap = 64 * 1024,
	},
	/*
	.spirvgen = {
		.out_capabilities_cap = 64 * 1024,
		.out_entry_points_cap = 64 * 1024,
		.out_debug_info_cap = 64 * 1024,
		.out_annotations_cap = 64 * 1024,
		.out_types_variables_constants_cap = 64 * 1024,
		.out_functions_cap = 64 * 1024,
	},
	*/

	.messages_cap = 64 * 1024,
	.message_strings_cap = 4 * 1024 * 1024,
	.string_table_data_cap = 64 * 1024,
	.string_table_entries_cap = 64 * 1024,
	.string_buffer_cap = 64 * 1024,
	.include_paths_cap = 64 * 1024,
	.code_files_cap = 64 * 1024,
	.code_file_lines_cap = 64 * 1024,
	.code_file_pp_if_spans_cap = 64 * 1024,
};

void hcc_string_table_intrinsic_add(HccCompiler* c, U32 expected_string_id, const char* string) {
	HccStringId id = hcc_string_table_deduplicate(&c->string_table, string, strlen(string));
	HCC_DEBUG_ASSERT(id.idx_plus_one == expected_string_id, "intrinsic string id for '%s' does not match! expected '%u' but got '%u'", string, expected_string_id, id.idx_plus_one);
}

bool hcc_compiler_init(HccCompiler* c, HccCompilerSetup* setup) {
	if (setjmp(c->compile_entry_jmp_loc)) {
		return false;
	}
	c->flags |= HCC_COMPILER_FLAGS_SET_LONG_JMP;
	c->code_file_lines_cap = setup->code_file_lines_cap;
	c->code_file_pp_if_spans_cap = setup->code_file_pp_if_spans_cap;
	hcc_options_set_enabled(c, HCC_OPTION_PRINT_COLOR);
	c->arch = HCC_ARCH_X86_64;
	c->os = HCC_OS_LINUX;

	switch (c->arch) {
		case HCC_ARCH_X86_64:
			switch (c->os) {
				case HCC_OS_LINUX:
					c->basic_type_size_and_aligns = hcc_basic_type_size_and_aligns_x86_64_linux;
					c->basic_type_int_mins = hcc_basic_type_int_mins_x86_64_linux;
					c->basic_type_int_maxes = hcc_basic_type_int_maxes_x86_64_linux;
					break;
				default: HCC_ABORT("internal error: unhandled OS for the X86_64 architecture");
			}
			break;
		default: HCC_ABORT("internal error: unhandled architecture");
	}

	c->message_sys.elmts = hcc_stack_init(HccMessage, setup->messages_cap, HCC_ALLOC_TAG_MESSAGES);
	c->message_sys.deferred_elmts = hcc_stack_init(HccMessage, setup->messages_cap, HCC_ALLOC_TAG_MESSAGES);
	c->message_sys.locations = hcc_stack_init(HccLocation, setup->messages_cap * 2, HCC_ALLOC_TAG_MESSAGES);
	c->message_sys.strings = hcc_stack_init(char, setup->message_strings_cap, HCC_ALLOC_TAG_MESSAGE_STRINGS);
	c->string_buffer = hcc_stack_init(char, setup->string_buffer_cap, HCC_ALLOC_TAG_STRING_BUFFER);
	c->include_paths = hcc_stack_init(HccString, setup->include_paths_cap, HCC_ALLOC_TAG_INCLUDE_PATHS);
	c->code_files = hcc_stack_init(HccCodeFile, setup->code_files_cap, HCC_ALLOC_TAG_CODE_FILES);
	hcc_hash_table_init(&c->path_to_code_file_id_map, setup->code_files_cap, HCC_ALLOC_TAG_PATH_TO_CODE_FILE_ID_MAP);

	hcc_constant_table_init(c, setup->string_table_data_cap, setup->string_table_entries_cap);
	{
		for (HccDataType data_type = HCC_DATA_TYPE_BOOL; data_type < HCC_DATA_TYPE_BASIC_COUNT; data_type += 1) {
			c->basic_type_zero_constant_ids[data_type] = hcc_constant_table_deduplicate_zero(c, data_type);
		}

		HccBasic one;
		one.u8 = 1;
		c->basic_type_one_constant_ids[HCC_DATA_TYPE_BOOL] = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_BOOL, &one);
		c->basic_type_one_constant_ids[HCC_DATA_TYPE_CHAR] = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_CHAR, &one);
		c->basic_type_one_constant_ids[HCC_DATA_TYPE_SCHAR] = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_SCHAR, &one);
		c->basic_type_one_constant_ids[HCC_DATA_TYPE_UCHAR] = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_UCHAR, &one);
		one = hcc_basic_from_sint(c, HCC_DATA_TYPE_SSHORT, 1);
		c->basic_type_one_constant_ids[HCC_DATA_TYPE_SSHORT] = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_SSHORT, &one);
		c->basic_type_one_constant_ids[HCC_DATA_TYPE_USHORT] = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_USHORT, &one);
		one = hcc_basic_from_sint(c, HCC_DATA_TYPE_SINT, 1);
		c->basic_type_one_constant_ids[HCC_DATA_TYPE_SINT] = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_SINT, &one);
		c->basic_type_one_constant_ids[HCC_DATA_TYPE_UINT] = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_UINT, &one);
		one = hcc_basic_from_sint(c, HCC_DATA_TYPE_SLONG, 1);
		c->basic_type_one_constant_ids[HCC_DATA_TYPE_SLONG] = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_SLONG, &one);
		c->basic_type_one_constant_ids[HCC_DATA_TYPE_ULONG] = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_ULONG, &one);
		one = hcc_basic_from_sint(c, HCC_DATA_TYPE_SLONGLONG, 1);
		c->basic_type_one_constant_ids[HCC_DATA_TYPE_SLONGLONG] = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_SLONGLONG, &one);
		c->basic_type_one_constant_ids[HCC_DATA_TYPE_ULONGLONG] = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_ULONGLONG, &one);
		one.f = 1.f;
		c->basic_type_one_constant_ids[HCC_DATA_TYPE_FLOAT] = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_FLOAT, &one);
		one.d = 1.f;
		c->basic_type_one_constant_ids[HCC_DATA_TYPE_DOUBLE] = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_DOUBLE, &one);

		HccBasic minus_one;
		minus_one.u8 = UINT8_MAX;
		c->basic_type_minus_one_constant_ids[HCC_DATA_TYPE_BOOL] = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_BOOL, &minus_one);
		c->basic_type_minus_one_constant_ids[HCC_DATA_TYPE_CHAR] = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_CHAR, &minus_one);
		c->basic_type_minus_one_constant_ids[HCC_DATA_TYPE_SCHAR] = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_SCHAR, &minus_one);
		c->basic_type_minus_one_constant_ids[HCC_DATA_TYPE_UCHAR] = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_UCHAR, &minus_one);
		minus_one = hcc_basic_from_sint(c, HCC_DATA_TYPE_SSHORT, -1);
		c->basic_type_minus_one_constant_ids[HCC_DATA_TYPE_SSHORT] = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_SSHORT, &minus_one);
		c->basic_type_minus_one_constant_ids[HCC_DATA_TYPE_USHORT] = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_USHORT, &minus_one);
		minus_one = hcc_basic_from_sint(c, HCC_DATA_TYPE_SINT, -1);
		c->basic_type_minus_one_constant_ids[HCC_DATA_TYPE_SINT] = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_SINT, &minus_one);
		c->basic_type_minus_one_constant_ids[HCC_DATA_TYPE_UINT] = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_UINT, &minus_one);
		minus_one = hcc_basic_from_sint(c, HCC_DATA_TYPE_SLONG, -1);
		c->basic_type_minus_one_constant_ids[HCC_DATA_TYPE_SLONG] = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_SLONG, &minus_one);
		c->basic_type_minus_one_constant_ids[HCC_DATA_TYPE_ULONG] = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_ULONG, &minus_one);
		minus_one = hcc_basic_from_sint(c, HCC_DATA_TYPE_SLONGLONG, -1);
		c->basic_type_minus_one_constant_ids[HCC_DATA_TYPE_SLONGLONG] = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_SLONGLONG, &minus_one);
		c->basic_type_minus_one_constant_ids[HCC_DATA_TYPE_ULONGLONG] = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_ULONGLONG, &minus_one);
		minus_one.f = -1.f;
		c->basic_type_minus_one_constant_ids[HCC_DATA_TYPE_FLOAT] = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_FLOAT, &minus_one);
		minus_one.d = -1.f;
		c->basic_type_minus_one_constant_ids[HCC_DATA_TYPE_DOUBLE] = hcc_constant_table_deduplicate_basic(c, HCC_DATA_TYPE_DOUBLE, &minus_one);
	}

	hcc_string_table_init(&c->string_table, setup->string_table_data_cap, setup->string_table_entries_cap);
	{
		for (U32 expected_string_id = HCC_STRING_ID_INTRINSIC_PARAM_NAMES_START; expected_string_id < HCC_STRING_ID_INTRINSIC_PARAM_NAMES_END; expected_string_id += 1) {
			char* string = hcc_string_intrinsic_param_names[expected_string_id];
			hcc_string_table_intrinsic_add(c, expected_string_id, string);
		}

		for (HccToken t = HCC_TOKEN_KEYWORDS_START; t < HCC_TOKEN_KEYWORDS_END; t += 1) {
			char* string = hcc_token_strings[t];
			U32 expected_string_id = HCC_STRING_ID_KEYWORDS_START + (t - HCC_TOKEN_KEYWORDS_START);
			hcc_string_table_intrinsic_add(c, expected_string_id, string);
		}

		for (U32 f = 0; f < HCC_FUNCTION_IDX_INTRINSIC_END; f += 1) {
			const char* string = hcc_intrinsic_function_strings[f];
			U32 expected_string_id = HCC_STRING_ID_FUNCTION_IDXS_START + f;
			hcc_string_table_intrinsic_add(c, expected_string_id, string);
		}

		for (HccPPPredefinedMacro m = 0; m < HCC_PP_PREDEFINED_MACRO_COUNT; m += 1) {
			char* string = hcc_pp_predefined_macro_identifier_strings[m];
			U32 expected_string_id = HCC_STRING_ID_PREDEFINED_MACROS_START + m;
			hcc_string_table_intrinsic_add(c, expected_string_id, string);
		}

		hcc_string_table_intrinsic_add(c, HCC_STRING_ID_ONCE, "once");
		hcc_string_table_intrinsic_add(c, HCC_STRING_ID_DEFINED, "defined");
		hcc_string_table_intrinsic_add(c, HCC_STRING_ID___VA_ARGS__, "__VA_ARGS__");
	}

	c->concat_buffer_code_file = hcc_code_file_init(c, hcc_string_table_deduplicate_lit(&c->string_table, "<concat buffer>\0"));

	//hcc_opt_set_enabled(&c->astgen.opts, HCC_OPTION_CONSTANT_FOLDING);

	hcc_pp_init(c, setup);
	hcc_tokengen_init(c, setup);
	hcc_astgen_init(c, setup);
	hcc_irgen_init(c, setup);
	//hcc_spirvgen_init(c, setup);

	return true;
}

bool hcc_compiler_compile(HccCompiler* c, char* file_path) {
	if (setjmp(c->compile_entry_jmp_loc)) {
		return false;
	}
	_hcc_compiler_ptr = c;
	c->flags |= HCC_COMPILER_FLAGS_SET_LONG_JMP;

	c->allocation_failure_alloc_tag = HCC_ALLOC_TAG_NONE;
	c->collection_is_full_alloc_tag = HCC_ALLOC_TAG_NONE;

	U32 file_path_size = strlen(file_path) + 1;

	HccCodeFileId code_file_id;
	HccCodeFile* code_file;
	bool found_file = hcc_code_file_find_or_insert(c, hcc_string_c(file_path), &code_file_id, &code_file);
	HCC_DEBUG_ASSERT(!found_file, "internal error: root file should be able to be inserted into the hash table no problem");

	U64 code_size;
	char* code = hcc_file_read_all_the_codes(file_path, &code_size);
	if (code == NULL) {
		char buf[512];
		hcc_get_last_system_error_string(buf, sizeof(buf));
		printf("failed to read file '%s': %s\n", file_path, buf);
	}

	code_file->flags |= HCC_CODE_FILE_FLAGS_COMPILATION_UNIT;
	code_file->code = hcc_string(code, code_size);

	hcc_tokengen_location_setup_new_file(c, code_file, true);
	hcc_tokengen_run(c, &c->tokengen.token_bag, HCC_TOKENGEN_RUN_MODE_CODE);

	hcc_astgen_generate(c);

	if (c->message_sys.used_type_flags & HCC_MESSAGE_TYPE_ERROR) {
		return false;
	}

	hcc_irgen_generate(c);
	//hcc_spirvgen_generate(c);

	hcc_tokengen_print(c, stdout);
	hcc_astgen_print(c, stdout);
	hcc_ir_print(c, stdout);

	c->flags &= ~HCC_COMPILER_FLAGS_SET_LONG_JMP;
	HCC_ZERO_ELMT(&c->compile_entry_jmp_loc);

	return !hcc_stack_count(c->message_sys.elmts);
}

noreturn void hcc_compiler_bail(HccCompiler* c) {
	HCC_DEBUG_ASSERT(c->flags & HCC_COMPILER_FLAGS_SET_LONG_JMP, "error: the long jump has not been set");
	longjmp(c->compile_entry_jmp_loc, 1);
}

noreturn void hcc_compiler_bail_allocation_failure(HccCompiler* c, HccAllocTag tag) {
	c->allocation_failure_alloc_tag = tag;
	hcc_compiler_bail(c);
}

noreturn void hcc_compiler_bail_collection_is_full(HccCompiler* c, HccAllocTag tag) {
	c->collection_is_full_alloc_tag = tag;
	hcc_compiler_bail(c);
}

bool hcc_options_is_enabled(HccCompiler* c, HccOption opt) {
	U64 bit = ((U64)1 << (opt % 64));
	return (c->options.bitset[opt / 64] & bit) == bit;
}

void hcc_options_set_enabled(HccCompiler* c, HccOption opt) {
	U64 bit = (U64)1 << (opt % 64);
	c->options.bitset[opt / 64] |= bit;
}

void hcc_options_set_disabled(HccCompiler* c, HccOption opt) {
	U64 bit = (U64)1 << (opt % 64);
	c->options.bitset[opt / 64] &= ~bit;
}

